"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@auth";
exports.ids = ["vendor-chunks/@auth"];
exports.modules = {

/***/ "(rsc)/./node_modules/@auth/firebase-adapter/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@auth/firebase-adapter/index.js ***!
  \******************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FirestoreAdapter: () => (/* binding */ FirestoreAdapter),\n/* harmony export */   collectionsFactory: () => (/* binding */ collectionsFactory),\n/* harmony export */   getDoc: () => (/* binding */ getDoc),\n/* harmony export */   getOneDoc: () => (/* binding */ getOneDoc),\n/* harmony export */   initFirestore: () => (/* binding */ initFirestore),\n/* harmony export */   mapFieldsFactory: () => (/* binding */ mapFieldsFactory)\n/* harmony export */ });\n/* harmony import */ var firebase_admin_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase-admin/app */ \"firebase-admin/app\");\n/* harmony import */ var firebase_admin_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase-admin/firestore */ \"firebase-admin/firestore\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([firebase_admin_app__WEBPACK_IMPORTED_MODULE_0__, firebase_admin_firestore__WEBPACK_IMPORTED_MODULE_1__]);\n([firebase_admin_app__WEBPACK_IMPORTED_MODULE_0__, firebase_admin_firestore__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n/**\n * Official **Firebase** adapter for Auth.js / NextAuth.js, using the [Firebase Admin SDK](https://firebase.google.com/docs/admin/setup)\n * and [Firestore](https://firebase.google.com/docs/firestore).\n * [![Firestore logo](https://authjs.dev/img/adapters/firebase.svg)](https://firebase.google.com)\n *\n * ## Installation\n *\n * ```bash npm2yarn\n * npm install @auth/firebase-adapter firebase-admin\n * ```\n *\n * @module @auth/firebase-adapter\n */ \n\n/**\n * ## Setup\n *\n * First, create a Firebase project and generate a service account key. Visit: `https://console.firebase.google.com/u/0/project/{project-id}/settings/serviceaccounts/adminsdk` (replace `{project-id}` with your project's id)\n *\n * Now you have a few options to authenticate with the Firebase Admin SDK in your app:\n *\n * ### Environment variables\n *  - Download the service account key and save it in your project. (Make sure to add the file to your `.gitignore`!)\n *  - Add [`GOOGLE_APPLICATION_CREDENTIALS`](https://cloud.google.com/docs/authentication/application-default-credentials#GAC) to your environment variables and point it to the service account key file.\n *  - The adapter will automatically pick up the environment variable and use it to authenticate with the Firebase Admin SDK.\n *\n * @example\n * ```ts title=\"pages/api/auth/[...nextauth].ts\"\n * import NextAuth from \"next-auth\"\n * import { FirestoreAdapter } from \"@auth/firebase-adapter\"\n *\n * export default NextAuth({\n *   adapter: FirestoreAdapter(),\n *   // ...\n * })\n * ```\n *\n * ### Service account values\n *\n * - Download the service account key to a temporary location. (Make sure to not commit this file to your repository!)\n * - Add the following environment variables to your project: `FIREBASE_PROJECT_ID`, `FIREBASE_CLIENT_EMAIL`, `FIREBASE_PRIVATE_KEY`.\n * - Pass the config to the adapter, using the environment variables as shown in the example below.\n *\n * @example\n * ```ts title=\"pages/api/auth/[...nextauth].ts\"\n * import NextAuth from \"next-auth\"\n * import { FirestoreAdapter } from \"@auth/firebase-adapter\"\n * import { cert } from \"firebase-admin/app\"\n *\n * export default NextAuth({\n *  adapter: FirestoreAdapter({\n *    credential: cert({\n *      projectId: process.env.FIREBASE_PROJECT_ID,\n *      clientEmail: process.env.FIREBASE_CLIENT_EMAIL,\n *      privateKey: process.env.FIREBASE_PRIVATE_KEY,\n *    })\n *  })\n *  // ...\n * })\n * ```\n *\n * ### Using an existing Firestore instance\n *\n * If you already have a Firestore instance, you can pass that to the adapter directly instead.\n *\n * :::note\n * When passing an instance and in a serverless environment, remember to handle duplicate app initialization.\n * :::\n *\n * :::tip\n * You can use the {@link initFirestore} utility to initialize the app and get an instance safely.\n * :::\n *\n * @example\n * ```ts title=\"pages/api/auth/[...nextauth].ts\"\n * import NextAuth from \"next-auth\"\n * import { FirestoreAdapter } from \"@auth/firebase-adapter\"\n * import { firestore } from \"lib/firestore\"\n *\n * export default NextAuth({\n *  adapter: FirestoreAdapter(firestore),\n *  // ...\n * })\n * ```\n */ function FirestoreAdapter(config) {\n    const { db, namingStrategy = \"default\" } = config instanceof firebase_admin_firestore__WEBPACK_IMPORTED_MODULE_1__.Firestore ? {\n        db: config\n    } : {\n        ...config,\n        db: config?.firestore ?? initFirestore(config)\n    };\n    const preferSnakeCase = namingStrategy === \"snake_case\";\n    const C = collectionsFactory(db, preferSnakeCase);\n    const mapper = mapFieldsFactory(preferSnakeCase);\n    return {\n        async createUser (userInit) {\n            const { id: userId } = await C.users.add(userInit);\n            const user = await getDoc(C.users.doc(userId));\n            if (!user) throw new Error(\"[createUser] Failed to fetch created user\");\n            return user;\n        },\n        async getUser (id) {\n            return await getDoc(C.users.doc(id));\n        },\n        async getUserByEmail (email) {\n            return await getOneDoc(C.users.where(\"email\", \"==\", email));\n        },\n        async getUserByAccount ({ provider, providerAccountId }) {\n            const account = await getOneDoc(C.accounts.where(\"provider\", \"==\", provider).where(mapper.toDb(\"providerAccountId\"), \"==\", providerAccountId));\n            if (!account) return null;\n            return await getDoc(C.users.doc(account.userId));\n        },\n        async updateUser (partialUser) {\n            if (!partialUser.id) throw new Error(\"[updateUser] Missing id\");\n            const userRef = C.users.doc(partialUser.id);\n            await userRef.set(partialUser, {\n                merge: true\n            });\n            const user = await getDoc(userRef);\n            if (!user) throw new Error(\"[updateUser] Failed to fetch updated user\");\n            return user;\n        },\n        async deleteUser (userId) {\n            await db.runTransaction(async (transaction)=>{\n                const accounts = await C.accounts.where(mapper.toDb(\"userId\"), \"==\", userId).get();\n                const sessions = await C.sessions.where(mapper.toDb(\"userId\"), \"==\", userId).get();\n                transaction.delete(C.users.doc(userId));\n                accounts.forEach((account)=>transaction.delete(account.ref));\n                sessions.forEach((session)=>transaction.delete(session.ref));\n            });\n        },\n        async linkAccount (accountInit) {\n            const ref = await C.accounts.add(accountInit);\n            const account = await ref.get().then((doc)=>doc.data());\n            return account ?? null;\n        },\n        async unlinkAccount ({ provider, providerAccountId }) {\n            await deleteDocs(C.accounts.where(\"provider\", \"==\", provider).where(mapper.toDb(\"providerAccountId\"), \"==\", providerAccountId).limit(1));\n        },\n        async createSession (sessionInit) {\n            const ref = await C.sessions.add(sessionInit);\n            const session = await ref.get().then((doc)=>doc.data());\n            if (session) return session ?? null;\n            throw new Error(\"[createSession] Failed to fetch created session\");\n        },\n        async getSessionAndUser (sessionToken) {\n            const session = await getOneDoc(C.sessions.where(mapper.toDb(\"sessionToken\"), \"==\", sessionToken));\n            if (!session) return null;\n            const user = await getDoc(C.users.doc(session.userId));\n            if (!user) return null;\n            return {\n                session,\n                user\n            };\n        },\n        async updateSession (partialSession) {\n            const sessionId = await db.runTransaction(async (transaction)=>{\n                const sessionSnapshot = (await transaction.get(C.sessions.where(mapper.toDb(\"sessionToken\"), \"==\", partialSession.sessionToken).limit(1))).docs[0];\n                if (!sessionSnapshot?.exists) return null;\n                transaction.set(sessionSnapshot.ref, partialSession, {\n                    merge: true\n                });\n                return sessionSnapshot.id;\n            });\n            if (!sessionId) return null;\n            const session = await getDoc(C.sessions.doc(sessionId));\n            if (session) return session;\n            throw new Error(\"[updateSession] Failed to fetch updated session\");\n        },\n        async deleteSession (sessionToken) {\n            await deleteDocs(C.sessions.where(mapper.toDb(\"sessionToken\"), \"==\", sessionToken).limit(1));\n        },\n        async createVerificationToken (verificationToken) {\n            await C.verification_tokens.add(verificationToken);\n            return verificationToken;\n        },\n        async useVerificationToken ({ identifier, token }) {\n            const verificationTokenSnapshot = (await C.verification_tokens.where(\"identifier\", \"==\", identifier).where(\"token\", \"==\", token).limit(1).get()).docs[0];\n            if (!verificationTokenSnapshot) return null;\n            const data = verificationTokenSnapshot.data();\n            await verificationTokenSnapshot.ref.delete();\n            return data;\n        }\n    };\n}\n// for consistency, store all fields as snake_case in the database\nconst MAP_TO_FIRESTORE = {\n    userId: \"user_id\",\n    sessionToken: \"session_token\",\n    providerAccountId: \"provider_account_id\",\n    emailVerified: \"email_verified\"\n};\nconst MAP_FROM_FIRESTORE = {};\nfor(const key in MAP_TO_FIRESTORE){\n    MAP_FROM_FIRESTORE[MAP_TO_FIRESTORE[key]] = key;\n}\nconst identity = (x)=>x;\n/** @internal */ function mapFieldsFactory(preferSnakeCase) {\n    if (preferSnakeCase) {\n        return {\n            toDb: (field)=>MAP_TO_FIRESTORE[field] ?? field,\n            fromDb: (field)=>MAP_FROM_FIRESTORE[field] ?? field\n        };\n    }\n    return {\n        toDb: identity,\n        fromDb: identity\n    };\n}\n/** @internal */ function getConverter(options) {\n    const mapper = mapFieldsFactory(options?.preferSnakeCase ?? false);\n    return {\n        toFirestore (object) {\n            const document = {};\n            for(const key in object){\n                if (key === \"id\") continue;\n                const value = object[key];\n                if (value !== undefined) {\n                    document[mapper.toDb(key)] = value;\n                } else {\n                    console.warn(`FirebaseAdapter: value for key \"${key}\" is undefined`);\n                }\n            }\n            return document;\n        },\n        fromFirestore (snapshot) {\n            const document = snapshot.data(); // we can guarantee it exists\n            const object = {};\n            if (!options?.excludeId) {\n                object.id = snapshot.id;\n            }\n            for(const key in document){\n                let value = document[key];\n                if (value instanceof firebase_admin_firestore__WEBPACK_IMPORTED_MODULE_1__.Timestamp) value = value.toDate();\n                object[mapper.fromDb(key)] = value;\n            }\n            return object;\n        }\n    };\n}\n/** @internal */ async function getOneDoc(querySnapshot) {\n    const querySnap = await querySnapshot.limit(1).get();\n    return querySnap.docs[0]?.data() ?? null;\n}\n/** @internal */ async function deleteDocs(querySnapshot) {\n    const querySnap = await querySnapshot.get();\n    for (const doc of querySnap.docs){\n        await doc.ref.delete();\n    }\n}\n/** @internal */ async function getDoc(docRef) {\n    const docSnap = await docRef.get();\n    return docSnap.data() ?? null;\n}\n/** @internal */ function collectionsFactory(db, preferSnakeCase = false) {\n    return {\n        users: db.collection(\"users\").withConverter(getConverter({\n            preferSnakeCase\n        })),\n        sessions: db.collection(\"sessions\").withConverter(getConverter({\n            preferSnakeCase\n        })),\n        accounts: db.collection(\"accounts\").withConverter(getConverter({\n            preferSnakeCase\n        })),\n        verification_tokens: db.collection(preferSnakeCase ? \"verification_tokens\" : \"verificationTokens\").withConverter(getConverter({\n            preferSnakeCase,\n            excludeId: true\n        }))\n    };\n}\n/**\n * Utility function that helps making sure that there is no duplicate app initialization issues in serverless environments.\n * If no parameter is passed, it will use the `GOOGLE_APPLICATION_CREDENTIALS` environment variable to initialize a Firestore instance.\n *\n * @example\n * ```ts title=\"lib/firestore.ts\"\n * import { initFirestore } from \"@auth/firebase-adapter\"\n * import { cert } from \"firebase-admin/app\"\n *\n * export const firestore = initFirestore({\n *  credential: cert({\n *    projectId: process.env.FIREBASE_PROJECT_ID,\n *    clientEmail: process.env.FIREBASE_CLIENT_EMAIL,\n *    privateKey: process.env.FIREBASE_PRIVATE_KEY,\n *  })\n * })\n * ```\n */ function initFirestore(options = {}) {\n    const apps = (0,firebase_admin_app__WEBPACK_IMPORTED_MODULE_0__.getApps)();\n    const app = options.name ? apps.find((a)=>a.name === options.name) : apps[0];\n    if (app) return (0,firebase_admin_firestore__WEBPACK_IMPORTED_MODULE_1__.getFirestore)(app);\n    return (0,firebase_admin_firestore__WEBPACK_IMPORTED_MODULE_1__.initializeFirestore)((0,firebase_admin_app__WEBPACK_IMPORTED_MODULE_0__.initializeApp)(options, options.name));\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGF1dGgvZmlyZWJhc2UtYWRhcHRlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUMyRDtBQUN3QztBQUNwRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNFQyxHQUNNLFNBQVNNLGlCQUFpQkMsTUFBTTtJQUNuQyxNQUFNLEVBQUVDLEVBQUUsRUFBRUMsaUJBQWlCLFNBQVMsRUFBRSxHQUFHRixrQkFBa0JMLCtEQUFTQSxHQUNoRTtRQUFFTSxJQUFJRDtJQUFPLElBQ2I7UUFBRSxHQUFHQSxNQUFNO1FBQUVDLElBQUlELFFBQVFHLGFBQWFDLGNBQWNKO0lBQVE7SUFDbEUsTUFBTUssa0JBQWtCSCxtQkFBbUI7SUFDM0MsTUFBTUksSUFBSUMsbUJBQW1CTixJQUFJSTtJQUNqQyxNQUFNRyxTQUFTQyxpQkFBaUJKO0lBQ2hDLE9BQU87UUFDSCxNQUFNSyxZQUFXQyxRQUFRO1lBQ3JCLE1BQU0sRUFBRUMsSUFBSUMsTUFBTSxFQUFFLEdBQUcsTUFBTVAsRUFBRVEsS0FBSyxDQUFDQyxHQUFHLENBQUNKO1lBQ3pDLE1BQU1LLE9BQU8sTUFBTUMsT0FBT1gsRUFBRVEsS0FBSyxDQUFDSSxHQUFHLENBQUNMO1lBQ3RDLElBQUksQ0FBQ0csTUFDRCxNQUFNLElBQUlHLE1BQU07WUFDcEIsT0FBT0g7UUFDWDtRQUNBLE1BQU1JLFNBQVFSLEVBQUU7WUFDWixPQUFPLE1BQU1LLE9BQU9YLEVBQUVRLEtBQUssQ0FBQ0ksR0FBRyxDQUFDTjtRQUNwQztRQUNBLE1BQU1TLGdCQUFlQyxLQUFLO1lBQ3RCLE9BQU8sTUFBTUMsVUFBVWpCLEVBQUVRLEtBQUssQ0FBQ1UsS0FBSyxDQUFDLFNBQVMsTUFBTUY7UUFDeEQ7UUFDQSxNQUFNRyxrQkFBaUIsRUFBRUMsUUFBUSxFQUFFQyxpQkFBaUIsRUFB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QUNGOEYsVUFBVSxDQUFDLFNBQ1hDLGFBQWEsQ0FBQ2xCLGFBQWE7WUFBRXpFO1FBQWdCO1FBQ2xEbUMsVUFBVXZDLEdBQ0w4RixVQUFVLENBQUMsWUFDWEMsYUFBYSxDQUFDbEIsYUFBYTtZQUFFekU7UUFBZ0I7UUFDbER3QixVQUFVNUIsR0FDTDhGLFVBQVUsQ0FBQyxZQUNYQyxhQUFhLENBQUNsQixhQUFhO1lBQUV6RTtRQUFnQjtRQUNsRDRELHFCQUFxQmhFLEdBQ2hCOEYsVUFBVSxDQUFDMUYsa0JBQWtCLHdCQUF3QixzQkFDckQyRixhQUFhLENBQUNsQixhQUFhO1lBQUV6RTtZQUFpQm9GLFdBQVc7UUFBSztJQUN2RTtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBQ00sU0FBU3JGLGNBQWMyRSxVQUFVLENBQUMsQ0FBQztJQUN0QyxNQUFNa0IsT0FBT3hHLDJEQUFPQTtJQUNwQixNQUFNeUcsTUFBTW5CLFFBQVFvQixJQUFJLEdBQUdGLEtBQUtHLElBQUksQ0FBQyxDQUFDQyxJQUFNQSxFQUFFRixJQUFJLEtBQUtwQixRQUFRb0IsSUFBSSxJQUFJRixJQUFJLENBQUMsRUFBRTtJQUM5RSxJQUFJQyxLQUNBLE9BQU90RyxzRUFBWUEsQ0FBQ3NHO0lBQ3hCLE9BQU9yRyw2RUFBbUJBLENBQUNILGlFQUFhQSxDQUFDcUYsU0FBU0EsUUFBUW9CLElBQUk7QUFDbEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXJjaG9vbGFyLy4vbm9kZV9tb2R1bGVzL0BhdXRoL2ZpcmViYXNlLWFkYXB0ZXIvaW5kZXguanM/NzA2NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE9mZmljaWFsICoqRmlyZWJhc2UqKiBhZGFwdGVyIGZvciBBdXRoLmpzIC8gTmV4dEF1dGguanMsIHVzaW5nIHRoZSBbRmlyZWJhc2UgQWRtaW4gU0RLXShodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9hZG1pbi9zZXR1cClcbiAqIGFuZCBbRmlyZXN0b3JlXShodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9maXJlc3RvcmUpLlxuICogWyFbRmlyZXN0b3JlIGxvZ29dKGh0dHBzOi8vYXV0aGpzLmRldi9pbWcvYWRhcHRlcnMvZmlyZWJhc2Uuc3ZnKV0oaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tKVxuICpcbiAqICMjIEluc3RhbGxhdGlvblxuICpcbiAqIGBgYGJhc2ggbnBtMnlhcm5cbiAqIG5wbSBpbnN0YWxsIEBhdXRoL2ZpcmViYXNlLWFkYXB0ZXIgZmlyZWJhc2UtYWRtaW5cbiAqIGBgYFxuICpcbiAqIEBtb2R1bGUgQGF1dGgvZmlyZWJhc2UtYWRhcHRlclxuICovXG5pbXBvcnQgeyBnZXRBcHBzLCBpbml0aWFsaXplQXBwIH0gZnJvbSBcImZpcmViYXNlLWFkbWluL2FwcFwiO1xuaW1wb3J0IHsgRmlyZXN0b3JlLCBnZXRGaXJlc3RvcmUsIGluaXRpYWxpemVGaXJlc3RvcmUsIFRpbWVzdGFtcCwgfSBmcm9tIFwiZmlyZWJhc2UtYWRtaW4vZmlyZXN0b3JlXCI7XG4vKipcbiAqICMjIFNldHVwXG4gKlxuICogRmlyc3QsIGNyZWF0ZSBhIEZpcmViYXNlIHByb2plY3QgYW5kIGdlbmVyYXRlIGEgc2VydmljZSBhY2NvdW50IGtleS4gVmlzaXQ6IGBodHRwczovL2NvbnNvbGUuZmlyZWJhc2UuZ29vZ2xlLmNvbS91LzAvcHJvamVjdC97cHJvamVjdC1pZH0vc2V0dGluZ3Mvc2VydmljZWFjY291bnRzL2FkbWluc2RrYCAocmVwbGFjZSBge3Byb2plY3QtaWR9YCB3aXRoIHlvdXIgcHJvamVjdCdzIGlkKVxuICpcbiAqIE5vdyB5b3UgaGF2ZSBhIGZldyBvcHRpb25zIHRvIGF1dGhlbnRpY2F0ZSB3aXRoIHRoZSBGaXJlYmFzZSBBZG1pbiBTREsgaW4geW91ciBhcHA6XG4gKlxuICogIyMjIEVudmlyb25tZW50IHZhcmlhYmxlc1xuICogIC0gRG93bmxvYWQgdGhlIHNlcnZpY2UgYWNjb3VudCBrZXkgYW5kIHNhdmUgaXQgaW4geW91ciBwcm9qZWN0LiAoTWFrZSBzdXJlIHRvIGFkZCB0aGUgZmlsZSB0byB5b3VyIGAuZ2l0aWdub3JlYCEpXG4gKiAgLSBBZGQgW2BHT09HTEVfQVBQTElDQVRJT05fQ1JFREVOVElBTFNgXShodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vZG9jcy9hdXRoZW50aWNhdGlvbi9hcHBsaWNhdGlvbi1kZWZhdWx0LWNyZWRlbnRpYWxzI0dBQykgdG8geW91ciBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYW5kIHBvaW50IGl0IHRvIHRoZSBzZXJ2aWNlIGFjY291bnQga2V5IGZpbGUuXG4gKiAgLSBUaGUgYWRhcHRlciB3aWxsIGF1dG9tYXRpY2FsbHkgcGljayB1cCB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUgYW5kIHVzZSBpdCB0byBhdXRoZW50aWNhdGUgd2l0aCB0aGUgRmlyZWJhc2UgQWRtaW4gU0RLLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0aXRsZT1cInBhZ2VzL2FwaS9hdXRoL1suLi5uZXh0YXV0aF0udHNcIlxuICogaW1wb3J0IE5leHRBdXRoIGZyb20gXCJuZXh0LWF1dGhcIlxuICogaW1wb3J0IHsgRmlyZXN0b3JlQWRhcHRlciB9IGZyb20gXCJAYXV0aC9maXJlYmFzZS1hZGFwdGVyXCJcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBOZXh0QXV0aCh7XG4gKiAgIGFkYXB0ZXI6IEZpcmVzdG9yZUFkYXB0ZXIoKSxcbiAqICAgLy8gLi4uXG4gKiB9KVxuICogYGBgXG4gKlxuICogIyMjIFNlcnZpY2UgYWNjb3VudCB2YWx1ZXNcbiAqXG4gKiAtIERvd25sb2FkIHRoZSBzZXJ2aWNlIGFjY291bnQga2V5IHRvIGEgdGVtcG9yYXJ5IGxvY2F0aW9uLiAoTWFrZSBzdXJlIHRvIG5vdCBjb21taXQgdGhpcyBmaWxlIHRvIHlvdXIgcmVwb3NpdG9yeSEpXG4gKiAtIEFkZCB0aGUgZm9sbG93aW5nIGVudmlyb25tZW50IHZhcmlhYmxlcyB0byB5b3VyIHByb2plY3Q6IGBGSVJFQkFTRV9QUk9KRUNUX0lEYCwgYEZJUkVCQVNFX0NMSUVOVF9FTUFJTGAsIGBGSVJFQkFTRV9QUklWQVRFX0tFWWAuXG4gKiAtIFBhc3MgdGhlIGNvbmZpZyB0byB0aGUgYWRhcHRlciwgdXNpbmcgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcyBhcyBzaG93biBpbiB0aGUgZXhhbXBsZSBiZWxvdy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdGl0bGU9XCJwYWdlcy9hcGkvYXV0aC9bLi4ubmV4dGF1dGhdLnRzXCJcbiAqIGltcG9ydCBOZXh0QXV0aCBmcm9tIFwibmV4dC1hdXRoXCJcbiAqIGltcG9ydCB7IEZpcmVzdG9yZUFkYXB0ZXIgfSBmcm9tIFwiQGF1dGgvZmlyZWJhc2UtYWRhcHRlclwiXG4gKiBpbXBvcnQgeyBjZXJ0IH0gZnJvbSBcImZpcmViYXNlLWFkbWluL2FwcFwiXG4gKlxuICogZXhwb3J0IGRlZmF1bHQgTmV4dEF1dGgoe1xuICogIGFkYXB0ZXI6IEZpcmVzdG9yZUFkYXB0ZXIoe1xuICogICAgY3JlZGVudGlhbDogY2VydCh7XG4gKiAgICAgIHByb2plY3RJZDogcHJvY2Vzcy5lbnYuRklSRUJBU0VfUFJPSkVDVF9JRCxcbiAqICAgICAgY2xpZW50RW1haWw6IHByb2Nlc3MuZW52LkZJUkVCQVNFX0NMSUVOVF9FTUFJTCxcbiAqICAgICAgcHJpdmF0ZUtleTogcHJvY2Vzcy5lbnYuRklSRUJBU0VfUFJJVkFURV9LRVksXG4gKiAgICB9KVxuICogIH0pXG4gKiAgLy8gLi4uXG4gKiB9KVxuICogYGBgXG4gKlxuICogIyMjIFVzaW5nIGFuIGV4aXN0aW5nIEZpcmVzdG9yZSBpbnN0YW5jZVxuICpcbiAqIElmIHlvdSBhbHJlYWR5IGhhdmUgYSBGaXJlc3RvcmUgaW5zdGFuY2UsIHlvdSBjYW4gcGFzcyB0aGF0IHRvIHRoZSBhZGFwdGVyIGRpcmVjdGx5IGluc3RlYWQuXG4gKlxuICogOjo6bm90ZVxuICogV2hlbiBwYXNzaW5nIGFuIGluc3RhbmNlIGFuZCBpbiBhIHNlcnZlcmxlc3MgZW52aXJvbm1lbnQsIHJlbWVtYmVyIHRvIGhhbmRsZSBkdXBsaWNhdGUgYXBwIGluaXRpYWxpemF0aW9uLlxuICogOjo6XG4gKlxuICogOjo6dGlwXG4gKiBZb3UgY2FuIHVzZSB0aGUge0BsaW5rIGluaXRGaXJlc3RvcmV9IHV0aWxpdHkgdG8gaW5pdGlhbGl6ZSB0aGUgYXBwIGFuZCBnZXQgYW4gaW5zdGFuY2Ugc2FmZWx5LlxuICogOjo6XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHRpdGxlPVwicGFnZXMvYXBpL2F1dGgvWy4uLm5leHRhdXRoXS50c1wiXG4gKiBpbXBvcnQgTmV4dEF1dGggZnJvbSBcIm5leHQtYXV0aFwiXG4gKiBpbXBvcnQgeyBGaXJlc3RvcmVBZGFwdGVyIH0gZnJvbSBcIkBhdXRoL2ZpcmViYXNlLWFkYXB0ZXJcIlxuICogaW1wb3J0IHsgZmlyZXN0b3JlIH0gZnJvbSBcImxpYi9maXJlc3RvcmVcIlxuICpcbiAqIGV4cG9ydCBkZWZhdWx0IE5leHRBdXRoKHtcbiAqICBhZGFwdGVyOiBGaXJlc3RvcmVBZGFwdGVyKGZpcmVzdG9yZSksXG4gKiAgLy8gLi4uXG4gKiB9KVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGaXJlc3RvcmVBZGFwdGVyKGNvbmZpZykge1xuICAgIGNvbnN0IHsgZGIsIG5hbWluZ1N0cmF0ZWd5ID0gXCJkZWZhdWx0XCIgfSA9IGNvbmZpZyBpbnN0YW5jZW9mIEZpcmVzdG9yZVxuICAgICAgICA/IHsgZGI6IGNvbmZpZyB9XG4gICAgICAgIDogeyAuLi5jb25maWcsIGRiOiBjb25maWc/LmZpcmVzdG9yZSA/PyBpbml0RmlyZXN0b3JlKGNvbmZpZykgfTtcbiAgICBjb25zdCBwcmVmZXJTbmFrZUNhc2UgPSBuYW1pbmdTdHJhdGVneSA9PT0gXCJzbmFrZV9jYXNlXCI7XG4gICAgY29uc3QgQyA9IGNvbGxlY3Rpb25zRmFjdG9yeShkYiwgcHJlZmVyU25ha2VDYXNlKTtcbiAgICBjb25zdCBtYXBwZXIgPSBtYXBGaWVsZHNGYWN0b3J5KHByZWZlclNuYWtlQ2FzZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXN5bmMgY3JlYXRlVXNlcih1c2VySW5pdCkge1xuICAgICAgICAgICAgY29uc3QgeyBpZDogdXNlcklkIH0gPSBhd2FpdCBDLnVzZXJzLmFkZCh1c2VySW5pdCk7XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gYXdhaXQgZ2V0RG9jKEMudXNlcnMuZG9jKHVzZXJJZCkpO1xuICAgICAgICAgICAgaWYgKCF1c2VyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIltjcmVhdGVVc2VyXSBGYWlsZWQgdG8gZmV0Y2ggY3JlYXRlZCB1c2VyXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHVzZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGdldFVzZXIoaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBnZXREb2MoQy51c2Vycy5kb2MoaWQpKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgZ2V0VXNlckJ5RW1haWwoZW1haWwpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBnZXRPbmVEb2MoQy51c2Vycy53aGVyZShcImVtYWlsXCIsIFwiPT1cIiwgZW1haWwpKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgZ2V0VXNlckJ5QWNjb3VudCh7IHByb3ZpZGVyLCBwcm92aWRlckFjY291bnRJZCB9KSB7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgZ2V0T25lRG9jKEMuYWNjb3VudHNcbiAgICAgICAgICAgICAgICAud2hlcmUoXCJwcm92aWRlclwiLCBcIj09XCIsIHByb3ZpZGVyKVxuICAgICAgICAgICAgICAgIC53aGVyZShtYXBwZXIudG9EYihcInByb3ZpZGVyQWNjb3VudElkXCIpLCBcIj09XCIsIHByb3ZpZGVyQWNjb3VudElkKSk7XG4gICAgICAgICAgICBpZiAoIWFjY291bnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZ2V0RG9jKEMudXNlcnMuZG9jKGFjY291bnQudXNlcklkKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIHVwZGF0ZVVzZXIocGFydGlhbFVzZXIpIHtcbiAgICAgICAgICAgIGlmICghcGFydGlhbFVzZXIuaWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW3VwZGF0ZVVzZXJdIE1pc3NpbmcgaWRcIik7XG4gICAgICAgICAgICBjb25zdCB1c2VyUmVmID0gQy51c2Vycy5kb2MocGFydGlhbFVzZXIuaWQpO1xuICAgICAgICAgICAgYXdhaXQgdXNlclJlZi5zZXQocGFydGlhbFVzZXIsIHsgbWVyZ2U6IHRydWUgfSk7XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gYXdhaXQgZ2V0RG9jKHVzZXJSZWYpO1xuICAgICAgICAgICAgaWYgKCF1c2VyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlt1cGRhdGVVc2VyXSBGYWlsZWQgdG8gZmV0Y2ggdXBkYXRlZCB1c2VyXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHVzZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGRlbGV0ZVVzZXIodXNlcklkKSB7XG4gICAgICAgICAgICBhd2FpdCBkYi5ydW5UcmFuc2FjdGlvbihhc3luYyAodHJhbnNhY3Rpb24pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IEMuYWNjb3VudHNcbiAgICAgICAgICAgICAgICAgICAgLndoZXJlKG1hcHBlci50b0RiKFwidXNlcklkXCIpLCBcIj09XCIsIHVzZXJJZClcbiAgICAgICAgICAgICAgICAgICAgLmdldCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25zID0gYXdhaXQgQy5zZXNzaW9uc1xuICAgICAgICAgICAgICAgICAgICAud2hlcmUobWFwcGVyLnRvRGIoXCJ1c2VySWRcIiksIFwiPT1cIiwgdXNlcklkKVxuICAgICAgICAgICAgICAgICAgICAuZ2V0KCk7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uZGVsZXRlKEMudXNlcnMuZG9jKHVzZXJJZCkpO1xuICAgICAgICAgICAgICAgIGFjY291bnRzLmZvckVhY2goKGFjY291bnQpID0+IHRyYW5zYWN0aW9uLmRlbGV0ZShhY2NvdW50LnJlZikpO1xuICAgICAgICAgICAgICAgIHNlc3Npb25zLmZvckVhY2goKHNlc3Npb24pID0+IHRyYW5zYWN0aW9uLmRlbGV0ZShzZXNzaW9uLnJlZikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGxpbmtBY2NvdW50KGFjY291bnRJbml0KSB7XG4gICAgICAgICAgICBjb25zdCByZWYgPSBhd2FpdCBDLmFjY291bnRzLmFkZChhY2NvdW50SW5pdCk7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgcmVmLmdldCgpLnRoZW4oKGRvYykgPT4gZG9jLmRhdGEoKSk7XG4gICAgICAgICAgICByZXR1cm4gYWNjb3VudCA/PyBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyB1bmxpbmtBY2NvdW50KHsgcHJvdmlkZXIsIHByb3ZpZGVyQWNjb3VudElkIH0pIHtcbiAgICAgICAgICAgIGF3YWl0IGRlbGV0ZURvY3MoQy5hY2NvdW50c1xuICAgICAgICAgICAgICAgIC53aGVyZShcInByb3ZpZGVyXCIsIFwiPT1cIiwgcHJvdmlkZXIpXG4gICAgICAgICAgICAgICAgLndoZXJlKG1hcHBlci50b0RiKFwicHJvdmlkZXJBY2NvdW50SWRcIiksIFwiPT1cIiwgcHJvdmlkZXJBY2NvdW50SWQpXG4gICAgICAgICAgICAgICAgLmxpbWl0KDEpKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgY3JlYXRlU2Vzc2lvbihzZXNzaW9uSW5pdCkge1xuICAgICAgICAgICAgY29uc3QgcmVmID0gYXdhaXQgQy5zZXNzaW9ucy5hZGQoc2Vzc2lvbkluaXQpO1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IHJlZi5nZXQoKS50aGVuKChkb2MpID0+IGRvYy5kYXRhKCkpO1xuICAgICAgICAgICAgaWYgKHNlc3Npb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlc3Npb24gPz8gbnVsbDtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIltjcmVhdGVTZXNzaW9uXSBGYWlsZWQgdG8gZmV0Y2ggY3JlYXRlZCBzZXNzaW9uXCIpO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBnZXRTZXNzaW9uQW5kVXNlcihzZXNzaW9uVG9rZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBnZXRPbmVEb2MoQy5zZXNzaW9ucy53aGVyZShtYXBwZXIudG9EYihcInNlc3Npb25Ub2tlblwiKSwgXCI9PVwiLCBzZXNzaW9uVG9rZW4pKTtcbiAgICAgICAgICAgIGlmICghc2Vzc2lvbilcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBnZXREb2MoQy51c2Vycy5kb2Moc2Vzc2lvbi51c2VySWQpKTtcbiAgICAgICAgICAgIGlmICghdXNlcilcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB7IHNlc3Npb24sIHVzZXIgfTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgdXBkYXRlU2Vzc2lvbihwYXJ0aWFsU2Vzc2lvbikge1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbklkID0gYXdhaXQgZGIucnVuVHJhbnNhY3Rpb24oYXN5bmMgKHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvblNuYXBzaG90ID0gKGF3YWl0IHRyYW5zYWN0aW9uLmdldChDLnNlc3Npb25zXG4gICAgICAgICAgICAgICAgICAgIC53aGVyZShtYXBwZXIudG9EYihcInNlc3Npb25Ub2tlblwiKSwgXCI9PVwiLCBwYXJ0aWFsU2Vzc2lvbi5zZXNzaW9uVG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIC5saW1pdCgxKSkpLmRvY3NbMF07XG4gICAgICAgICAgICAgICAgaWYgKCFzZXNzaW9uU25hcHNob3Q/LmV4aXN0cylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uc2V0KHNlc3Npb25TbmFwc2hvdC5yZWYsIHBhcnRpYWxTZXNzaW9uLCB7IG1lcmdlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uU25hcHNob3QuaWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghc2Vzc2lvbklkKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IGdldERvYyhDLnNlc3Npb25zLmRvYyhzZXNzaW9uSWQpKTtcbiAgICAgICAgICAgIGlmIChzZXNzaW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW3VwZGF0ZVNlc3Npb25dIEZhaWxlZCB0byBmZXRjaCB1cGRhdGVkIHNlc3Npb25cIik7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGRlbGV0ZVNlc3Npb24oc2Vzc2lvblRva2VuKSB7XG4gICAgICAgICAgICBhd2FpdCBkZWxldGVEb2NzKEMuc2Vzc2lvbnNcbiAgICAgICAgICAgICAgICAud2hlcmUobWFwcGVyLnRvRGIoXCJzZXNzaW9uVG9rZW5cIiksIFwiPT1cIiwgc2Vzc2lvblRva2VuKVxuICAgICAgICAgICAgICAgIC5saW1pdCgxKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGNyZWF0ZVZlcmlmaWNhdGlvblRva2VuKHZlcmlmaWNhdGlvblRva2VuKSB7XG4gICAgICAgICAgICBhd2FpdCBDLnZlcmlmaWNhdGlvbl90b2tlbnMuYWRkKHZlcmlmaWNhdGlvblRva2VuKTtcbiAgICAgICAgICAgIHJldHVybiB2ZXJpZmljYXRpb25Ub2tlbjtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgdXNlVmVyaWZpY2F0aW9uVG9rZW4oeyBpZGVudGlmaWVyLCB0b2tlbiB9KSB7XG4gICAgICAgICAgICBjb25zdCB2ZXJpZmljYXRpb25Ub2tlblNuYXBzaG90ID0gKGF3YWl0IEMudmVyaWZpY2F0aW9uX3Rva2Vuc1xuICAgICAgICAgICAgICAgIC53aGVyZShcImlkZW50aWZpZXJcIiwgXCI9PVwiLCBpZGVudGlmaWVyKVxuICAgICAgICAgICAgICAgIC53aGVyZShcInRva2VuXCIsIFwiPT1cIiwgdG9rZW4pXG4gICAgICAgICAgICAgICAgLmxpbWl0KDEpXG4gICAgICAgICAgICAgICAgLmdldCgpKS5kb2NzWzBdO1xuICAgICAgICAgICAgaWYgKCF2ZXJpZmljYXRpb25Ub2tlblNuYXBzaG90KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHZlcmlmaWNhdGlvblRva2VuU25hcHNob3QuZGF0YSgpO1xuICAgICAgICAgICAgYXdhaXQgdmVyaWZpY2F0aW9uVG9rZW5TbmFwc2hvdC5yZWYuZGVsZXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8gZm9yIGNvbnNpc3RlbmN5LCBzdG9yZSBhbGwgZmllbGRzIGFzIHNuYWtlX2Nhc2UgaW4gdGhlIGRhdGFiYXNlXG5jb25zdCBNQVBfVE9fRklSRVNUT1JFID0ge1xuICAgIHVzZXJJZDogXCJ1c2VyX2lkXCIsXG4gICAgc2Vzc2lvblRva2VuOiBcInNlc3Npb25fdG9rZW5cIixcbiAgICBwcm92aWRlckFjY291bnRJZDogXCJwcm92aWRlcl9hY2NvdW50X2lkXCIsXG4gICAgZW1haWxWZXJpZmllZDogXCJlbWFpbF92ZXJpZmllZFwiLFxufTtcbmNvbnN0IE1BUF9GUk9NX0ZJUkVTVE9SRSA9IHt9O1xuZm9yIChjb25zdCBrZXkgaW4gTUFQX1RPX0ZJUkVTVE9SRSkge1xuICAgIE1BUF9GUk9NX0ZJUkVTVE9SRVtNQVBfVE9fRklSRVNUT1JFW2tleV1dID0ga2V5O1xufVxuY29uc3QgaWRlbnRpdHkgPSAoeCkgPT4geDtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBGaWVsZHNGYWN0b3J5KHByZWZlclNuYWtlQ2FzZSkge1xuICAgIGlmIChwcmVmZXJTbmFrZUNhc2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvRGI6IChmaWVsZCkgPT4gTUFQX1RPX0ZJUkVTVE9SRVtmaWVsZF0gPz8gZmllbGQsXG4gICAgICAgICAgICBmcm9tRGI6IChmaWVsZCkgPT4gTUFQX0ZST01fRklSRVNUT1JFW2ZpZWxkXSA/PyBmaWVsZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdG9EYjogaWRlbnRpdHksIGZyb21EYjogaWRlbnRpdHkgfTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGdldENvbnZlcnRlcihvcHRpb25zKSB7XG4gICAgY29uc3QgbWFwcGVyID0gbWFwRmllbGRzRmFjdG9yeShvcHRpb25zPy5wcmVmZXJTbmFrZUNhc2UgPz8gZmFsc2UpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRvRmlyZXN0b3JlKG9iamVjdCkge1xuICAgICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiaWRcIilcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudFttYXBwZXIudG9EYihrZXkpXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBGaXJlYmFzZUFkYXB0ZXI6IHZhbHVlIGZvciBrZXkgXCIke2tleX1cIiBpcyB1bmRlZmluZWRgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21GaXJlc3RvcmUoc25hcHNob3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gc25hcHNob3QuZGF0YSgpOyAvLyB3ZSBjYW4gZ3VhcmFudGVlIGl0IGV4aXN0c1xuICAgICAgICAgICAgY29uc3Qgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnM/LmV4Y2x1ZGVJZCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5pZCA9IHNuYXBzaG90LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBkb2N1bWVudFtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0RhdGUoKTtcbiAgICAgICAgICAgICAgICBvYmplY3RbbWFwcGVyLmZyb21EYihrZXkpXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE9uZURvYyhxdWVyeVNuYXBzaG90KSB7XG4gICAgY29uc3QgcXVlcnlTbmFwID0gYXdhaXQgcXVlcnlTbmFwc2hvdC5saW1pdCgxKS5nZXQoKTtcbiAgICByZXR1cm4gcXVlcnlTbmFwLmRvY3NbMF0/LmRhdGEoKSA/PyBudWxsO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuYXN5bmMgZnVuY3Rpb24gZGVsZXRlRG9jcyhxdWVyeVNuYXBzaG90KSB7XG4gICAgY29uc3QgcXVlcnlTbmFwID0gYXdhaXQgcXVlcnlTbmFwc2hvdC5nZXQoKTtcbiAgICBmb3IgKGNvbnN0IGRvYyBvZiBxdWVyeVNuYXAuZG9jcykge1xuICAgICAgICBhd2FpdCBkb2MucmVmLmRlbGV0ZSgpO1xuICAgIH1cbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXREb2MoZG9jUmVmKSB7XG4gICAgY29uc3QgZG9jU25hcCA9IGF3YWl0IGRvY1JlZi5nZXQoKTtcbiAgICByZXR1cm4gZG9jU25hcC5kYXRhKCkgPz8gbnVsbDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBjb2xsZWN0aW9uc0ZhY3RvcnkoZGIsIHByZWZlclNuYWtlQ2FzZSA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlcnM6IGRiXG4gICAgICAgICAgICAuY29sbGVjdGlvbihcInVzZXJzXCIpXG4gICAgICAgICAgICAud2l0aENvbnZlcnRlcihnZXRDb252ZXJ0ZXIoeyBwcmVmZXJTbmFrZUNhc2UgfSkpLFxuICAgICAgICBzZXNzaW9uczogZGJcbiAgICAgICAgICAgIC5jb2xsZWN0aW9uKFwic2Vzc2lvbnNcIilcbiAgICAgICAgICAgIC53aXRoQ29udmVydGVyKGdldENvbnZlcnRlcih7IHByZWZlclNuYWtlQ2FzZSB9KSksXG4gICAgICAgIGFjY291bnRzOiBkYlxuICAgICAgICAgICAgLmNvbGxlY3Rpb24oXCJhY2NvdW50c1wiKVxuICAgICAgICAgICAgLndpdGhDb252ZXJ0ZXIoZ2V0Q29udmVydGVyKHsgcHJlZmVyU25ha2VDYXNlIH0pKSxcbiAgICAgICAgdmVyaWZpY2F0aW9uX3Rva2VuczogZGJcbiAgICAgICAgICAgIC5jb2xsZWN0aW9uKHByZWZlclNuYWtlQ2FzZSA/IFwidmVyaWZpY2F0aW9uX3Rva2Vuc1wiIDogXCJ2ZXJpZmljYXRpb25Ub2tlbnNcIilcbiAgICAgICAgICAgIC53aXRoQ29udmVydGVyKGdldENvbnZlcnRlcih7IHByZWZlclNuYWtlQ2FzZSwgZXhjbHVkZUlkOiB0cnVlIH0pKSxcbiAgICB9O1xufVxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHRoYXQgaGVscHMgbWFraW5nIHN1cmUgdGhhdCB0aGVyZSBpcyBubyBkdXBsaWNhdGUgYXBwIGluaXRpYWxpemF0aW9uIGlzc3VlcyBpbiBzZXJ2ZXJsZXNzIGVudmlyb25tZW50cy5cbiAqIElmIG5vIHBhcmFtZXRlciBpcyBwYXNzZWQsIGl0IHdpbGwgdXNlIHRoZSBgR09PR0xFX0FQUExJQ0FUSU9OX0NSRURFTlRJQUxTYCBlbnZpcm9ubWVudCB2YXJpYWJsZSB0byBpbml0aWFsaXplIGEgRmlyZXN0b3JlIGluc3RhbmNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0aXRsZT1cImxpYi9maXJlc3RvcmUudHNcIlxuICogaW1wb3J0IHsgaW5pdEZpcmVzdG9yZSB9IGZyb20gXCJAYXV0aC9maXJlYmFzZS1hZGFwdGVyXCJcbiAqIGltcG9ydCB7IGNlcnQgfSBmcm9tIFwiZmlyZWJhc2UtYWRtaW4vYXBwXCJcbiAqXG4gKiBleHBvcnQgY29uc3QgZmlyZXN0b3JlID0gaW5pdEZpcmVzdG9yZSh7XG4gKiAgY3JlZGVudGlhbDogY2VydCh7XG4gKiAgICBwcm9qZWN0SWQ6IHByb2Nlc3MuZW52LkZJUkVCQVNFX1BST0pFQ1RfSUQsXG4gKiAgICBjbGllbnRFbWFpbDogcHJvY2Vzcy5lbnYuRklSRUJBU0VfQ0xJRU5UX0VNQUlMLFxuICogICAgcHJpdmF0ZUtleTogcHJvY2Vzcy5lbnYuRklSRUJBU0VfUFJJVkFURV9LRVksXG4gKiAgfSlcbiAqIH0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRGaXJlc3RvcmUob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgYXBwcyA9IGdldEFwcHMoKTtcbiAgICBjb25zdCBhcHAgPSBvcHRpb25zLm5hbWUgPyBhcHBzLmZpbmQoKGEpID0+IGEubmFtZSA9PT0gb3B0aW9ucy5uYW1lKSA6IGFwcHNbMF07XG4gICAgaWYgKGFwcClcbiAgICAgICAgcmV0dXJuIGdldEZpcmVzdG9yZShhcHApO1xuICAgIHJldHVybiBpbml0aWFsaXplRmlyZXN0b3JlKGluaXRpYWxpemVBcHAob3B0aW9ucywgb3B0aW9ucy5uYW1lKSk7XG59XG4iXSwibmFtZXMiOlsiZ2V0QXBwcyIsImluaXRpYWxpemVBcHAiLCJGaXJlc3RvcmUiLCJnZXRGaXJlc3RvcmUiLCJpbml0aWFsaXplRmlyZXN0b3JlIiwiVGltZXN0YW1wIiwiRmlyZXN0b3JlQWRhcHRlciIsImNvbmZpZyIsImRiIiwibmFtaW5nU3RyYXRlZ3kiLCJmaXJlc3RvcmUiLCJpbml0RmlyZXN0b3JlIiwicHJlZmVyU25ha2VDYXNlIiwiQyIsImNvbGxlY3Rpb25zRmFjdG9yeSIsIm1hcHBlciIsIm1hcEZpZWxkc0ZhY3RvcnkiLCJjcmVhdGVVc2VyIiwidXNlckluaXQiLCJpZCIsInVzZXJJZCIsInVzZXJzIiwiYWRkIiwidXNlciIsImdldERvYyIsImRvYyIsIkVycm9yIiwiZ2V0VXNlciIsImdldFVzZXJCeUVtYWlsIiwiZW1haWwiLCJnZXRPbmVEb2MiLCJ3aGVyZSIsImdldFVzZXJCeUFjY291bnQiLCJwcm92aWRlciIsInByb3ZpZGVyQWNjb3VudElkIiwiYWNjb3VudCIsImFjY291bnRzIiwidG9EYiIsInVwZGF0ZVVzZXIiLCJwYXJ0aWFsVXNlciIsInVzZXJSZWYiLCJzZXQiLCJtZXJnZSIsImRlbGV0ZVVzZXIiLCJydW5UcmFuc2FjdGlvbiIsInRyYW5zYWN0aW9uIiwiZ2V0Iiwic2Vzc2lvbnMiLCJkZWxldGUiLCJmb3JFYWNoIiwicmVmIiwic2Vzc2lvbiIsImxpbmtBY2NvdW50IiwiYWNjb3VudEluaXQiLCJ0aGVuIiwiZGF0YSIsInVubGlua0FjY291bnQiLCJkZWxldGVEb2NzIiwibGltaXQiLCJjcmVhdGVTZXNzaW9uIiwic2Vzc2lvbkluaXQiLCJnZXRTZXNzaW9uQW5kVXNlciIsInNlc3Npb25Ub2tlbiIsInVwZGF0ZVNlc3Npb24iLCJwYXJ0aWFsU2Vzc2lvbiIsInNlc3Npb25JZCIsInNlc3Npb25TbmFwc2hvdCIsImRvY3MiLCJleGlzdHMiLCJkZWxldGVTZXNzaW9uIiwiY3JlYXRlVmVyaWZpY2F0aW9uVG9rZW4iLCJ2ZXJpZmljYXRpb25Ub2tlbiIsInZlcmlmaWNhdGlvbl90b2tlbnMiLCJ1c2VWZXJpZmljYXRpb25Ub2tlbiIsImlkZW50aWZpZXIiLCJ0b2tlbiIsInZlcmlmaWNhdGlvblRva2VuU25hcHNob3QiLCJNQVBfVE9fRklSRVNUT1JFIiwiZW1haWxWZXJpZmllZCIsIk1BUF9GUk9NX0ZJUkVTVE9SRSIsImtleSIsImlkZW50aXR5IiwieCIsImZpZWxkIiwiZnJvbURiIiwiZ2V0Q29udmVydGVyIiwib3B0aW9ucyIsInRvRmlyZXN0b3JlIiwib2JqZWN0IiwiZG9jdW1lbnQiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsImNvbnNvbGUiLCJ3YXJuIiwiZnJvbUZpcmVzdG9yZSIsInNuYXBzaG90IiwiZXhjbHVkZUlkIiwidG9EYXRlIiwicXVlcnlTbmFwc2hvdCIsInF1ZXJ5U25hcCIsImRvY1JlZiIsImRvY1NuYXAiLCJjb2xsZWN0aW9uIiwid2l0aENvbnZlcnRlciIsImFwcHMiLCJhcHAiLCJuYW1lIiwiZmluZCIsImEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@auth/firebase-adapter/index.js\n");

/***/ })

};
;