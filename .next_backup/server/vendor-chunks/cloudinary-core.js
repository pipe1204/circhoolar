"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cloudinary-core";
exports.ids = ["vendor-chunks/cloudinary-core"];
exports.modules = {

/***/ "(rsc)/./node_modules/cloudinary-core/cloudinary-core.js":
/*!*********************************************************!*\
  !*** ./node_modules/cloudinary-core/cloudinary-core.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n   * cloudinary-core.js\n   * Cloudinary's JavaScript library - Version 2.13.0\n   * Copyright Cloudinary\n   * see https://github.com/cloudinary/cloudinary_js\n   *\n   */ (function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory(__webpack_require__(/*! lodash/assign */ \"lodash/assign\"), __webpack_require__(/*! lodash/cloneDeep */ \"lodash/cloneDeep\"), __webpack_require__(/*! lodash/compact */ \"lodash/compact\"), __webpack_require__(/*! lodash/difference */ \"lodash/difference\"), __webpack_require__(/*! lodash/functions */ \"lodash/functions\"), __webpack_require__(/*! lodash/identity */ \"lodash/identity\"), __webpack_require__(/*! lodash/includes */ \"lodash/includes\"), __webpack_require__(/*! lodash/isArray */ \"lodash/isArray\"), __webpack_require__(/*! lodash/isElement */ \"lodash/isElement\"), __webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"), __webpack_require__(/*! lodash/isPlainObject */ \"lodash/isPlainObject\"), __webpack_require__(/*! lodash/isString */ \"lodash/isString\"), __webpack_require__(/*! lodash/merge */ \"lodash/merge\"), __webpack_require__(/*! lodash/trim */ \"lodash/trim\"));\n    else {}\n})(void 0, function(__WEBPACK_EXTERNAL_MODULE_lodash_assign__, __WEBPACK_EXTERNAL_MODULE_lodash_cloneDeep__, __WEBPACK_EXTERNAL_MODULE_lodash_compact__, __WEBPACK_EXTERNAL_MODULE_lodash_difference__, __WEBPACK_EXTERNAL_MODULE_lodash_functions__, __WEBPACK_EXTERNAL_MODULE_lodash_identity__, __WEBPACK_EXTERNAL_MODULE_lodash_includes__, __WEBPACK_EXTERNAL_MODULE_lodash_isArray__, __WEBPACK_EXTERNAL_MODULE_lodash_isElement__, __WEBPACK_EXTERNAL_MODULE_lodash_isFunction__, __WEBPACK_EXTERNAL_MODULE_lodash_isPlainObject__, __WEBPACK_EXTERNAL_MODULE_lodash_isString__, __WEBPACK_EXTERNAL_MODULE_lodash_merge__, __WEBPACK_EXTERNAL_MODULE_lodash_trim__) {\n    return /******/ function(modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_2864__(moduleId) {\n            /******/ /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_2864__);\n            /******/ /******/ // Flag the module as loaded\n            /******/ module1.l = true;\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_2864__.m = modules;\n        /******/ /******/ // expose the module cache\n        /******/ __nested_webpack_require_2864__.c = installedModules;\n        /******/ /******/ // define getter function for harmony exports\n        /******/ __nested_webpack_require_2864__.d = function(exports1, name, getter) {\n            /******/ if (!__nested_webpack_require_2864__.o(exports1, name)) {\n                /******/ Object.defineProperty(exports1, name, {\n                    enumerable: true,\n                    get: getter\n                });\n            /******/ }\n        /******/ };\n        /******/ /******/ // define __esModule on exports\n        /******/ __nested_webpack_require_2864__.r = function(exports1) {\n            /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n                /******/ Object.defineProperty(exports1, Symbol.toStringTag, {\n                    value: \"Module\"\n                });\n            /******/ }\n            /******/ Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n        /******/ };\n        /******/ /******/ // create a fake namespace object\n        /******/ // mode & 1: value is a module id, require it\n        /******/ // mode & 2: merge all properties of value into the ns\n        /******/ // mode & 4: return value when already ns object\n        /******/ // mode & 8|1: behave like require\n        /******/ __nested_webpack_require_2864__.t = function(value, mode) {\n            /******/ if (mode & 1) value = __nested_webpack_require_2864__(value);\n            /******/ if (mode & 8) return value;\n            /******/ if (mode & 4 && typeof value === \"object\" && value && value.__esModule) return value;\n            /******/ var ns = Object.create(null);\n            /******/ __nested_webpack_require_2864__.r(ns);\n            /******/ Object.defineProperty(ns, \"default\", {\n                enumerable: true,\n                value: value\n            });\n            /******/ if (mode & 2 && typeof value != \"string\") for(var key in value)__nested_webpack_require_2864__.d(ns, key, (function(key) {\n                return value[key];\n            }).bind(null, key));\n            /******/ return ns;\n        /******/ };\n        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __nested_webpack_require_2864__.n = function(module1) {\n            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n                return module1[\"default\"];\n            } : /******/ function getModuleExports() {\n                return module1;\n            };\n            /******/ __nested_webpack_require_2864__.d(getter, \"a\", getter);\n            /******/ return getter;\n        /******/ };\n        /******/ /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __nested_webpack_require_2864__.o = function(object, property) {\n            return Object.prototype.hasOwnProperty.call(object, property);\n        };\n        /******/ /******/ // __webpack_public_path__\n        /******/ __nested_webpack_require_2864__.p = \"\";\n        /******/ /******/ /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_2864__(__nested_webpack_require_2864__.s = \"./src/namespace/cloudinary-core.js\");\n    /******/ }({\n        /***/ \"./src/namespace/cloudinary-core.js\": /***/ function(module1, __nested_webpack_exports__, __nested_webpack_require_7160__) {\n            \"use strict\";\n            // ESM COMPAT FLAG\n            __nested_webpack_require_7160__.r(__nested_webpack_exports__);\n            // EXPORTS\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"ClientHintsMetaTag\", function() {\n                return /* reexport */ clienthintsmetatag;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Cloudinary\", function() {\n                return /* reexport */ cloudinary;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Condition\", function() {\n                return /* reexport */ condition;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Configuration\", function() {\n                return /* reexport */ src_configuration;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"crc32\", function() {\n                return /* reexport */ src_crc32;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Expression\", function() {\n                return /* reexport */ expression;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"FetchLayer\", function() {\n                return /* reexport */ fetchlayer;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"HtmlTag\", function() {\n                return /* reexport */ htmltag;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"ImageTag\", function() {\n                return /* reexport */ imagetag;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Layer\", function() {\n                return /* reexport */ layer_layer;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"PictureTag\", function() {\n                return /* reexport */ picturetag;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"SubtitlesLayer\", function() {\n                return /* reexport */ subtitleslayer;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"TextLayer\", function() {\n                return /* reexport */ textlayer;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Transformation\", function() {\n                return /* reexport */ src_transformation;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"utf8_encode\", function() {\n                return /* reexport */ src_utf8_encode;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Util\", function() {\n                return /* reexport */ lodash_namespaceObject;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"VideoTag\", function() {\n                return /* reexport */ videotag;\n            });\n            // NAMESPACE OBJECT: ./src/constants.js\n            var constants_namespaceObject = {};\n            __nested_webpack_require_7160__.r(constants_namespaceObject);\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"VERSION\", function() {\n                return VERSION;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"CF_SHARED_CDN\", function() {\n                return CF_SHARED_CDN;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"OLD_AKAMAI_SHARED_CDN\", function() {\n                return OLD_AKAMAI_SHARED_CDN;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"AKAMAI_SHARED_CDN\", function() {\n                return AKAMAI_SHARED_CDN;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"SHARED_CDN\", function() {\n                return SHARED_CDN;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_TIMEOUT_MS\", function() {\n                return DEFAULT_TIMEOUT_MS;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_POSTER_OPTIONS\", function() {\n                return DEFAULT_POSTER_OPTIONS;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_VIDEO_SOURCE_TYPES\", function() {\n                return DEFAULT_VIDEO_SOURCE_TYPES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"SEO_TYPES\", function() {\n                return SEO_TYPES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_IMAGE_PARAMS\", function() {\n                return DEFAULT_IMAGE_PARAMS;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_VIDEO_PARAMS\", function() {\n                return DEFAULT_VIDEO_PARAMS;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_VIDEO_SOURCES\", function() {\n                return DEFAULT_VIDEO_SOURCES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_EXTERNAL_LIBRARIES\", function() {\n                return DEFAULT_EXTERNAL_LIBRARIES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"PLACEHOLDER_IMAGE_MODES\", function() {\n                return PLACEHOLDER_IMAGE_MODES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"ACCESSIBILITY_MODES\", function() {\n                return ACCESSIBILITY_MODES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"URL_KEYS\", function() {\n                return URL_KEYS;\n            });\n            // NAMESPACE OBJECT: ./src/util/lodash.js\n            var lodash_namespaceObject = {};\n            __nested_webpack_require_7160__.r(lodash_namespaceObject);\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getSDKAnalyticsSignature\", function() {\n                return getSDKAnalyticsSignature;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getAnalyticsOptions\", function() {\n                return getAnalyticsOptions;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"assign\", function() {\n                return assign_root_assign_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"cloneDeep\", function() {\n                return cloneDeep_root_cloneDeep_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"compact\", function() {\n                return compact_root_compact_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"difference\", function() {\n                return difference_root_difference_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"functions\", function() {\n                return functions_root_functions_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"identity\", function() {\n                return identity_root_identity_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"includes\", function() {\n                return includes_root_includes_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isArray\", function() {\n                return isArray_root_isArray_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isPlainObject\", function() {\n                return isPlainObject_root_isPlainObject_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isString\", function() {\n                return isString_root_isString_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"merge\", function() {\n                return merge_root_merge_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"contains\", function() {\n                return includes_root_includes_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isIntersectionObserverSupported\", function() {\n                return isIntersectionObserverSupported;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isNativeLazyLoadSupported\", function() {\n                return isNativeLazyLoadSupported;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"detectIntersection\", function() {\n                return detectIntersection;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"omit\", function() {\n                return omit;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"allStrings\", function() {\n                return baseutil_allStrings;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"without\", function() {\n                return without;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isNumberLike\", function() {\n                return isNumberLike;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"smartEscape\", function() {\n                return smartEscape;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"defaults\", function() {\n                return defaults;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"objectProto\", function() {\n                return objectProto;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"objToString\", function() {\n                return objToString;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isObject\", function() {\n                return isObject;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"funcTag\", function() {\n                return funcTag;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"reWords\", function() {\n                return reWords;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"camelCase\", function() {\n                return camelCase;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"snakeCase\", function() {\n                return snakeCase;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"convertKeys\", function() {\n                return convertKeys;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"withCamelCaseKeys\", function() {\n                return withCamelCaseKeys;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"withSnakeCaseKeys\", function() {\n                return withSnakeCaseKeys;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"base64Encode\", function() {\n                return base64Encode;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"base64EncodeURL\", function() {\n                return base64EncodeURL;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"extractUrlParams\", function() {\n                return extractUrlParams;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"patchFetchFormat\", function() {\n                return patchFetchFormat;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"optionConsume\", function() {\n                return optionConsume;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isEmpty\", function() {\n                return isEmpty;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isAndroid\", function() {\n                return isAndroid;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isEdge\", function() {\n                return isEdge;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isChrome\", function() {\n                return isChrome;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isSafari\", function() {\n                return isSafari;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isElement\", function() {\n                return isElement_root_isElement_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isFunction\", function() {\n                return isFunction_root_isFunction_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"trim\", function() {\n                return trim_root_trim_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getData\", function() {\n                return lodash_getData;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"setData\", function() {\n                return lodash_setData;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getAttribute\", function() {\n                return lodash_getAttribute;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"setAttribute\", function() {\n                return lodash_setAttribute;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"removeAttribute\", function() {\n                return lodash_removeAttribute;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"setAttributes\", function() {\n                return setAttributes;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"hasClass\", function() {\n                return lodash_hasClass;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"addClass\", function() {\n                return lodash_addClass;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getStyles\", function() {\n                return getStyles;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"cssExpand\", function() {\n                return cssExpand;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"domStyle\", function() {\n                return domStyle;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"curCSS\", function() {\n                return curCSS;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"cssValue\", function() {\n                return cssValue;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"augmentWidthOrHeight\", function() {\n                return augmentWidthOrHeight;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getWidthOrHeight\", function() {\n                return getWidthOrHeight;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"width\", function() {\n                return lodash_width;\n            });\n            // CONCATENATED MODULE: ./src/utf8_encode.js\n            /**\n * UTF8 encoder\n * @private\n */ var utf8_encode;\n            /* harmony default export */ var src_utf8_encode = utf8_encode = function utf8_encode(argString) {\n                var c1, enc, end, n, start, string, stringl, utftext; // http://kevin.vanzonneveld.net\n                // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)\n                // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n                // +   improved by: sowberry\n                // +    tweaked by: Jack\n                // +   bugfixed by: Onno Marsman\n                // +   improved by: Yves Sucaet\n                // +   bugfixed by: Onno Marsman\n                // +   bugfixed by: Ulrich\n                // +   bugfixed by: Rafal Kukawski\n                // +   improved by: kirilloid\n                // *     example 1: utf8_encode('Kevin van Zonneveld');\n                // *     returns 1: 'Kevin van Zonneveld'\n                if (argString === null || typeof argString === \"undefined\") {\n                    return \"\";\n                }\n                string = argString + \"\"; // .replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n                utftext = \"\";\n                start = void 0;\n                end = void 0;\n                stringl = 0;\n                start = end = 0;\n                stringl = string.length;\n                n = 0;\n                while(n < stringl){\n                    c1 = string.charCodeAt(n);\n                    enc = null;\n                    if (c1 < 128) {\n                        end++;\n                    } else if (c1 > 127 && c1 < 2048) {\n                        enc = String.fromCharCode(c1 >> 6 | 192, c1 & 63 | 128);\n                    } else {\n                        enc = String.fromCharCode(c1 >> 12 | 224, c1 >> 6 & 63 | 128, c1 & 63 | 128);\n                    }\n                    if (enc !== null) {\n                        if (end > start) {\n                            utftext += string.slice(start, end);\n                        }\n                        utftext += enc;\n                        start = end = n + 1;\n                    }\n                    n++;\n                }\n                if (end > start) {\n                    utftext += string.slice(start, stringl);\n                }\n                return utftext;\n            };\n            // CONCATENATED MODULE: ./src/crc32.js\n            /**\n * CRC32 calculator\n * Depends on 'utf8_encode'\n * @private\n * @param {string} str - The string to calculate the CRC32 for.\n * @return {number}\n */ function crc32(str) {\n                var crc, i, iTop, table, x, y; // http://kevin.vanzonneveld.net\n                // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)\n                // +   improved by: T0bsn\n                // +   improved by: http://stackoverflow.com/questions/2647935/javascript-crc32-function-and-php-crc32-not-matching\n                // -    depends on: utf8_encode\n                // *     example 1: crc32('Kevin van Zonneveld');\n                // *     returns 1: 1249991249\n                str = src_utf8_encode(str);\n                table = \"00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D\";\n                crc = 0;\n                x = 0;\n                y = 0;\n                crc = crc ^ -1;\n                i = 0;\n                iTop = str.length;\n                while(i < iTop){\n                    y = (crc ^ str.charCodeAt(i)) & 0xFF;\n                    x = \"0x\" + table.substr(y * 9, 8);\n                    crc = crc >>> 8 ^ x;\n                    i++;\n                }\n                crc = crc ^ -1; //convert to unsigned 32-bit int if needed\n                if (crc < 0) {\n                    crc += 4294967296;\n                }\n                return crc;\n            }\n            /* harmony default export */ var src_crc32 = crc32;\n            // CONCATENATED MODULE: ./src/sdkAnalytics/stringPad.js\n            function stringPad(value, targetLength, padString) {\n                targetLength = targetLength >> 0; //truncate if number or convert non-number to 0;\n                padString = String(typeof padString !== \"undefined\" ? padString : \" \");\n                if (value.length > targetLength) {\n                    return String(value);\n                } else {\n                    targetLength = targetLength - value.length;\n                    if (targetLength > padString.length) {\n                        padString += repeatStringNumTimes(padString, targetLength / padString.length);\n                    }\n                    return padString.slice(0, targetLength) + String(value);\n                }\n            }\n            function repeatStringNumTimes(string, times) {\n                var repeatedString = \"\";\n                while(times > 0){\n                    repeatedString += string;\n                    times--;\n                }\n                return repeatedString;\n            }\n            // CONCATENATED MODULE: ./src/sdkAnalytics/base64Map.js\n            function _toConsumableArray(arr) {\n                return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n            }\n            function _nonIterableSpread() {\n                throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function _unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n            }\n            function _iterableToArray(iter) {\n                if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n            }\n            function _arrayWithoutHoles(arr) {\n                if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n            }\n            function _arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n            var base64Map_num = 0;\n            var map = {};\n            _toConsumableArray(chars).forEach(function(_char) {\n                var key = base64Map_num.toString(2);\n                key = stringPad(key, 6, \"0\");\n                map[key] = _char;\n                base64Map_num++;\n            });\n            /**\n * Map of six-bit binary codes to Base64 characters\n */ /* harmony default export */ var base64Map = map;\n            // CONCATENATED MODULE: ./src/sdkAnalytics/reverseVersion.js\n            /**\n * @description A semVer like string, x.y.z or x.y is allowed\n *              Reverses the version positions, x.y.z turns to z.y.x\n *              Pads each segment with '0' so they have length of 2\n *              Example: 1.2.3 -> 03.02.01\n * @param {string} semVer Input can be either x.y.z or x.y\n * @return {string} in the form of zz.yy.xx (\n */ function reverseVersion(semVer) {\n                if (semVer.split(\".\").length < 2) {\n                    throw new Error(\"invalid semVer, must have at least two segments\");\n                } // Split by '.', reverse, create new array with padded values and concat it together\n                return semVer.split(\".\").reverse().map(function(segment) {\n                    return stringPad(segment, 2, \"0\");\n                }).join(\".\");\n            }\n            // CONCATENATED MODULE: ./src/sdkAnalytics/encodeVersion.js\n            /**\n * @description Encodes a semVer-like version string\n * @param {string} semVer Input can be either x.y.z or x.y\n * @return {string} A string built from 3 characters of the base64 table that encode the semVer\n */ function encodeVersion(semVer) {\n                var strResult = \"\"; // support x.y or x.y.z by using 'parts' as a variable\n                var parts = semVer.split(\".\").length;\n                var paddedStringLength = parts * 6; // we pad to either 12 or 18 characters\n                // reverse (but don't mirror) the version. 1.5.15 -> 15.5.1\n                // Pad to two spaces, 15.5.1 -> 15.05.01\n                var paddedReversedSemver = reverseVersion(semVer); // turn 15.05.01 to a string '150501' then to a number 150501\n                var num = parseInt(paddedReversedSemver.split(\".\").join(\"\")); // Represent as binary, add left padding to 12 or 18 characters.\n                // 150,501 -> 100100101111100101\n                var paddedBinary = num.toString(2);\n                paddedBinary = stringPad(paddedBinary, paddedStringLength, \"0\"); // Stop in case an invalid version number was provided\n                // paddedBinary must be built from sections of 6 bits\n                if (paddedBinary.length % 6 !== 0) {\n                    throw \"Version must be smaller than 43.21.26)\";\n                } // turn every 6 bits into a character using the base64Map\n                paddedBinary.match(/.{1,6}/g).forEach(function(bitString) {\n                    // console.log(bitString);\n                    strResult += base64Map[bitString];\n                });\n                return strResult;\n            }\n            // CONCATENATED MODULE: ./src/sdkAnalytics/getSDKAnalyticsSignature.js\n            /**\n * @description Gets the SDK signature by encoding the SDK version and tech version\n * @param {{\n *    [techVersion]:string,\n *    [sdkSemver]: string,\n *    [sdkCode]: string,\n *    [feature]: string\n * }} analyticsOptions\n * @return {string} sdkAnalyticsSignature\n */ function getSDKAnalyticsSignature() {\n                var analyticsOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                try {\n                    var twoPartVersion = removePatchFromSemver(analyticsOptions.techVersion);\n                    var encodedSDKVersion = encodeVersion(analyticsOptions.sdkSemver);\n                    var encodedTechVersion = encodeVersion(twoPartVersion);\n                    var featureCode = analyticsOptions.feature;\n                    var SDKCode = analyticsOptions.sdkCode;\n                    var algoVersion = \"A\"; // The algo version is determined here, it should not be an argument\n                    return \"\".concat(algoVersion).concat(SDKCode).concat(encodedSDKVersion).concat(encodedTechVersion).concat(featureCode);\n                } catch (e) {\n                    // Either SDK or Node versions were unparsable\n                    return \"E\";\n                }\n            }\n            /**\n * @description Removes patch version from the semver if it exists\n *              Turns x.y.z OR x.y into x.y\n * @param {'x.y.z' || 'x.y' || string} semVerStr\n */ function removePatchFromSemver(semVerStr) {\n                var parts = semVerStr.split(\".\");\n                return \"\".concat(parts[0], \".\").concat(parts[1]);\n            }\n            // CONCATENATED MODULE: ./src/sdkAnalytics/getAnalyticsOptions.js\n            /**\n * @description Gets the analyticsOptions from options- should include sdkSemver, techVersion, sdkCode, and feature\n * @param options\n * @returns {{sdkSemver: (string), sdkCode, feature: string, techVersion: (string)} || {}}\n */ function getAnalyticsOptions(options) {\n                var analyticsOptions = {\n                    sdkSemver: options.sdkSemver,\n                    techVersion: options.techVersion,\n                    sdkCode: options.sdkCode,\n                    feature: \"0\"\n                };\n                if (options.urlAnalytics) {\n                    if (options.accessibility) {\n                        analyticsOptions.feature = \"D\";\n                    }\n                    if (options.loading === \"lazy\") {\n                        analyticsOptions.feature = \"C\";\n                    }\n                    if (options.responsive) {\n                        analyticsOptions.feature = \"A\";\n                    }\n                    if (options.placeholder) {\n                        analyticsOptions.feature = \"B\";\n                    }\n                    return analyticsOptions;\n                } else {\n                    return {};\n                }\n            }\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/assign\",\"commonjs2\":\"lodash/assign\",\"amd\":\"lodash/assign\",\"root\":[\"_\",\"assign\"]}\n            var assign_root_assign_ = __nested_webpack_require_7160__(\"lodash/assign\");\n            var assign_root_assign_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(assign_root_assign_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/cloneDeep\",\"commonjs2\":\"lodash/cloneDeep\",\"amd\":\"lodash/cloneDeep\",\"root\":[\"_\",\"cloneDeep\"]}\n            var cloneDeep_root_cloneDeep_ = __nested_webpack_require_7160__(\"lodash/cloneDeep\");\n            var cloneDeep_root_cloneDeep_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(cloneDeep_root_cloneDeep_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/compact\",\"commonjs2\":\"lodash/compact\",\"amd\":\"lodash/compact\",\"root\":[\"_\",\"compact\"]}\n            var compact_root_compact_ = __nested_webpack_require_7160__(\"lodash/compact\");\n            var compact_root_compact_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(compact_root_compact_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/difference\",\"commonjs2\":\"lodash/difference\",\"amd\":\"lodash/difference\",\"root\":[\"_\",\"difference\"]}\n            var difference_root_difference_ = __nested_webpack_require_7160__(\"lodash/difference\");\n            var difference_root_difference_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(difference_root_difference_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/functions\",\"commonjs2\":\"lodash/functions\",\"amd\":\"lodash/functions\",\"root\":[\"_\",\"functions\"]}\n            var functions_root_functions_ = __nested_webpack_require_7160__(\"lodash/functions\");\n            var functions_root_functions_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(functions_root_functions_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/identity\",\"commonjs2\":\"lodash/identity\",\"amd\":\"lodash/identity\",\"root\":[\"_\",\"identity\"]}\n            var identity_root_identity_ = __nested_webpack_require_7160__(\"lodash/identity\");\n            var identity_root_identity_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(identity_root_identity_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/includes\",\"commonjs2\":\"lodash/includes\",\"amd\":\"lodash/includes\",\"root\":[\"_\",\"includes\"]}\n            var includes_root_includes_ = __nested_webpack_require_7160__(\"lodash/includes\");\n            var includes_root_includes_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(includes_root_includes_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isArray\",\"commonjs2\":\"lodash/isArray\",\"amd\":\"lodash/isArray\",\"root\":[\"_\",\"isArray\"]}\n            var isArray_root_isArray_ = __nested_webpack_require_7160__(\"lodash/isArray\");\n            var isArray_root_isArray_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isArray_root_isArray_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isPlainObject\",\"commonjs2\":\"lodash/isPlainObject\",\"amd\":\"lodash/isPlainObject\",\"root\":[\"_\",\"isPlainObject\"]}\n            var isPlainObject_root_isPlainObject_ = __nested_webpack_require_7160__(\"lodash/isPlainObject\");\n            var isPlainObject_root_isPlainObject_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isPlainObject_root_isPlainObject_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isString\",\"commonjs2\":\"lodash/isString\",\"amd\":\"lodash/isString\",\"root\":[\"_\",\"isString\"]}\n            var isString_root_isString_ = __nested_webpack_require_7160__(\"lodash/isString\");\n            var isString_root_isString_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isString_root_isString_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/merge\",\"commonjs2\":\"lodash/merge\",\"amd\":\"lodash/merge\",\"root\":[\"_\",\"merge\"]}\n            var merge_root_merge_ = __nested_webpack_require_7160__(\"lodash/merge\");\n            var merge_root_merge_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(merge_root_merge_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isElement\",\"commonjs2\":\"lodash/isElement\",\"amd\":\"lodash/isElement\",\"root\":[\"_\",\"isElement\"]}\n            var isElement_root_isElement_ = __nested_webpack_require_7160__(\"lodash/isElement\");\n            var isElement_root_isElement_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isElement_root_isElement_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isFunction\",\"commonjs2\":\"lodash/isFunction\",\"amd\":\"lodash/isFunction\",\"root\":[\"_\",\"isFunction\"]}\n            var isFunction_root_isFunction_ = __nested_webpack_require_7160__(\"lodash/isFunction\");\n            var isFunction_root_isFunction_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isFunction_root_isFunction_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/trim\",\"commonjs2\":\"lodash/trim\",\"amd\":\"lodash/trim\",\"root\":[\"_\",\"trim\"]}\n            var trim_root_trim_ = __nested_webpack_require_7160__(\"lodash/trim\");\n            var trim_root_trim_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(trim_root_trim_);\n            // CONCATENATED MODULE: ./src/util/lazyLoad.js\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, _typeof(obj);\n            }\n            /*\n * Includes utility methods for lazy loading media\n */ /**\n * Check if IntersectionObserver is supported\n * @return {boolean} true if window.IntersectionObserver is defined\n */ function isIntersectionObserverSupported() {\n                // Check that 'IntersectionObserver' property is defined on window\n                return  false && 0;\n            }\n            /**\n * Check if native lazy loading is supported\n * @return {boolean} true if 'loading' property is defined for HTMLImageElement\n */ function isNativeLazyLoadSupported() {\n                return (typeof HTMLImageElement === \"undefined\" ? \"undefined\" : _typeof(HTMLImageElement)) === \"object\" && HTMLImageElement.prototype.loading;\n            }\n            /**\n * Calls onIntersect() when intersection is detected, or when\n * no native lazy loading or when IntersectionObserver isn't supported.\n * @param {Element} el - the element to observe\n * @param {function} onIntersect - called when the given element is in view\n */ function detectIntersection(el, onIntersect) {\n                try {\n                    if (isNativeLazyLoadSupported() || !isIntersectionObserverSupported()) {\n                        // Return if there's no need or possibility to detect intersection\n                        onIntersect();\n                        return;\n                    } // Detect intersection with given element using IntersectionObserver\n                    var observer = new IntersectionObserver(function(entries) {\n                        entries.forEach(function(entry) {\n                            if (entry.isIntersecting) {\n                                onIntersect();\n                                observer.unobserve(entry.target);\n                            }\n                        });\n                    }, {\n                        threshold: [\n                            0,\n                            0.01\n                        ]\n                    });\n                    observer.observe(el);\n                } catch (e) {\n                    onIntersect();\n                }\n            }\n            // CONCATENATED MODULE: ./src/constants.js\n            var VERSION = \"2.5.0\";\n            var CF_SHARED_CDN = \"d3jpl91pxevbkh.cloudfront.net\";\n            var OLD_AKAMAI_SHARED_CDN = \"cloudinary-a.akamaihd.net\";\n            var AKAMAI_SHARED_CDN = \"res.cloudinary.com\";\n            var SHARED_CDN = AKAMAI_SHARED_CDN;\n            var DEFAULT_TIMEOUT_MS = 10000;\n            var DEFAULT_POSTER_OPTIONS = {\n                format: \"jpg\",\n                resource_type: \"video\"\n            };\n            var DEFAULT_VIDEO_SOURCE_TYPES = [\n                \"webm\",\n                \"mp4\",\n                \"ogv\"\n            ];\n            var SEO_TYPES = {\n                \"image/upload\": \"images\",\n                \"image/private\": \"private_images\",\n                \"image/authenticated\": \"authenticated_images\",\n                \"raw/upload\": \"files\",\n                \"video/upload\": \"videos\"\n            };\n            /**\n* @const {Object} Cloudinary.DEFAULT_IMAGE_PARAMS\n* Defaults values for image parameters.\n*\n* (Previously defined using option_consume() )\n */ var DEFAULT_IMAGE_PARAMS = {\n                resource_type: \"image\",\n                transformation: [],\n                type: \"upload\"\n            };\n            /**\n* Defaults values for video parameters.\n* @const {Object} Cloudinary.DEFAULT_VIDEO_PARAMS\n* (Previously defined using option_consume() )\n */ var DEFAULT_VIDEO_PARAMS = {\n                fallback_content: \"\",\n                resource_type: \"video\",\n                source_transformation: {},\n                source_types: DEFAULT_VIDEO_SOURCE_TYPES,\n                transformation: [],\n                type: \"upload\"\n            };\n            /**\n * Recommended sources for video tag\n * @const {Object} Cloudinary.DEFAULT_VIDEO_SOURCES\n */ var DEFAULT_VIDEO_SOURCES = [\n                {\n                    type: \"mp4\",\n                    codecs: \"hev1\",\n                    transformations: {\n                        video_codec: \"h265\"\n                    }\n                },\n                {\n                    type: \"webm\",\n                    codecs: \"vp9\",\n                    transformations: {\n                        video_codec: \"vp9\"\n                    }\n                },\n                {\n                    type: \"mp4\",\n                    transformations: {\n                        video_codec: \"auto\"\n                    }\n                },\n                {\n                    type: \"webm\",\n                    transformations: {\n                        video_codec: \"auto\"\n                    }\n                }\n            ];\n            var DEFAULT_EXTERNAL_LIBRARIES = {\n                seeThru: \"https://unpkg.com/seethru@4/dist/seeThru.min.js\"\n            };\n            /**\n * Predefined placeholder transformations\n * @const {Object} Cloudinary.PLACEHOLDER_IMAGE_MODES\n */ var PLACEHOLDER_IMAGE_MODES = {\n                \"blur\": [\n                    {\n                        effect: \"blur:2000\",\n                        quality: 1,\n                        fetch_format: \"auto\"\n                    }\n                ],\n                // Default\n                \"pixelate\": [\n                    {\n                        effect: \"pixelate\",\n                        quality: 1,\n                        fetch_format: \"auto\"\n                    }\n                ],\n                // Generates a pixel size image which color is the predominant color of the original image.\n                \"predominant-color-pixel\": [\n                    {\n                        width: \"iw_div_2\",\n                        aspect_ratio: 1,\n                        crop: \"pad\",\n                        background: \"auto\"\n                    },\n                    {\n                        crop: \"crop\",\n                        width: 1,\n                        height: 1,\n                        gravity: \"north_east\"\n                    },\n                    {\n                        fetch_format: \"auto\",\n                        quality: \"auto\"\n                    }\n                ],\n                // Generates an image which color is the predominant color of the original image.\n                \"predominant-color\": [\n                    {\n                        variables: [\n                            [\n                                \"$currWidth\",\n                                \"w\"\n                            ],\n                            [\n                                \"$currHeight\",\n                                \"h\"\n                            ]\n                        ]\n                    },\n                    {\n                        width: \"iw_div_2\",\n                        aspect_ratio: 1,\n                        crop: \"pad\",\n                        background: \"auto\"\n                    },\n                    {\n                        crop: \"crop\",\n                        width: 10,\n                        height: 10,\n                        gravity: \"north_east\"\n                    },\n                    {\n                        width: \"$currWidth\",\n                        height: \"$currHeight\",\n                        crop: \"fill\"\n                    },\n                    {\n                        fetch_format: \"auto\",\n                        quality: \"auto\"\n                    }\n                ],\n                \"vectorize\": [\n                    {\n                        effect: \"vectorize:3:0.1\",\n                        fetch_format: \"svg\"\n                    }\n                ]\n            };\n            /**\n * Predefined accessibility transformations\n * @const {Object} Cloudinary.ACCESSIBILITY_MODES\n */ var ACCESSIBILITY_MODES = {\n                darkmode: \"tint:75:black\",\n                brightmode: \"tint:50:white\",\n                monochrome: \"grayscale\",\n                colorblind: \"assist_colorblind\"\n            };\n            /**\n * A list of keys used by the url() function.\n * @private\n */ var URL_KEYS = [\n                \"accessibility\",\n                \"api_secret\",\n                \"auth_token\",\n                \"cdn_subdomain\",\n                \"cloud_name\",\n                \"cname\",\n                \"format\",\n                \"placeholder\",\n                \"private_cdn\",\n                \"resource_type\",\n                \"secure\",\n                \"secure_cdn_subdomain\",\n                \"secure_distribution\",\n                \"shorten\",\n                \"sign_url\",\n                \"signature\",\n                \"ssl_detected\",\n                \"type\",\n                \"url_suffix\",\n                \"use_root_path\",\n                \"version\"\n            ];\n            /**\n * The resource storage type\n * @typedef type\n * @enum {string}\n * @property  {string} 'upload' A resource uploaded directly to Cloudinary\n * @property  {string} 'fetch' A resource fetched by Cloudinary from a 3rd party storage\n * @property  {string} 'private'\n * @property  {string} 'authenticated'\n * @property  {string} 'sprite'\n * @property  {string} 'facebook'\n * @property  {string} 'twitter'\n * @property  {string} 'youtube'\n * @property  {string} 'vimeo'\n *\n */ /**\n * The resource type\n * @typedef resourceType\n * @enum {string}\n * @property {string} 'image' An image file\n * @property {string} 'video' A video file\n * @property {string} 'raw'   A raw file\n */ // CONCATENATED MODULE: ./src/util/baseutil.js\n            function baseutil_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return baseutil_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, baseutil_typeof(obj);\n            }\n            /*\n * Includes common utility methods and shims\n */ function omit(obj, keys) {\n                obj = obj || {};\n                var srcKeys = Object.keys(obj).filter(function(key) {\n                    return !includes_root_includes_default()(keys, key);\n                });\n                var filtered = {};\n                srcKeys.forEach(function(key) {\n                    return filtered[key] = obj[key];\n                });\n                return filtered;\n            }\n            /**\n * Return true if all items in list are strings\n * @function Util.allString\n * @param {Array} list - an array of items\n */ var baseutil_allStrings = function allStrings(list) {\n                return list.length && list.every(isString_root_isString_default.a);\n            };\n            /**\n* Creates a new array without the given item.\n* @function Util.without\n* @param {Array} array - original array\n* @param {*} item - the item to exclude from the new array\n* @return {Array} a new array made of the original array's items except for `item`\n */ var without = function without(array, item) {\n                return array.filter(function(v) {\n                    return v !== item;\n                });\n            };\n            /**\n* Return true is value is a number or a string representation of a number.\n* @function Util.isNumberLike\n* @param {*} value\n* @returns {boolean} true if value is a number\n* @example\n*    Util.isNumber(0) // true\n*    Util.isNumber(\"1.3\") // true\n*    Util.isNumber(\"\") // false\n*    Util.isNumber(undefined) // false\n */ var isNumberLike = function isNumberLike(value) {\n                return value != null && !isNaN(parseFloat(value));\n            };\n            /**\n * Escape all characters matching unsafe in the given string\n * @function Util.smartEscape\n * @param {string} string - source string to escape\n * @param {RegExp} unsafe - characters that must be escaped\n * @return {string} escaped string\n */ var smartEscape = function smartEscape(string) {\n                var unsafe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /([^a-zA-Z0-9_.\\-\\/:]+)/g;\n                return string.replace(unsafe, function(match) {\n                    return match.split(\"\").map(function(c) {\n                        return \"%\" + c.charCodeAt(0).toString(16).toUpperCase();\n                    }).join(\"\");\n                });\n            };\n            /**\n * Assign values from sources if they are not defined in the destination.\n * Once a value is set it does not change\n * @function Util.defaults\n * @param {Object} destination - the object to assign defaults to\n * @param {...Object} source - the source object(s) to assign defaults from\n * @return {Object} destination after it was modified\n */ var defaults = function defaults(destination) {\n                for(var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    sources[_key - 1] = arguments[_key];\n                }\n                return sources.reduce(function(dest, source) {\n                    var key, value;\n                    for(key in source){\n                        value = source[key];\n                        if (dest[key] === void 0) {\n                            dest[key] = value;\n                        }\n                    }\n                    return dest;\n                }, destination);\n            };\n            /*********** lodash functions */ var objectProto = Object.prototype;\n            /**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */ var objToString = objectProto.toString;\n            /**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n#isObject({});\n * // => true\n *\n#isObject([1, 2, 3]);\n * // => true\n *\n#isObject(1);\n * // => false\n */ var isObject = function isObject(value) {\n                var type; // Avoid a V8 JIT bug in Chrome 19-20.\n                // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n                type = baseutil_typeof(value);\n                return !!value && (type === \"object\" || type === \"function\");\n            };\n            var funcTag = \"[object Function]\";\n            /**\n* Checks if `value` is classified as a `Function` object.\n* @function Util.isFunction\n* @param {*} value The value to check.\n* @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n* @example\n*\n* function Foo(){};\n* isFunction(Foo);\n* // => true\n*\n* isFunction(/abc/);\n* // => false\n */ var isFunction = function isFunction(value) {\n                // The use of `Object#toString` avoids issues with the `typeof` operator\n                // in older versions of Chrome and Safari which return 'function' for regexes\n                // and Safari 8 which returns 'object' for typed array constructors.\n                return isObject(value) && objToString.call(value) === funcTag;\n            };\n            /*********** lodash functions */ /** Used to match words to create compound words. */ var reWords = function() {\n                var lower, upper;\n                upper = \"[A-Z]\";\n                lower = \"[a-z]+\";\n                return RegExp(upper + \"+(?=\" + upper + lower + \")|\" + upper + \"?\" + lower + \"|\" + upper + \"+|[0-9]+\", \"g\");\n            }();\n            /**\n* Convert string to camelCase\n* @function Util.camelCase\n* @param {string} source - the string to convert\n* @return {string} in camelCase format\n */ var camelCase = function camelCase(source) {\n                var words = source.match(reWords);\n                words = words.map(function(word) {\n                    return word.charAt(0).toLocaleUpperCase() + word.slice(1).toLocaleLowerCase();\n                });\n                words[0] = words[0].toLocaleLowerCase();\n                return words.join(\"\");\n            };\n            /**\n * Convert string to snake_case\n * @function Util.snakeCase\n * @param {string} source - the string to convert\n * @return {string} in snake_case format\n */ var snakeCase = function snakeCase(source) {\n                var words = source.match(reWords);\n                words = words.map(function(word) {\n                    return word.toLocaleLowerCase();\n                });\n                return words.join(\"_\");\n            };\n            /**\n * Creates a new object from source, with the keys transformed using the converter.\n * @param {object} source\n * @param {function|null} converter\n * @returns {object}\n */ var convertKeys = function convertKeys(source, converter) {\n                var result, value;\n                result = {};\n                for(var key in source){\n                    value = source[key];\n                    if (converter) {\n                        key = converter(key);\n                    }\n                    if (!isEmpty(key)) {\n                        result[key] = value;\n                    }\n                }\n                return result;\n            };\n            /**\n * Create a copy of the source object with all keys in camelCase\n * @function Util.withCamelCaseKeys\n * @param {Object} value - the object to copy\n * @return {Object} a new object\n */ var withCamelCaseKeys = function withCamelCaseKeys(source) {\n                return convertKeys(source, camelCase);\n            };\n            /**\n * Create a copy of the source object with all keys in snake_case\n * @function Util.withSnakeCaseKeys\n * @param {Object} value - the object to copy\n * @return {Object} a new object\n */ var withSnakeCaseKeys = function withSnakeCaseKeys(source) {\n                return convertKeys(source, snakeCase);\n            }; // Browser\n            // Node.js\n            var base64Encode = typeof btoa !== \"undefined\" && isFunction(btoa) ? btoa : typeof Buffer !== \"undefined\" && isFunction(Buffer) ? function(input) {\n                if (!(input instanceof Buffer)) {\n                    input = new Buffer.from(String(input), \"binary\");\n                }\n                return input.toString(\"base64\");\n            } : function(input) {\n                throw new Error(\"No base64 encoding function found\");\n            };\n            /**\n* Returns the Base64-decoded version of url.<br>\n* This method delegates to `btoa` if present. Otherwise it tries `Buffer`.\n* @function Util.base64EncodeURL\n* @param {string} url - the url to encode. the value is URIdecoded and then re-encoded before converting to base64 representation\n* @return {string} the base64 representation of the URL\n */ var base64EncodeURL = function base64EncodeURL(url) {\n                try {\n                    url = decodeURI(url);\n                } finally{\n                    url = encodeURI(url);\n                }\n                return base64Encode(url);\n            };\n            /**\n * Create a new object with only URL parameters\n * @param {object} options The source object\n * @return {Object} An object containing only URL parameters\n */ function extractUrlParams(options) {\n                return URL_KEYS.reduce(function(obj, key) {\n                    if (options[key] != null) {\n                        obj[key] = options[key];\n                    }\n                    return obj;\n                }, {});\n            }\n            /**\n * Handle the format parameter for fetch urls\n * @private\n * @param options url and transformation options. This argument may be changed by the function!\n */ function patchFetchFormat(options) {\n                if (options == null) {\n                    options = {};\n                }\n                if (options.type === \"fetch\") {\n                    if (options.fetch_format == null) {\n                        options.fetch_format = optionConsume(options, \"format\");\n                    }\n                }\n            }\n            /**\n * Deletes `option_name` from `options` and return the value if present.\n * If `options` doesn't contain `option_name` the default value is returned.\n * @param {Object} options a collection\n * @param {String} option_name the name (key) of the desired value\n * @param {*} [default_value] the value to return is option_name is missing\n */ function optionConsume(options, option_name, default_value) {\n                var result = options[option_name];\n                delete options[option_name];\n                if (result != null) {\n                    return result;\n                } else {\n                    return default_value;\n                }\n            }\n            /**\n * Returns true if value is empty:\n * <ul>\n *   <li>value is null or undefined</li>\n *   <li>value is an array or string of length 0</li>\n *   <li>value is an object with no keys</li>\n * </ul>\n * @function Util.isEmpty\n * @param value\n * @returns {boolean} true if value is empty\n */ function isEmpty(value) {\n                if (value == null) {\n                    return true;\n                }\n                if (typeof value.length == \"number\") {\n                    return value.length === 0;\n                }\n                if (typeof value.size == \"number\") {\n                    return value.size === 0;\n                }\n                if (baseutil_typeof(value) == \"object\") {\n                    for(var key in value){\n                        if (value.hasOwnProperty(key)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                return true;\n            }\n            // CONCATENATED MODULE: ./src/util/browser.js\n            /**\n * Based on video.js implementation:\n * https://github.com/videojs/video.js/blob/4238f5c1d88890547153e7e1de7bd0d1d8e0b236/src/js/utils/browser.js\n */ /**\n* Retrieve from the navigator the user agent property.\n* @returns user agent property.\n*/ function getUserAgent() {\n                return navigator && navigator.userAgent || \"\";\n            }\n            /**\n * Detect if current browser is any Android\n * @returns true if current browser is Android, false otherwise.\n */ function isAndroid() {\n                var userAgent = getUserAgent();\n                return /Android/i.test(userAgent);\n            }\n            /**\n * Detect if current browser is any Edge\n * @returns true if current browser is Edge, false otherwise.\n */ function isEdge() {\n                var userAgent = getUserAgent();\n                return /Edg/i.test(userAgent);\n            }\n            /**\n * Detect if current browser is chrome.\n * @returns true if current browser is Chrome, false otherwise.\n */ function isChrome() {\n                var userAgent = getUserAgent();\n                return !isEdge() && (/Chrome/i.test(userAgent) || /CriOS/i.test(userAgent));\n            }\n            /**\n * Detect if current browser is Safari.\n * @returns true if current browser is Safari, false otherwise.\n */ function isSafari() {\n                // User agents for other browsers might include \"Safari\" so we must exclude them.\n                // For example - this is the chrome user agent on windows 10:\n                // Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36\n                var userAgent = getUserAgent();\n                return /Safari/i.test(userAgent) && !isChrome() && !isAndroid() && !isEdge();\n            }\n            // CONCATENATED MODULE: ./src/util/lodash.js\n            var nodeContains;\n            /*\n * Includes utility methods and lodash / jQuery shims\n */ /**\n * Get data from the DOM element.\n *\n * This method will use jQuery's `data()` method if it is available, otherwise it will get the `data-` attribute\n * @param {Element} element - the element to get the data from\n * @param {string} name - the name of the data item\n * @returns the value associated with the `name`\n * @function Util.getData\n */ var lodash_getData = function getData(element, name) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.getAttribute):\n                        return element.getAttribute(\"data-\".concat(name));\n                    case !isFunction_root_isFunction_default()(element.getAttr):\n                        return element.getAttr(\"data-\".concat(name));\n                    case !isFunction_root_isFunction_default()(element.data):\n                        return element.data(name);\n                    case !(isFunction_root_isFunction_default()(typeof jQuery !== \"undefined\" && jQuery.fn && jQuery.fn.data) && isElement_root_isElement_default()(element)):\n                        return jQuery(element).data(name);\n                }\n            };\n            /**\n * Set data in the DOM element.\n *\n * This method will use jQuery's `data()` method if it is available, otherwise it will set the `data-` attribute\n * @function Util.setData\n * @param {Element} element - the element to set the data in\n * @param {string} name - the name of the data item\n * @param {*} value - the value to be set\n *\n */ var lodash_setData = function setData(element, name, value) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.setAttribute):\n                        return element.setAttribute(\"data-\".concat(name), value);\n                    case !isFunction_root_isFunction_default()(element.setAttr):\n                        return element.setAttr(\"data-\".concat(name), value);\n                    case !isFunction_root_isFunction_default()(element.data):\n                        return element.data(name, value);\n                    case !(isFunction_root_isFunction_default()(typeof jQuery !== \"undefined\" && jQuery.fn && jQuery.fn.data) && isElement_root_isElement_default()(element)):\n                        return jQuery(element).data(name, value);\n                }\n            };\n            /**\n * Get attribute from the DOM element.\n *\n * @function Util.getAttribute\n * @param {Element} element - the element to set the attribute for\n * @param {string} name - the name of the attribute\n * @returns {*} the value of the attribute\n *\n */ var lodash_getAttribute = function getAttribute(element, name) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.getAttribute):\n                        return element.getAttribute(name);\n                    case !isFunction_root_isFunction_default()(element.attr):\n                        return element.attr(name);\n                    case !isFunction_root_isFunction_default()(element.getAttr):\n                        return element.getAttr(name);\n                }\n            };\n            /**\n * Set attribute in the DOM element.\n *\n * @function Util.setAttribute\n * @param {Element} element - the element to set the attribute for\n * @param {string} name - the name of the attribute\n * @param {*} value - the value to be set\n */ var lodash_setAttribute = function setAttribute(element, name, value) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.setAttribute):\n                        return element.setAttribute(name, value);\n                    case !isFunction_root_isFunction_default()(element.attr):\n                        return element.attr(name, value);\n                    case !isFunction_root_isFunction_default()(element.setAttr):\n                        return element.setAttr(name, value);\n                }\n            };\n            /**\n * Remove an attribute in the DOM element.\n *\n * @function Util.removeAttribute\n * @param {Element} element - the element to set the attribute for\n * @param {string} name - the name of the attribute\n */ var lodash_removeAttribute = function removeAttribute(element, name) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.removeAttribute):\n                        return element.removeAttribute(name);\n                    default:\n                        return lodash_setAttribute(element, void 0);\n                }\n            };\n            /**\n * Set a group of attributes to the element\n * @function Util.setAttributes\n * @param {Element} element - the element to set the attributes for\n * @param {Object} attributes - a hash of attribute names and values\n */ var setAttributes = function setAttributes(element, attributes) {\n                var name, results, value;\n                results = [];\n                for(name in attributes){\n                    value = attributes[name];\n                    if (value != null) {\n                        results.push(lodash_setAttribute(element, name, value));\n                    } else {\n                        results.push(lodash_removeAttribute(element, name));\n                    }\n                }\n                return results;\n            };\n            /**\n * Checks if element has a css class\n * @function Util.hasClass\n * @param {Element} element - the element to check\n * @param {string} name - the class name\n @returns {boolean} true if the element has the class\n */ var lodash_hasClass = function hasClass(element, name) {\n                if (isElement_root_isElement_default()(element)) {\n                    return element.className.match(new RegExp(\"\\\\b\".concat(name, \"\\\\b\")));\n                }\n            };\n            /**\n * Add class to the element\n * @function Util.addClass\n * @param {Element} element - the element\n * @param {string} name - the class name to add\n */ var lodash_addClass = function addClass(element, name) {\n                if (!element.className.match(new RegExp(\"\\\\b\".concat(name, \"\\\\b\")))) {\n                    return element.className = trim_root_trim_default()(\"\".concat(element.className, \" \").concat(name));\n                }\n            }; // The following code is taken from jQuery\n            var getStyles = function getStyles(elem) {\n                // Support: IE<=11+, Firefox<=30+ (#15098, #14150)\n                // IE throws on elements created in popups\n                // FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n                if (elem.ownerDocument.defaultView.opener) {\n                    return elem.ownerDocument.defaultView.getComputedStyle(elem, null);\n                }\n                return window.getComputedStyle(elem, null);\n            };\n            var cssExpand = [\n                \"Top\",\n                \"Right\",\n                \"Bottom\",\n                \"Left\"\n            ];\n            nodeContains = function nodeContains(a, b) {\n                var adown, bup;\n                adown = a.nodeType === 9 ? a.documentElement : a;\n                bup = b && b.parentNode;\n                return a === bup || !!(bup && bup.nodeType === 1 && adown.contains(bup));\n            }; // Truncated version of jQuery.style(elem, name)\n            var domStyle = function domStyle(elem, name) {\n                if (!(!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style)) {\n                    return elem.style[name];\n                }\n            };\n            var curCSS = function curCSS(elem, name, computed) {\n                var maxWidth, minWidth, ret, rmargin, style, width;\n                rmargin = /^margin/;\n                width = void 0;\n                minWidth = void 0;\n                maxWidth = void 0;\n                ret = void 0;\n                style = elem.style;\n                computed = computed || getStyles(elem);\n                if (computed) {\n                    // Support: IE9\n                    // getPropertyValue is only needed for .css('filter') (#12537)\n                    ret = computed.getPropertyValue(name) || computed[name];\n                }\n                if (computed) {\n                    if (ret === \"\" && !nodeContains(elem.ownerDocument, elem)) {\n                        ret = domStyle(elem, name);\n                    } // Support: iOS < 6\n                    // A tribute to the \"awesome hack by Dean Edwards\"\n                    // iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n                    // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n                    if (rnumnonpx.test(ret) && rmargin.test(name)) {\n                        // Remember the original values\n                        width = style.width;\n                        minWidth = style.minWidth;\n                        maxWidth = style.maxWidth; // Put in the new values to get a computed value out\n                        style.minWidth = style.maxWidth = style.width = ret;\n                        ret = computed.width; // Revert the changed values\n                        style.width = width;\n                        style.minWidth = minWidth;\n                        style.maxWidth = maxWidth;\n                    }\n                } // Support: IE\n                // IE returns zIndex value as an integer.\n                if (ret !== undefined) {\n                    return ret + \"\";\n                } else {\n                    return ret;\n                }\n            };\n            var cssValue = function cssValue(elem, name, convert, styles) {\n                var val;\n                val = curCSS(elem, name, styles);\n                if (convert) {\n                    return parseFloat(val);\n                } else {\n                    return val;\n                }\n            };\n            var augmentWidthOrHeight = function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {\n                var i, len, side, sides, val; // If we already have the right measurement, avoid augmentation\n                // Otherwise initialize for horizontal or vertical properties\n                if (extra === (isBorderBox ? \"border\" : \"content\")) {\n                    return 0;\n                } else {\n                    sides = name === \"width\" ? [\n                        \"Right\",\n                        \"Left\"\n                    ] : [\n                        \"Top\",\n                        \"Bottom\"\n                    ];\n                    val = 0;\n                    for(i = 0, len = sides.length; i < len; i++){\n                        side = sides[i];\n                        if (extra === \"margin\") {\n                            // Both box models exclude margin, so add it if we want it\n                            val += cssValue(elem, extra + side, true, styles);\n                        }\n                        if (isBorderBox) {\n                            if (extra === \"content\") {\n                                // border-box includes padding, so remove it if we want content\n                                val -= cssValue(elem, \"padding\".concat(side), true, styles);\n                            }\n                            if (extra !== \"margin\") {\n                                // At this point, extra isn't border nor margin, so remove border\n                                val -= cssValue(elem, \"border\".concat(side, \"Width\"), true, styles);\n                            }\n                        } else {\n                            // At this point, extra isn't content, so add padding\n                            val += cssValue(elem, \"padding\".concat(side), true, styles);\n                            if (extra !== \"padding\") {\n                                // At this point, extra isn't content nor padding, so add border\n                                val += cssValue(elem, \"border\".concat(side, \"Width\"), true, styles);\n                            }\n                        }\n                    }\n                    return val;\n                }\n            };\n            var pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\n            var rnumnonpx = new RegExp(\"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\");\n            var getWidthOrHeight = function getWidthOrHeight(elem, name, extra) {\n                var isBorderBox, styles, val, valueIsBorderBox; // Start with offset property, which is equivalent to the border-box value\n                valueIsBorderBox = true;\n                val = name === \"width\" ? elem.offsetWidth : elem.offsetHeight;\n                styles = getStyles(elem);\n                isBorderBox = cssValue(elem, \"boxSizing\", false, styles) === \"border-box\"; // Some non-html elements return undefined for offsetWidth, so check for null/undefined\n                // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n                // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n                if (val <= 0 || val == null) {\n                    // Fall back to computed then uncomputed css if necessary\n                    val = curCSS(elem, name, styles);\n                    if (val < 0 || val == null) {\n                        val = elem.style[name];\n                    }\n                    if (rnumnonpx.test(val)) {\n                        // Computed unit is not pixels. Stop here and return.\n                        return val;\n                    } // Check for style in case a browser which returns unreliable values\n                    // for getComputedStyle silently falls back to the reliable elem.style\n                    //    valueIsBorderBox = isBorderBox and (support.boxSizingReliable() or val is elem.style[name])\n                    valueIsBorderBox = isBorderBox && val === elem.style[name]; // Normalize \"\", auto, and prepare for extra\n                    val = parseFloat(val) || 0;\n                } // Use the active box-sizing model to add/subtract irrelevant styles\n                return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? \"border\" : \"content\"), valueIsBorderBox, styles);\n            };\n            var lodash_width = function width(element) {\n                return getWidthOrHeight(element, \"width\", \"content\");\n            };\n            /**\n * @class Util\n */ /**\n * Returns true if item is a string\n * @function Util.isString\n * @param item\n * @returns {boolean} true if item is a string\n */ /**\n * Returns true if item is empty:\n * <ul>\n *   <li>item is null or undefined</li>\n *   <li>item is an array or string of length 0</li>\n *   <li>item is an object with no keys</li>\n * </ul>\n * @function Util.isEmpty\n * @param item\n * @returns {boolean} true if item is empty\n */ /**\n * Assign source properties to destination.\n * If the property is an object it is assigned as a whole, overriding the destination object.\n * @function Util.assign\n * @param {Object} destination - the object to assign to\n */ /**\n * Recursively assign source properties to destination\n * @function Util.merge\n * @param {Object} destination - the object to assign to\n * @param {...Object} [sources] The source objects.\n */ /**\n * Create a new copy of the given object, including all internal objects.\n * @function Util.cloneDeep\n * @param {Object} value - the object to clone\n * @return {Object} a new deep copy of the object\n */ /**\n * Creates a new array from the parameter with \"falsey\" values removed\n * @function Util.compact\n * @param {Array} array - the array to remove values from\n * @return {Array} a new array without falsey values\n */ /**\n * Check if a given item is included in the given array\n * @function Util.contains\n * @param {Array} array - the array to search in\n * @param {*} item - the item to search for\n * @return {boolean} true if the item is included in the array\n */ /**\n * Returns values in the given array that are not included in the other array\n * @function Util.difference\n * @param {Array} arr - the array to select from\n * @param {Array} values - values to filter from arr\n * @return {Array} the filtered values\n */ /**\n * Returns a list of all the function names in obj\n * @function Util.functions\n * @param {Object} object - the object to inspect\n * @return {Array} a list of functions of object\n */ /**\n * Returns the provided value. This functions is used as a default predicate function.\n * @function Util.identity\n * @param {*} value\n * @return {*} the provided value\n */ /**\n * Remove leading or trailing spaces from text\n * @function Util.trim\n * @param {string} text\n * @return {string} the `text` without leading or trailing spaces\n */ // CONCATENATED MODULE: ./src/expression.js\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function _createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) _defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            /**\n * Represents a transformation expression.\n * @param {string} expressionStr - An expression in string format.\n * @class Expression\n * Normally this class is not instantiated directly\n */ var Expression = /*#__PURE__*/ function() {\n                function Expression(expressionStr) {\n                    _classCallCheck(this, Expression);\n                    /**\n     * @protected\n     * @inner Expression-expressions\n     */ this.expressions = [];\n                    if (expressionStr != null) {\n                        this.expressions.push(Expression.normalize(expressionStr));\n                    }\n                }\n                /**\n   * Convenience constructor method\n   * @function Expression.new\n   */ _createClass(Expression, [\n                    {\n                        key: \"serialize\",\n                        value: /**\n     * Serialize the expression\n     * @return {string} the expression as a string\n     */ function serialize() {\n                            return Expression.normalize(this.expressions.join(\"_\"));\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            return this.serialize();\n                        }\n                    },\n                    {\n                        key: \"getParent\",\n                        value: function getParent() {\n                            return this.parent;\n                        }\n                    },\n                    {\n                        key: \"setParent\",\n                        value: function setParent(parent) {\n                            this.parent = parent;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"predicate\",\n                        value: function predicate(name, operator, value) {\n                            if (Expression.OPERATORS[operator] != null) {\n                                operator = Expression.OPERATORS[operator];\n                            }\n                            this.expressions.push(\"\".concat(name, \"_\").concat(operator, \"_\").concat(value));\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"and\",\n                        value: function and() {\n                            this.expressions.push(\"and\");\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"or\",\n                        value: function or() {\n                            this.expressions.push(\"or\");\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"then\",\n                        value: function then() {\n                            return this.getParent()[\"if\"](this.toString());\n                        }\n                    },\n                    {\n                        key: \"height\",\n                        value: function height(operator, value) {\n                            return this.predicate(\"h\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"width\",\n                        value: function width(operator, value) {\n                            return this.predicate(\"w\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"aspectRatio\",\n                        value: function aspectRatio(operator, value) {\n                            return this.predicate(\"ar\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"pageCount\",\n                        value: function pageCount(operator, value) {\n                            return this.predicate(\"pc\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"faceCount\",\n                        value: function faceCount(operator, value) {\n                            return this.predicate(\"fc\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value(_value) {\n                            this.expressions.push(_value);\n                            return this;\n                        }\n                    }\n                ], [\n                    {\n                        key: \"new\",\n                        value: function _new(expressionStr) {\n                            return new this(expressionStr);\n                        }\n                    },\n                    {\n                        key: \"normalize\",\n                        value: function normalize(expression) {\n                            if (expression == null) {\n                                return expression;\n                            }\n                            expression = String(expression);\n                            var operators = \"\\\\|\\\\||>=|<=|&&|!=|>|=|<|/|-|\\\\+|\\\\*|\\\\^\"; // operators\n                            var operatorsPattern = \"((\" + operators + \")(?=[ _]))\";\n                            var operatorsReplaceRE = new RegExp(operatorsPattern, \"g\");\n                            expression = expression.replace(operatorsReplaceRE, function(match) {\n                                return Expression.OPERATORS[match];\n                            }); // predefined variables\n                            // The :${v} part is to prevent normalization of vars with a preceding colon (such as :duration),\n                            // It won't be found in PREDEFINED_VARS and so won't be normalized.\n                            // It is done like this because ie11 does not support regex lookbehind\n                            var predefinedVarsPattern = \"(\" + Object.keys(Expression.PREDEFINED_VARS).map(function(v) {\n                                return \":\".concat(v, \"|\").concat(v);\n                            }).join(\"|\") + \")\";\n                            var userVariablePattern = \"(\\\\$_*[^_ ]+)\";\n                            var variablesReplaceRE = new RegExp(\"\".concat(userVariablePattern, \"|\").concat(predefinedVarsPattern), \"g\");\n                            expression = expression.replace(variablesReplaceRE, function(match) {\n                                return Expression.PREDEFINED_VARS[match] || match;\n                            });\n                            return expression.replace(/[ _]+/g, \"_\");\n                        }\n                    },\n                    {\n                        key: \"variable\",\n                        value: function variable(name, value) {\n                            return new this(name).value(value);\n                        }\n                    },\n                    {\n                        key: \"width\",\n                        value: function width() {\n                            return new this(\"width\");\n                        }\n                    },\n                    {\n                        key: \"height\",\n                        value: function height() {\n                            return new this(\"height\");\n                        }\n                    },\n                    {\n                        key: \"initialWidth\",\n                        value: function initialWidth() {\n                            return new this(\"initialWidth\");\n                        }\n                    },\n                    {\n                        key: \"initialHeight\",\n                        value: function initialHeight() {\n                            return new this(\"initialHeight\");\n                        }\n                    },\n                    {\n                        key: \"aspectRatio\",\n                        value: function aspectRatio() {\n                            return new this(\"aspectRatio\");\n                        }\n                    },\n                    {\n                        key: \"initialAspectRatio\",\n                        value: function initialAspectRatio() {\n                            return new this(\"initialAspectRatio\");\n                        }\n                    },\n                    {\n                        key: \"pageCount\",\n                        value: function pageCount() {\n                            return new this(\"pageCount\");\n                        }\n                    },\n                    {\n                        key: \"faceCount\",\n                        value: function faceCount() {\n                            return new this(\"faceCount\");\n                        }\n                    },\n                    {\n                        key: \"currentPage\",\n                        value: function currentPage() {\n                            return new this(\"currentPage\");\n                        }\n                    },\n                    {\n                        key: \"tags\",\n                        value: function tags() {\n                            return new this(\"tags\");\n                        }\n                    },\n                    {\n                        key: \"pageX\",\n                        value: function pageX() {\n                            return new this(\"pageX\");\n                        }\n                    },\n                    {\n                        key: \"pageY\",\n                        value: function pageY() {\n                            return new this(\"pageY\");\n                        }\n                    }\n                ]);\n                return Expression;\n            }();\n            /**\n * @internal\n */ Expression.OPERATORS = {\n                \"=\": \"eq\",\n                \"!=\": \"ne\",\n                \"<\": \"lt\",\n                \">\": \"gt\",\n                \"<=\": \"lte\",\n                \">=\": \"gte\",\n                \"&&\": \"and\",\n                \"||\": \"or\",\n                \"*\": \"mul\",\n                \"/\": \"div\",\n                \"+\": \"add\",\n                \"-\": \"sub\",\n                \"^\": \"pow\"\n            };\n            /**\n * @internal\n */ Expression.PREDEFINED_VARS = {\n                \"aspect_ratio\": \"ar\",\n                \"aspectRatio\": \"ar\",\n                \"current_page\": \"cp\",\n                \"currentPage\": \"cp\",\n                \"duration\": \"du\",\n                \"face_count\": \"fc\",\n                \"faceCount\": \"fc\",\n                \"height\": \"h\",\n                \"initial_aspect_ratio\": \"iar\",\n                \"initial_duration\": \"idu\",\n                \"initial_height\": \"ih\",\n                \"initial_width\": \"iw\",\n                \"initialAspectRatio\": \"iar\",\n                \"initialDuration\": \"idu\",\n                \"initialHeight\": \"ih\",\n                \"initialWidth\": \"iw\",\n                \"page_count\": \"pc\",\n                \"page_x\": \"px\",\n                \"page_y\": \"py\",\n                \"pageCount\": \"pc\",\n                \"pageX\": \"px\",\n                \"pageY\": \"py\",\n                \"tags\": \"tags\",\n                \"width\": \"w\"\n            };\n            /**\n * @internal\n */ Expression.BOUNDRY = \"[ _]+\";\n            /* harmony default export */ var expression = Expression;\n            // CONCATENATED MODULE: ./src/condition.js\n            function condition_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return condition_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, condition_typeof(obj);\n            }\n            function condition_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function condition_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function condition_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) condition_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) condition_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) _setPrototypeOf(subClass, superClass);\n            }\n            function _setPrototypeOf(o, p) {\n                _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return _setPrototypeOf(o, p);\n            }\n            function _createSuper(Derived) {\n                var hasNativeReflectConstruct = _isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = _getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = _getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return _possibleConstructorReturn(this, result);\n                };\n            }\n            function _possibleConstructorReturn(self, call) {\n                if (call && (condition_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return _assertThisInitialized(self);\n            }\n            function _assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function _isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function _getPrototypeOf(o) {\n                _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return _getPrototypeOf(o);\n            }\n            /**\n * Represents a transformation condition.\n * @param {string} conditionStr - a condition in string format\n * @class Condition\n * @example\n * // normally this class is not instantiated directly\n * var tr = cloudinary.Transformation.new()\n *    .if().width( \">\", 1000).and().aspectRatio(\"<\", \"3:4\").then()\n *      .width(1000)\n *      .crop(\"scale\")\n *    .else()\n *      .width(500)\n *      .crop(\"scale\")\n *\n * var tr = cloudinary.Transformation.new()\n *    .if(\"w > 1000 and aspectRatio < 3:4\")\n *      .width(1000)\n *      .crop(\"scale\")\n *    .else()\n *      .width(500)\n *      .crop(\"scale\")\n *\n */ var Condition = /*#__PURE__*/ function(_Expression) {\n                _inherits(Condition, _Expression);\n                var _super = _createSuper(Condition);\n                function Condition(conditionStr) {\n                    condition_classCallCheck(this, Condition);\n                    return _super.call(this, conditionStr);\n                }\n                /**\n   * @function Condition#height\n   * @param {string} operator the comparison operator (e.g. \"<\", \"lt\")\n   * @param {string|number} value the right hand side value\n   * @return {Condition} this condition\n   */ condition_createClass(Condition, [\n                    {\n                        key: \"height\",\n                        value: function height(operator, value) {\n                            return this.predicate(\"h\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"width\",\n                        value: function width(operator, value) {\n                            return this.predicate(\"w\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"aspectRatio\",\n                        value: function aspectRatio(operator, value) {\n                            return this.predicate(\"ar\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"pageCount\",\n                        value: function pageCount(operator, value) {\n                            return this.predicate(\"pc\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"faceCount\",\n                        value: function faceCount(operator, value) {\n                            return this.predicate(\"fc\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"duration\",\n                        value: function duration(operator, value) {\n                            return this.predicate(\"du\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"initialDuration\",\n                        value: function initialDuration(operator, value) {\n                            return this.predicate(\"idu\", operator, value);\n                        }\n                    }\n                ]);\n                return Condition;\n            }(expression);\n            /* harmony default export */ var condition = Condition;\n            // CONCATENATED MODULE: ./src/configuration.js\n            function _slicedToArray(arr, i) {\n                return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || configuration_unsupportedIterableToArray(arr, i) || _nonIterableRest();\n            }\n            function _nonIterableRest() {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function configuration_unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return configuration_arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return configuration_arrayLikeToArray(o, minLen);\n            }\n            function configuration_arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            function _iterableToArrayLimit(arr, i) {\n                var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n                if (_i == null) return;\n                var _arr = [];\n                var _n = true;\n                var _d = false;\n                var _s, _e;\n                try {\n                    for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n                        _arr.push(_s.value);\n                        if (i && _arr.length === i) break;\n                    }\n                } catch (err) {\n                    _d = true;\n                    _e = err;\n                } finally{\n                    try {\n                        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n                    } finally{\n                        if (_d) throw _e;\n                    }\n                }\n                return _arr;\n            }\n            function _arrayWithHoles(arr) {\n                if (Array.isArray(arr)) return arr;\n            }\n            function configuration_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function configuration_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function configuration_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) configuration_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) configuration_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            /**\n * Class for defining account configuration options.\n * Depends on 'utils'\n */ /**\n * Class for defining account configuration options.\n * @constructor Configuration\n * @param {Object} options - The account configuration parameters to set.\n * @see <a href=\"https://cloudinary.com/documentation/solution_overview#configuration_parameters\"\n *  target=\"_new\">Available configuration options</a>\n */ var configuration_Configuration = /*#__PURE__*/ function() {\n                function Configuration(options) {\n                    configuration_classCallCheck(this, Configuration);\n                    this.configuration = options == null ? {} : cloneDeep_root_cloneDeep_default()(options);\n                    defaults(this.configuration, DEFAULT_CONFIGURATION_PARAMS);\n                }\n                /**\n   * Initializes the configuration. This method is a convenience method that invokes both\n   *  {@link Configuration#fromEnvironment|fromEnvironment()} (Node.js environment only)\n   *  and {@link Configuration#fromDocument|fromDocument()}.\n   *  It first tries to retrieve the configuration from the environment variable.\n   *  If not available, it tries from the document meta tags.\n   * @function Configuration#init\n   * @return {Configuration} returns `this` for chaining\n   * @see fromDocument\n   * @see fromEnvironment\n   */ configuration_createClass(Configuration, [\n                    {\n                        key: \"init\",\n                        value: function init() {\n                            this.fromEnvironment();\n                            this.fromDocument();\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"set\",\n                        value: function set(name, value) {\n                            this.configuration[name] = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"get\",\n                        value: function get(name) {\n                            return this.configuration[name];\n                        }\n                    },\n                    {\n                        key: \"merge\",\n                        value: function merge(config) {\n                            assign_root_assign_default()(this.configuration, cloneDeep_root_cloneDeep_default()(config));\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fromDocument\",\n                        value: function fromDocument() {\n                            var el, i, len, meta_elements;\n                            meta_elements = typeof document !== \"undefined\" && document !== null ? document.querySelectorAll('meta[name^=\"cloudinary_\"]') : void 0;\n                            if (meta_elements) {\n                                for(i = 0, len = meta_elements.length; i < len; i++){\n                                    el = meta_elements[i];\n                                    this.configuration[el.getAttribute(\"name\").replace(\"cloudinary_\", \"\")] = el.getAttribute(\"content\");\n                                }\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fromEnvironment\",\n                        value: function fromEnvironment() {\n                            var _this = this;\n                            var cloudinary_url, query, uri, uriRegex;\n                            if (typeof process !== \"undefined\" && process !== null && process.env && process.env.CLOUDINARY_URL) {\n                                cloudinary_url = process.env.CLOUDINARY_URL;\n                                uriRegex = /cloudinary:\\/\\/(?:(\\w+)(?:\\:([\\w-]+))?@)?([\\w\\.-]+)(?:\\/([^?]*))?(?:\\?(.+))?/;\n                                uri = uriRegex.exec(cloudinary_url);\n                                if (uri) {\n                                    if (uri[3] != null) {\n                                        this.configuration[\"cloud_name\"] = uri[3];\n                                    }\n                                    if (uri[1] != null) {\n                                        this.configuration[\"api_key\"] = uri[1];\n                                    }\n                                    if (uri[2] != null) {\n                                        this.configuration[\"api_secret\"] = uri[2];\n                                    }\n                                    if (uri[4] != null) {\n                                        this.configuration[\"private_cdn\"] = uri[4] != null;\n                                    }\n                                    if (uri[4] != null) {\n                                        this.configuration[\"secure_distribution\"] = uri[4];\n                                    }\n                                    query = uri[5];\n                                    if (query != null) {\n                                        query.split(\"&\").forEach(function(value) {\n                                            var _value$split = value.split(\"=\"), _value$split2 = _slicedToArray(_value$split, 2), k = _value$split2[0], v = _value$split2[1];\n                                            if (v == null) {\n                                                v = true;\n                                            }\n                                            _this.configuration[k] = v;\n                                        });\n                                    }\n                                }\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"config\",\n                        value: function config(new_config, new_value) {\n                            switch(false){\n                                case new_value === void 0:\n                                    this.set(new_config, new_value);\n                                    return this.configuration;\n                                case !isString_root_isString_default()(new_config):\n                                    return this.get(new_config);\n                                case !isPlainObject_root_isPlainObject_default()(new_config):\n                                    this.merge(new_config);\n                                    return this.configuration;\n                                default:\n                                    // Backward compatibility - return the internal object\n                                    return this.configuration;\n                            }\n                        }\n                    },\n                    {\n                        key: \"toOptions\",\n                        value: function toOptions() {\n                            return cloneDeep_root_cloneDeep_default()(this.configuration);\n                        }\n                    }\n                ]);\n                return Configuration;\n            }();\n            var DEFAULT_CONFIGURATION_PARAMS = {\n                responsive_class: \"cld-responsive\",\n                responsive_use_breakpoints: true,\n                round_dpr: true,\n                secure: ( false ? 0 : void 0) === \"https:\"\n            };\n            configuration_Configuration.CONFIG_PARAMS = [\n                \"api_key\",\n                \"api_secret\",\n                \"callback\",\n                \"cdn_subdomain\",\n                \"cloud_name\",\n                \"cname\",\n                \"private_cdn\",\n                \"protocol\",\n                \"resource_type\",\n                \"responsive\",\n                \"responsive_class\",\n                \"responsive_use_breakpoints\",\n                \"responsive_width\",\n                \"round_dpr\",\n                \"secure\",\n                \"secure_cdn_subdomain\",\n                \"secure_distribution\",\n                \"shorten\",\n                \"type\",\n                \"upload_preset\",\n                \"url_suffix\",\n                \"use_root_path\",\n                \"version\",\n                \"externalLibraries\",\n                \"max_timeout_ms\"\n            ];\n            /* harmony default export */ var src_configuration = configuration_Configuration;\n            // CONCATENATED MODULE: ./src/layer/layer.js\n            function layer_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function layer_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function layer_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) layer_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) layer_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            var layer_Layer = /*#__PURE__*/ function() {\n                /**\n   * Layer\n   * @constructor Layer\n   * @param {Object} options - layer parameters\n   */ function Layer1(options) {\n                    var _this = this;\n                    layer_classCallCheck(this, Layer1);\n                    this.options = {};\n                    if (options != null) {\n                        [\n                            \"resourceType\",\n                            \"type\",\n                            \"publicId\",\n                            \"format\"\n                        ].forEach(function(key) {\n                            var ref;\n                            return _this.options[key] = (ref = options[key]) != null ? ref : options[snakeCase(key)];\n                        });\n                    }\n                }\n                layer_createClass(Layer1, [\n                    {\n                        key: \"resourceType\",\n                        value: function resourceType(value) {\n                            this.options.resourceType = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"type\",\n                        value: function type(value) {\n                            this.options.type = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"publicId\",\n                        value: function publicId(value) {\n                            this.options.publicId = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"getPublicId\",\n                        value: function getPublicId() {\n                            var ref;\n                            return (ref = this.options.publicId) != null ? ref.replace(/\\//g, \":\") : void 0;\n                        }\n                    },\n                    {\n                        key: \"getFullPublicId\",\n                        value: function getFullPublicId() {\n                            if (this.options.format != null) {\n                                return this.getPublicId() + \".\" + this.options.format;\n                            } else {\n                                return this.getPublicId();\n                            }\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(value) {\n                            this.options.format = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            var components;\n                            components = [];\n                            if (this.options.publicId == null) {\n                                throw \"Must supply publicId\";\n                            }\n                            if (!(this.options.resourceType === \"image\")) {\n                                components.push(this.options.resourceType);\n                            }\n                            if (!(this.options.type === \"upload\")) {\n                                components.push(this.options.type);\n                            }\n                            components.push(this.getFullPublicId());\n                            return compact_root_compact_default()(components).join(\":\");\n                        }\n                    },\n                    {\n                        key: \"clone\",\n                        value: function clone() {\n                            return new this.constructor(this.options);\n                        }\n                    }\n                ]);\n                return Layer1;\n            }();\n            /* harmony default export */ var layer_layer = layer_Layer;\n            // CONCATENATED MODULE: ./src/layer/textlayer.js\n            function textlayer_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return textlayer_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, textlayer_typeof(obj);\n            }\n            function textlayer_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function textlayer_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function textlayer_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) textlayer_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) textlayer_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function textlayer_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) textlayer_setPrototypeOf(subClass, superClass);\n            }\n            function textlayer_setPrototypeOf(o, p) {\n                textlayer_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return textlayer_setPrototypeOf(o, p);\n            }\n            function textlayer_createSuper(Derived) {\n                var hasNativeReflectConstruct = textlayer_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = textlayer_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = textlayer_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return textlayer_possibleConstructorReturn(this, result);\n                };\n            }\n            function textlayer_possibleConstructorReturn(self, call) {\n                if (call && (textlayer_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return textlayer_assertThisInitialized(self);\n            }\n            function textlayer_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function textlayer_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function textlayer_getPrototypeOf(o) {\n                textlayer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return textlayer_getPrototypeOf(o);\n            }\n            var textlayer_TextLayer = /*#__PURE__*/ function(_Layer) {\n                textlayer_inherits(TextLayer, _Layer);\n                var _super = textlayer_createSuper(TextLayer);\n                /**\n   * @constructor TextLayer\n   * @param {Object} options - layer parameters\n   */ function TextLayer(options) {\n                    var _this;\n                    textlayer_classCallCheck(this, TextLayer);\n                    var keys;\n                    _this = _super.call(this, options);\n                    keys = [\n                        \"resourceType\",\n                        \"resourceType\",\n                        \"fontFamily\",\n                        \"fontSize\",\n                        \"fontWeight\",\n                        \"fontStyle\",\n                        \"textDecoration\",\n                        \"textAlign\",\n                        \"stroke\",\n                        \"letterSpacing\",\n                        \"lineSpacing\",\n                        \"fontHinting\",\n                        \"fontAntialiasing\",\n                        \"text\",\n                        \"textStyle\"\n                    ];\n                    if (options != null) {\n                        keys.forEach(function(key) {\n                            var ref;\n                            return _this.options[key] = (ref = options[key]) != null ? ref : options[snakeCase(key)];\n                        });\n                    }\n                    _this.options.resourceType = \"text\";\n                    return _this;\n                }\n                textlayer_createClass(TextLayer, [\n                    {\n                        key: \"resourceType\",\n                        value: function resourceType(_resourceType) {\n                            throw \"Cannot modify resourceType for text layers\";\n                        }\n                    },\n                    {\n                        key: \"type\",\n                        value: function type(_type) {\n                            throw \"Cannot modify type for text layers\";\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(_format) {\n                            throw \"Cannot modify format for text layers\";\n                        }\n                    },\n                    {\n                        key: \"fontFamily\",\n                        value: function fontFamily(_fontFamily) {\n                            this.options.fontFamily = _fontFamily;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontSize\",\n                        value: function fontSize(_fontSize) {\n                            this.options.fontSize = _fontSize;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontWeight\",\n                        value: function fontWeight(_fontWeight) {\n                            this.options.fontWeight = _fontWeight;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontStyle\",\n                        value: function fontStyle(_fontStyle) {\n                            this.options.fontStyle = _fontStyle;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"textDecoration\",\n                        value: function textDecoration(_textDecoration) {\n                            this.options.textDecoration = _textDecoration;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"textAlign\",\n                        value: function textAlign(_textAlign) {\n                            this.options.textAlign = _textAlign;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"stroke\",\n                        value: function stroke(_stroke) {\n                            this.options.stroke = _stroke;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"letterSpacing\",\n                        value: function letterSpacing(_letterSpacing) {\n                            this.options.letterSpacing = _letterSpacing;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"lineSpacing\",\n                        value: function lineSpacing(_lineSpacing) {\n                            this.options.lineSpacing = _lineSpacing;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontHinting\",\n                        value: function fontHinting(_fontHinting) {\n                            this.options.fontHinting = _fontHinting;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontAntialiasing\",\n                        value: function fontAntialiasing(_fontAntialiasing) {\n                            this.options.fontAntialiasing = _fontAntialiasing;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"text\",\n                        value: function text(_text) {\n                            this.options.text = _text;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"textStyle\",\n                        value: function textStyle(_textStyle) {\n                            this.options.textStyle = _textStyle;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            var components, hasPublicId, hasStyle, publicId, re, res, start, style, text, textSource;\n                            style = this.textStyleIdentifier();\n                            if (this.options.publicId != null) {\n                                publicId = this.getFullPublicId();\n                            }\n                            if (this.options.text != null) {\n                                hasPublicId = !isEmpty(publicId);\n                                hasStyle = !isEmpty(style);\n                                if (hasPublicId && hasStyle || !hasPublicId && !hasStyle) {\n                                    throw \"Must supply either style parameters or a public_id when providing text parameter in a text overlay/underlay, but not both!\";\n                                }\n                                re = /\\$\\([a-zA-Z]\\w*\\)/g;\n                                start = 0; //        textSource = text.replace(new RegExp(\"[,/]\", 'g'), (c)-> \"%#{c.charCodeAt(0).toString(16).toUpperCase()}\")\n                                textSource = smartEscape(this.options.text, /[,\\/]/g);\n                                text = \"\";\n                                while(res = re.exec(textSource)){\n                                    text += smartEscape(textSource.slice(start, res.index));\n                                    text += res[0];\n                                    start = res.index + res[0].length;\n                                }\n                                text += smartEscape(textSource.slice(start));\n                            }\n                            components = [\n                                this.options.resourceType,\n                                style,\n                                publicId,\n                                text\n                            ];\n                            return compact_root_compact_default()(components).join(\":\");\n                        }\n                    },\n                    {\n                        key: \"textStyleIdentifier\",\n                        value: function textStyleIdentifier() {\n                            // Note: if a text-style argument is provided as a whole, it overrides everything else, no mix and match.\n                            if (!isEmpty(this.options.textStyle)) {\n                                return this.options.textStyle;\n                            }\n                            var components;\n                            components = [];\n                            if (this.options.fontWeight !== \"normal\") {\n                                components.push(this.options.fontWeight);\n                            }\n                            if (this.options.fontStyle !== \"normal\") {\n                                components.push(this.options.fontStyle);\n                            }\n                            if (this.options.textDecoration !== \"none\") {\n                                components.push(this.options.textDecoration);\n                            }\n                            components.push(this.options.textAlign);\n                            if (this.options.stroke !== \"none\") {\n                                components.push(this.options.stroke);\n                            }\n                            if (!(isEmpty(this.options.letterSpacing) && !isNumberLike(this.options.letterSpacing))) {\n                                components.push(\"letter_spacing_\" + this.options.letterSpacing);\n                            }\n                            if (!(isEmpty(this.options.lineSpacing) && !isNumberLike(this.options.lineSpacing))) {\n                                components.push(\"line_spacing_\" + this.options.lineSpacing);\n                            }\n                            if (!isEmpty(this.options.fontAntialiasing)) {\n                                components.push(\"antialias_\" + this.options.fontAntialiasing);\n                            }\n                            if (!isEmpty(this.options.fontHinting)) {\n                                components.push(\"hinting_\" + this.options.fontHinting);\n                            }\n                            if (!isEmpty(compact_root_compact_default()(components))) {\n                                if (isEmpty(this.options.fontFamily)) {\n                                    throw \"Must supply fontFamily. \".concat(components);\n                                }\n                                if (isEmpty(this.options.fontSize) && !isNumberLike(this.options.fontSize)) {\n                                    throw \"Must supply fontSize.\";\n                                }\n                            }\n                            components.unshift(this.options.fontFamily, this.options.fontSize);\n                            components = compact_root_compact_default()(components).join(\"_\");\n                            return components;\n                        }\n                    }\n                ]);\n                return TextLayer;\n            }(layer_layer);\n            ;\n            /* harmony default export */ var textlayer = textlayer_TextLayer;\n            // CONCATENATED MODULE: ./src/layer/subtitleslayer.js\n            function subtitleslayer_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return subtitleslayer_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, subtitleslayer_typeof(obj);\n            }\n            function subtitleslayer_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function subtitleslayer_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) subtitleslayer_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) subtitleslayer_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function subtitleslayer_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function subtitleslayer_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) subtitleslayer_setPrototypeOf(subClass, superClass);\n            }\n            function subtitleslayer_setPrototypeOf(o, p) {\n                subtitleslayer_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return subtitleslayer_setPrototypeOf(o, p);\n            }\n            function subtitleslayer_createSuper(Derived) {\n                var hasNativeReflectConstruct = subtitleslayer_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = subtitleslayer_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = subtitleslayer_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return subtitleslayer_possibleConstructorReturn(this, result);\n                };\n            }\n            function subtitleslayer_possibleConstructorReturn(self, call) {\n                if (call && (subtitleslayer_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return subtitleslayer_assertThisInitialized(self);\n            }\n            function subtitleslayer_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function subtitleslayer_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function subtitleslayer_getPrototypeOf(o) {\n                subtitleslayer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return subtitleslayer_getPrototypeOf(o);\n            }\n            var SubtitlesLayer = /*#__PURE__*/ function(_TextLayer) {\n                subtitleslayer_inherits(SubtitlesLayer, _TextLayer);\n                var _super = subtitleslayer_createSuper(SubtitlesLayer);\n                /**\n   * Represent a subtitles layer\n   * @constructor SubtitlesLayer\n   * @param {Object} options - layer parameters\n   */ function SubtitlesLayer(options) {\n                    var _this;\n                    subtitleslayer_classCallCheck(this, SubtitlesLayer);\n                    _this = _super.call(this, options);\n                    _this.options.resourceType = \"subtitles\";\n                    return _this;\n                }\n                return subtitleslayer_createClass(SubtitlesLayer);\n            }(textlayer);\n            /* harmony default export */ var subtitleslayer = SubtitlesLayer;\n            // CONCATENATED MODULE: ./src/layer/fetchlayer.js\n            function fetchlayer_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return fetchlayer_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, fetchlayer_typeof(obj);\n            }\n            function fetchlayer_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function fetchlayer_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function fetchlayer_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) fetchlayer_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) fetchlayer_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function fetchlayer_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) fetchlayer_setPrototypeOf(subClass, superClass);\n            }\n            function fetchlayer_setPrototypeOf(o, p) {\n                fetchlayer_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return fetchlayer_setPrototypeOf(o, p);\n            }\n            function fetchlayer_createSuper(Derived) {\n                var hasNativeReflectConstruct = fetchlayer_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = fetchlayer_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = fetchlayer_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return fetchlayer_possibleConstructorReturn(this, result);\n                };\n            }\n            function fetchlayer_possibleConstructorReturn(self, call) {\n                if (call && (fetchlayer_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return fetchlayer_assertThisInitialized(self);\n            }\n            function fetchlayer_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function fetchlayer_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function fetchlayer_getPrototypeOf(o) {\n                fetchlayer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return fetchlayer_getPrototypeOf(o);\n            }\n            var fetchlayer_FetchLayer = /*#__PURE__*/ function(_Layer) {\n                fetchlayer_inherits(FetchLayer, _Layer);\n                var _super = fetchlayer_createSuper(FetchLayer);\n                /**\n   * @class FetchLayer\n   * @classdesc Creates an image layer using a remote URL.\n   * @param {Object|string} options - layer parameters or a url\n   * @param {string} options.url the url of the image to fetch\n   */ function FetchLayer(options) {\n                    var _this;\n                    fetchlayer_classCallCheck(this, FetchLayer);\n                    _this = _super.call(this, options);\n                    if (isString_root_isString_default()(options)) {\n                        _this.options.url = options;\n                    } else if (options != null ? options.url : void 0) {\n                        _this.options.url = options.url;\n                    }\n                    return _this;\n                }\n                fetchlayer_createClass(FetchLayer, [\n                    {\n                        key: \"url\",\n                        value: function url(_url) {\n                            this.options.url = _url;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            return \"fetch:\".concat(base64EncodeURL(this.options.url));\n                        }\n                    }\n                ]);\n                return FetchLayer;\n            }(layer_layer);\n            /* harmony default export */ var fetchlayer = fetchlayer_FetchLayer;\n            // CONCATENATED MODULE: ./src/parameters.js\n            function parameters_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return parameters_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, parameters_typeof(obj);\n            }\n            function _get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    _get = Reflect.get.bind();\n                } else {\n                    _get = function _get(target, property, receiver) {\n                        var base = _superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return _get.apply(this, arguments);\n            }\n            function _superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = parameters_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function parameters_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) parameters_setPrototypeOf(subClass, superClass);\n            }\n            function parameters_setPrototypeOf(o, p) {\n                parameters_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return parameters_setPrototypeOf(o, p);\n            }\n            function parameters_createSuper(Derived) {\n                var hasNativeReflectConstruct = parameters_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = parameters_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = parameters_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return parameters_possibleConstructorReturn(this, result);\n                };\n            }\n            function parameters_possibleConstructorReturn(self, call) {\n                if (call && (parameters_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return parameters_assertThisInitialized(self);\n            }\n            function parameters_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function parameters_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function parameters_getPrototypeOf(o) {\n                parameters_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return parameters_getPrototypeOf(o);\n            }\n            function parameters_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function parameters_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function parameters_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) parameters_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) parameters_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            /**\n * Transformation parameters\n * Depends on 'util', 'transformation'\n */ var parameters_Param = /*#__PURE__*/ function() {\n                /**\n   * Represents a single parameter.\n   * @class Param\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} shortName - The name of the serialized form of the parameter.\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @ignore\n   */ function Param(name, shortName) {\n                    var process1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity_root_identity_default.a;\n                    parameters_classCallCheck(this, Param);\n                    /**\n     * The name of the parameter in snake_case\n     * @member {string} Param#name\n     */ this.name = name;\n                    /**\n     * The name of the serialized form of the parameter\n     * @member {string} Param#shortName\n     */ this.shortName = shortName;\n                    /**\n     * Manipulate origValue when value is called\n     * @member {function} Param#process\n     */ this.process = process1;\n                }\n                /**\n   * Set a (unprocessed) value for this parameter\n   * @function Param#set\n   * @param {*} origValue - the value of the parameter\n   * @return {Param} self for chaining\n   */ parameters_createClass(Param, [\n                    {\n                        key: \"set\",\n                        value: function set(origValue) {\n                            this.origValue = origValue;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            var val, valid;\n                            val = this.value();\n                            valid = isArray_root_isArray_default()(val) || isPlainObject_root_isPlainObject_default()(val) || isString_root_isString_default()(val) ? !isEmpty(val) : val != null;\n                            if (this.shortName != null && valid) {\n                                return \"\".concat(this.shortName, \"_\").concat(val);\n                            } else {\n                                return \"\";\n                            }\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value() {\n                            return this.process(this.origValue);\n                        }\n                    }\n                ], [\n                    {\n                        key: \"norm_color\",\n                        value: function norm_color(value) {\n                            return value != null ? value.replace(/^#/, \"rgb:\") : void 0;\n                        }\n                    },\n                    {\n                        key: \"build_array\",\n                        value: function build_array(arg) {\n                            if (arg == null) {\n                                return [];\n                            } else if (isArray_root_isArray_default()(arg)) {\n                                return arg;\n                            } else {\n                                return [\n                                    arg\n                                ];\n                            }\n                        }\n                    },\n                    {\n                        key: \"process_video_params\",\n                        value: function process_video_params(param) {\n                            var video;\n                            switch(param.constructor){\n                                case Object:\n                                    video = \"\";\n                                    if (\"codec\" in param) {\n                                        video = param.codec;\n                                        if (\"profile\" in param) {\n                                            video += \":\" + param.profile;\n                                            if (\"level\" in param) {\n                                                video += \":\" + param.level;\n                                                if (\"b_frames\" in param && param.b_frames === false) {\n                                                    video += \":bframes_no\";\n                                                }\n                                            }\n                                        }\n                                    }\n                                    return video;\n                                case String:\n                                    return param;\n                                default:\n                                    return null;\n                            }\n                        }\n                    }\n                ]);\n                return Param;\n            }();\n            var parameters_ArrayParam = /*#__PURE__*/ function(_Param) {\n                parameters_inherits(ArrayParam, _Param);\n                var _super = parameters_createSuper(ArrayParam);\n                /**\n   * A parameter that represents an array.\n   * @param {string} name - The name of the parameter in snake_case.\n   * @param {string} shortName - The name of the serialized form of the parameter\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {string} [sep='.'] - The separator to use when joining the array elements together\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @class ArrayParam\n   * @extends Param\n   * @ignore\n   */ function ArrayParam(name, shortName) {\n                    var _this;\n                    var sep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \".\";\n                    var process1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n                    parameters_classCallCheck(this, ArrayParam);\n                    _this = _super.call(this, name, shortName, process1);\n                    _this.sep = sep;\n                    return _this;\n                }\n                parameters_createClass(ArrayParam, [\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            if (this.shortName != null) {\n                                var arrayValue = this.value();\n                                if (isEmpty(arrayValue)) {\n                                    return \"\";\n                                } else if (isString_root_isString_default()(arrayValue)) {\n                                    return \"\".concat(this.shortName, \"_\").concat(arrayValue);\n                                } else {\n                                    var flat = arrayValue.map(function(t) {\n                                        return isFunction_root_isFunction_default()(t.serialize) ? t.serialize() : t;\n                                    }).join(this.sep);\n                                    return \"\".concat(this.shortName, \"_\").concat(flat);\n                                }\n                            } else {\n                                return \"\";\n                            }\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value() {\n                            var _this2 = this;\n                            if (isArray_root_isArray_default()(this.origValue)) {\n                                return this.origValue.map(function(v) {\n                                    return _this2.process(v);\n                                });\n                            } else {\n                                return this.process(this.origValue);\n                            }\n                        }\n                    },\n                    {\n                        key: \"set\",\n                        value: function set(origValue) {\n                            if (origValue == null || isArray_root_isArray_default()(origValue)) {\n                                return _get(parameters_getPrototypeOf(ArrayParam.prototype), \"set\", this).call(this, origValue);\n                            } else {\n                                return _get(parameters_getPrototypeOf(ArrayParam.prototype), \"set\", this).call(this, [\n                                    origValue\n                                ]);\n                            }\n                        }\n                    }\n                ]);\n                return ArrayParam;\n            }(parameters_Param);\n            var parameters_TransformationParam = /*#__PURE__*/ function(_Param2) {\n                parameters_inherits(TransformationParam, _Param2);\n                var _super2 = parameters_createSuper(TransformationParam);\n                /**\n   * A parameter that represents a transformation\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} [shortName='t'] - The name of the serialized form of the parameter\n   * @param {string} [sep='.'] - The separator to use when joining the array elements together\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @class TransformationParam\n   * @extends Param\n   * @ignore\n   */ function TransformationParam(name) {\n                    var _this3;\n                    var shortName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"t\";\n                    var sep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \".\";\n                    var process1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n                    parameters_classCallCheck(this, TransformationParam);\n                    _this3 = _super2.call(this, name, shortName, process1);\n                    _this3.sep = sep;\n                    return _this3;\n                }\n                /**\n   * Generate string representations of the transformation.\n   * @returns {*} Returns either the transformation as a string, or an array of string representations.\n   */ parameters_createClass(TransformationParam, [\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            var _this4 = this;\n                            var result = \"\";\n                            var val = this.value();\n                            if (isEmpty(val)) {\n                                return result;\n                            } // val is an array of strings so join them\n                            if (baseutil_allStrings(val)) {\n                                var joined = val.join(this.sep); // creates t1.t2.t3 in case multiple named transformations were configured\n                                if (!isEmpty(joined)) {\n                                    // in case options.transformation was not set with an empty string (val != ['']);\n                                    result = \"\".concat(this.shortName, \"_\").concat(joined);\n                                }\n                            } else {\n                                // Convert val to an array of strings\n                                result = val.map(function(t) {\n                                    if (isString_root_isString_default()(t) && !isEmpty(t)) {\n                                        return \"\".concat(_this4.shortName, \"_\").concat(t);\n                                    }\n                                    if (isFunction_root_isFunction_default()(t.serialize)) {\n                                        return t.serialize();\n                                    }\n                                    if (isPlainObject_root_isPlainObject_default()(t) && !isEmpty(t)) {\n                                        return new src_transformation(t).serialize();\n                                    }\n                                    return undefined;\n                                }).filter(function(t) {\n                                    return t;\n                                });\n                            }\n                            return result;\n                        }\n                    },\n                    {\n                        key: \"set\",\n                        value: function set(origValue1) {\n                            this.origValue = origValue1;\n                            if (isArray_root_isArray_default()(this.origValue)) {\n                                return _get(parameters_getPrototypeOf(TransformationParam.prototype), \"set\", this).call(this, this.origValue);\n                            } else {\n                                return _get(parameters_getPrototypeOf(TransformationParam.prototype), \"set\", this).call(this, [\n                                    this.origValue\n                                ]);\n                            }\n                        }\n                    }\n                ]);\n                return TransformationParam;\n            }(parameters_Param);\n            var number_pattern = \"([0-9]*)\\\\.([0-9]+)|([0-9]+)\";\n            var offset_any_pattern = \"(\" + number_pattern + \")([%pP])?\";\n            var parameters_RangeParam = /*#__PURE__*/ function(_Param3) {\n                parameters_inherits(RangeParam, _Param3);\n                var _super3 = parameters_createSuper(RangeParam);\n                /**\n   * A parameter that represents a range\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} shortName - The name of the serialized form of the parameter\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {function} [process=norm_range_value ] - Manipulate origValue when value is called\n   * @class RangeParam\n   * @extends Param\n   * @ignore\n   */ function RangeParam(name, shortName) {\n                    var process1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : RangeParam.norm_range_value;\n                    parameters_classCallCheck(this, RangeParam);\n                    return _super3.call(this, name, shortName, process1);\n                }\n                parameters_createClass(RangeParam, null, [\n                    {\n                        key: \"norm_range_value\",\n                        value: function norm_range_value(value) {\n                            var offset = String(value).match(new RegExp(\"^\" + offset_any_pattern + \"$\"));\n                            if (offset) {\n                                var modifier = offset[5] != null ? \"p\" : \"\";\n                                value = (offset[1] || offset[4]) + modifier;\n                            }\n                            return expression.normalize(value);\n                        }\n                    }\n                ]);\n                return RangeParam;\n            }(parameters_Param);\n            var parameters_RawParam = /*#__PURE__*/ function(_Param4) {\n                parameters_inherits(RawParam, _Param4);\n                var _super4 = parameters_createSuper(RawParam);\n                function RawParam(name, shortName) {\n                    var process1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity_root_identity_default.a;\n                    parameters_classCallCheck(this, RawParam);\n                    return _super4.call(this, name, shortName, process1);\n                }\n                parameters_createClass(RawParam, [\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            return this.value();\n                        }\n                    }\n                ]);\n                return RawParam;\n            }(parameters_Param);\n            var parameters_LayerParam = /*#__PURE__*/ function(_Param5) {\n                parameters_inherits(LayerParam, _Param5);\n                var _super5 = parameters_createSuper(LayerParam);\n                function LayerParam() {\n                    parameters_classCallCheck(this, LayerParam);\n                    return _super5.apply(this, arguments);\n                }\n                parameters_createClass(LayerParam, [\n                    {\n                        key: \"value\",\n                        value: // @return [string] layer transformation string\n                        // @private\n                        function value() {\n                            if (this.origValue == null) {\n                                return \"\";\n                            }\n                            var result;\n                            if (this.origValue instanceof layer_layer) {\n                                result = this.origValue;\n                            } else if (isPlainObject_root_isPlainObject_default()(this.origValue)) {\n                                var layerOptions = withCamelCaseKeys(this.origValue);\n                                if (layerOptions.resourceType === \"text\" || layerOptions.text != null) {\n                                    result = new textlayer(layerOptions);\n                                } else if (layerOptions.resourceType === \"subtitles\") {\n                                    result = new subtitleslayer(layerOptions);\n                                } else if (layerOptions.resourceType === \"fetch\" || layerOptions.url != null) {\n                                    result = new fetchlayer(layerOptions);\n                                } else {\n                                    result = new layer_layer(layerOptions);\n                                }\n                            } else if (isString_root_isString_default()(this.origValue)) {\n                                if (/^fetch:.+/.test(this.origValue)) {\n                                    result = new fetchlayer(this.origValue.substr(6));\n                                } else {\n                                    result = this.origValue;\n                                }\n                            } else {\n                                result = \"\";\n                            }\n                            return result.toString();\n                        }\n                    }\n                ], [\n                    {\n                        key: \"textStyle\",\n                        value: function textStyle(layer) {\n                            return new textlayer(layer).textStyleIdentifier();\n                        }\n                    }\n                ]);\n                return LayerParam;\n            }(parameters_Param);\n            var parameters_ExpressionParam = /*#__PURE__*/ function(_Param6) {\n                parameters_inherits(ExpressionParam, _Param6);\n                var _super6 = parameters_createSuper(ExpressionParam);\n                function ExpressionParam() {\n                    parameters_classCallCheck(this, ExpressionParam);\n                    return _super6.apply(this, arguments);\n                }\n                parameters_createClass(ExpressionParam, [\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            return expression.normalize(_get(parameters_getPrototypeOf(ExpressionParam.prototype), \"serialize\", this).call(this));\n                        }\n                    }\n                ]);\n                return ExpressionParam;\n            }(parameters_Param);\n            // CONCATENATED MODULE: ./src/transformation.js\n            function transformation_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return transformation_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, transformation_typeof(obj);\n            }\n            function transformation_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) transformation_setPrototypeOf(subClass, superClass);\n            }\n            function transformation_setPrototypeOf(o, p) {\n                transformation_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return transformation_setPrototypeOf(o, p);\n            }\n            function transformation_createSuper(Derived) {\n                var hasNativeReflectConstruct = transformation_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = transformation_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = transformation_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return transformation_possibleConstructorReturn(this, result);\n                };\n            }\n            function transformation_possibleConstructorReturn(self, call) {\n                if (call && (transformation_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return transformation_assertThisInitialized(self);\n            }\n            function transformation_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function transformation_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function transformation_getPrototypeOf(o) {\n                transformation_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return transformation_getPrototypeOf(o);\n            }\n            function transformation_slicedToArray(arr, i) {\n                return transformation_arrayWithHoles(arr) || transformation_iterableToArrayLimit(arr, i) || transformation_unsupportedIterableToArray(arr, i) || transformation_nonIterableRest();\n            }\n            function transformation_nonIterableRest() {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function transformation_unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return transformation_arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return transformation_arrayLikeToArray(o, minLen);\n            }\n            function transformation_arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            function transformation_iterableToArrayLimit(arr, i) {\n                var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n                if (_i == null) return;\n                var _arr = [];\n                var _n = true;\n                var _d = false;\n                var _s, _e;\n                try {\n                    for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n                        _arr.push(_s.value);\n                        if (i && _arr.length === i) break;\n                    }\n                } catch (err) {\n                    _d = true;\n                    _e = err;\n                } finally{\n                    try {\n                        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n                    } finally{\n                        if (_d) throw _e;\n                    }\n                }\n                return _arr;\n            }\n            function transformation_arrayWithHoles(arr) {\n                if (Array.isArray(arr)) return arr;\n            }\n            function transformation_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function transformation_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function transformation_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) transformation_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) transformation_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            /**\n * Assign key, value to target, when value is not null.<br>\n *   This function mutates the target!\n * @param {object} target the object to assign the values to\n * @param {object} sources one or more objects to get values from\n * @returns {object} the target after the assignment\n */ function assignNotNull(target) {\n                for(var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    sources[_key - 1] = arguments[_key];\n                }\n                sources.forEach(function(source) {\n                    Object.keys(source).forEach(function(key) {\n                        if (source[key] != null) {\n                            target[key] = source[key];\n                        }\n                    });\n                });\n                return target;\n            }\n            /**\n * TransformationBase\n * Depends on 'configuration', 'parameters','util'\n * @internal\n */ var transformation_TransformationBase = /*#__PURE__*/ function() {\n                /**\n   * The base class for transformations.\n   * Members of this class are documented as belonging to the {@link Transformation} class for convenience.\n   * @class TransformationBase\n   */ function TransformationBase(options) {\n                    transformation_classCallCheck(this, TransformationBase);\n                    /** @private */ /** @private */ var parent, trans;\n                    parent = void 0;\n                    trans = {};\n                    /**\n     * Return an options object that can be used to create an identical Transformation\n     * @function Transformation#toOptions\n     * @return {Object} Returns a plain object representing this transformation\n     */ this.toOptions = function(withChain) {\n                        var opt = {};\n                        if (withChain == null) {\n                            withChain = true;\n                        }\n                        Object.keys(trans).forEach(function(key) {\n                            return opt[key] = trans[key].origValue;\n                        });\n                        assignNotNull(opt, this.otherOptions);\n                        if (withChain && !isEmpty(this.chained)) {\n                            var list = this.chained.map(function(tr) {\n                                return tr.toOptions();\n                            });\n                            list.push(opt);\n                            opt = {};\n                            assignNotNull(opt, this.otherOptions);\n                            opt.transformation = list;\n                        }\n                        return opt;\n                    };\n                    /**\n     * Set a parent for this object for chaining purposes.\n     *\n     * @function Transformation#setParent\n     * @param {Object} object - the parent to be assigned to\n     * @returns {Transformation} Returns this instance for chaining purposes.\n     */ this.setParent = function(object) {\n                        parent = object;\n                        if (object != null) {\n                            this.fromOptions(typeof object.toOptions === \"function\" ? object.toOptions() : void 0);\n                        }\n                        return this;\n                    };\n                    /**\n     * Returns the parent of this object in the chain\n     * @function Transformation#getParent\n     * @protected\n     * @return {Object} Returns the parent of this object if there is any\n     */ this.getParent = function() {\n                        return parent;\n                    }; // Helper methods to create parameter methods\n                    // These methods are defined here because they access `trans` which is\n                    // a private member of `TransformationBase`\n                    /** @protected */ this.param = function(value, name, abbr, defaultValue, process1) {\n                        if (process1 == null) {\n                            if (isFunction_root_isFunction_default()(defaultValue)) {\n                                process1 = defaultValue;\n                            } else {\n                                process1 = identity_root_identity_default.a;\n                            }\n                        }\n                        trans[name] = new parameters_Param(name, abbr, process1).set(value);\n                        return this;\n                    };\n                    /** @protected */ this.rawParam = function(value, name, abbr, defaultValue, process1) {\n                        process1 = lastArgCallback(arguments);\n                        trans[name] = new parameters_RawParam(name, abbr, process1).set(value);\n                        return this;\n                    };\n                    /** @protected */ this.rangeParam = function(value, name, abbr, defaultValue, process1) {\n                        process1 = lastArgCallback(arguments);\n                        trans[name] = new parameters_RangeParam(name, abbr, process1).set(value);\n                        return this;\n                    };\n                    /** @protected */ this.arrayParam = function(value, name, abbr) {\n                        var sep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \":\";\n                        var defaultValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n                        var process1 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n                        process1 = lastArgCallback(arguments);\n                        trans[name] = new parameters_ArrayParam(name, abbr, sep, process1).set(value);\n                        return this;\n                    };\n                    /** @protected */ this.transformationParam = function(value, name, abbr) {\n                        var sep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \".\";\n                        var defaultValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n                        var process1 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n                        process1 = lastArgCallback(arguments);\n                        trans[name] = new parameters_TransformationParam(name, abbr, sep, process1).set(value);\n                        return this;\n                    };\n                    this.layerParam = function(value, name, abbr) {\n                        trans[name] = new parameters_LayerParam(name, abbr).set(value);\n                        return this;\n                    }; // End Helper methods\n                    /**\n     * Get the value associated with the given name.\n     * @function Transformation#getValue\n     * @param {string} name - the name of the parameter\n     * @return {*} the processed value associated with the given name\n     * @description Use {@link get}.origValue for the value originally provided for the parameter\n     */ this.getValue = function(name) {\n                        var value = trans[name] && trans[name].value();\n                        return value != null ? value : this.otherOptions[name];\n                    };\n                    /**\n     * Get the parameter object for the given parameter name\n     * @function Transformation#get\n     * @param {string} name the name of the transformation parameter\n     * @returns {Param} the param object for the given name, or undefined\n     */ this.get = function(name) {\n                        return trans[name];\n                    };\n                    /**\n     * Remove a transformation option from the transformation.\n     * @function Transformation#remove\n     * @param {string} name - the name of the option to remove\n     * @return {*} Returns the option that was removed or null if no option by that name was found. The type of the\n     *              returned value depends on the value.\n     */ this.remove = function(name) {\n                        var temp;\n                        switch(false){\n                            case trans[name] == null:\n                                temp = trans[name];\n                                delete trans[name];\n                                return temp.origValue;\n                            case this.otherOptions[name] == null:\n                                temp = this.otherOptions[name];\n                                delete this.otherOptions[name];\n                                return temp;\n                            default:\n                                return null;\n                        }\n                    };\n                    /**\n     * Return an array of all the keys (option names) in the transformation.\n     * @return {Array<string>} the keys in snakeCase format\n     */ this.keys = function() {\n                        var key;\n                        return (function() {\n                            var results;\n                            results = [];\n                            for(key in trans){\n                                if (key != null) {\n                                    results.push(key.match(VAR_NAME_RE) ? key : snakeCase(key));\n                                }\n                            }\n                            return results;\n                        })().sort();\n                    };\n                    /**\n     * Returns a plain object representation of the transformation. Values are processed.\n     * @function Transformation#toPlainObject\n     * @return {Object} the transformation options as plain object\n     */ this.toPlainObject = function() {\n                        var hash, key, list;\n                        hash = {};\n                        for(key in trans){\n                            hash[key] = trans[key].value();\n                            if (isPlainObject_root_isPlainObject_default()(hash[key])) {\n                                hash[key] = cloneDeep_root_cloneDeep_default()(hash[key]);\n                            }\n                        }\n                        if (!isEmpty(this.chained)) {\n                            list = this.chained.map(function(tr) {\n                                return tr.toPlainObject();\n                            });\n                            list.push(hash);\n                            hash = {\n                                transformation: list\n                            };\n                        }\n                        return hash;\n                    };\n                    /**\n     * Complete the current transformation and chain to a new one.\n     * In the URL, transformations are chained together by slashes.\n     * @function Transformation#chain\n     * @return {Transformation} Returns this transformation for chaining\n     * @example\n     * var tr = cloudinary.Transformation.new();\n     * tr.width(10).crop('fit').chain().angle(15).serialize()\n     * // produces \"c_fit,w_10/a_15\"\n     */ this.chain = function() {\n                        var names, tr;\n                        names = Object.getOwnPropertyNames(trans);\n                        if (names.length !== 0) {\n                            tr = new this.constructor(this.toOptions(false));\n                            this.resetTransformations();\n                            this.chained.push(tr);\n                        }\n                        return this;\n                    };\n                    this.resetTransformations = function() {\n                        trans = {};\n                        return this;\n                    };\n                    this.otherOptions = {};\n                    this.chained = [];\n                    this.fromOptions(options);\n                }\n                /**\n   * Merge the provided options with own's options\n   * @param {Object} [options={}] key-value list of options\n   * @returns {Transformation} Returns this instance for chaining\n   */ transformation_createClass(TransformationBase, [\n                    {\n                        key: \"fromOptions\",\n                        value: function fromOptions() {\n                            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                            if (options instanceof TransformationBase) {\n                                this.fromTransformation(options);\n                            } else {\n                                if (isString_root_isString_default()(options) || isArray_root_isArray_default()(options)) {\n                                    options = {\n                                        transformation: options\n                                    };\n                                }\n                                options = cloneDeep_root_cloneDeep_default()(options, function(value) {\n                                    if (value instanceof TransformationBase || value instanceof Layer) {\n                                        return new value.clone();\n                                    }\n                                }); // Handling of \"if\" statements precedes other options as it creates a chained transformation\n                                if (options[\"if\"]) {\n                                    this.set(\"if\", options[\"if\"]);\n                                    delete options[\"if\"];\n                                }\n                                for(var key in options){\n                                    var opt = options[key];\n                                    if (opt != null) {\n                                        if (key.match(VAR_NAME_RE)) {\n                                            if (key !== \"$attr\") {\n                                                this.set(\"variable\", key, opt);\n                                            }\n                                        } else {\n                                            this.set(key, opt);\n                                        }\n                                    }\n                                }\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fromTransformation\",\n                        value: function fromTransformation(other) {\n                            var _this = this;\n                            if (other instanceof TransformationBase) {\n                                other.keys().forEach(function(key) {\n                                    return _this.set(key, other.get(key).origValue);\n                                });\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"set\",\n                        value: function set(key) {\n                            var camelKey;\n                            camelKey = camelCase(key);\n                            for(var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                                values[_key2 - 1] = arguments[_key2];\n                            }\n                            if (includes_root_includes_default()(transformation_Transformation.methods, camelKey)) {\n                                this[camelKey].apply(this, values);\n                            } else {\n                                this.otherOptions[key] = values[0];\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"hasLayer\",\n                        value: function hasLayer() {\n                            return this.getValue(\"overlay\") || this.getValue(\"underlay\");\n                        }\n                    },\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            var ifParam, j, len, paramList, ref, ref1, ref2, ref3, ref4, resultArray, t, transformationList, transformationString, transformations, value, variables, vars;\n                            resultArray = this.chained.map(function(tr) {\n                                return tr.serialize();\n                            });\n                            paramList = this.keys();\n                            transformations = (ref = this.get(\"transformation\")) != null ? ref.serialize() : void 0;\n                            ifParam = (ref1 = this.get(\"if\")) != null ? ref1.serialize() : void 0;\n                            variables = processVar((ref2 = this.get(\"variables\")) != null ? ref2.value() : void 0);\n                            paramList = difference_root_difference_default()(paramList, [\n                                \"transformation\",\n                                \"if\",\n                                \"variables\"\n                            ]);\n                            vars = [];\n                            transformationList = [];\n                            for(j = 0, len = paramList.length; j < len; j++){\n                                t = paramList[j];\n                                if (t.match(VAR_NAME_RE)) {\n                                    vars.push(t + \"_\" + expression.normalize((ref3 = this.get(t)) != null ? ref3.value() : void 0));\n                                } else {\n                                    transformationList.push((ref4 = this.get(t)) != null ? ref4.serialize() : void 0);\n                                }\n                            }\n                            switch(false){\n                                case !isString_root_isString_default()(transformations):\n                                    transformationList.push(transformations);\n                                    break;\n                                case !isArray_root_isArray_default()(transformations):\n                                    resultArray = resultArray.concat(transformations);\n                            }\n                            transformationList = function() {\n                                var k, len1, results;\n                                results = [];\n                                for(k = 0, len1 = transformationList.length; k < len1; k++){\n                                    value = transformationList[k];\n                                    if (isArray_root_isArray_default()(value) && !isEmpty(value) || !isArray_root_isArray_default()(value) && value) {\n                                        results.push(value);\n                                    }\n                                }\n                                return results;\n                            }();\n                            transformationList = vars.sort().concat(variables).concat(transformationList.sort());\n                            if (ifParam === \"if_end\") {\n                                transformationList.push(ifParam);\n                            } else if (!isEmpty(ifParam)) {\n                                transformationList.unshift(ifParam);\n                            }\n                            transformationString = compact_root_compact_default()(transformationList).join(this.param_separator);\n                            if (!isEmpty(transformationString)) {\n                                resultArray.push(transformationString);\n                            }\n                            return compact_root_compact_default()(resultArray).join(this.trans_separator);\n                        }\n                    },\n                    {\n                        key: \"toHtmlAttributes\",\n                        value: /**\n     * Returns the attributes for an HTML tag.\n     * @function Cloudinary.toHtmlAttributes\n     * @return PlainObject\n     */ function toHtmlAttributes() {\n                            var _this2 = this;\n                            var attrName, height, options, ref2, ref3, value, width;\n                            options = {};\n                            var snakeCaseKey;\n                            Object.keys(this.otherOptions).forEach(function(key) {\n                                value = _this2.otherOptions[key];\n                                snakeCaseKey = snakeCase(key);\n                                if (!includes_root_includes_default()(transformation_Transformation.PARAM_NAMES, snakeCaseKey) && !includes_root_includes_default()(URL_KEYS, snakeCaseKey)) {\n                                    attrName = /^html_/.test(key) ? key.slice(5) : key;\n                                    options[attrName] = value;\n                                }\n                            }); // convert all \"html_key\" to \"key\" with the same value\n                            this.keys().forEach(function(key) {\n                                if (/^html_/.test(key)) {\n                                    options[camelCase(key.slice(5))] = _this2.getValue(key);\n                                }\n                            });\n                            if (!(this.hasLayer() || this.getValue(\"angle\") || includes_root_includes_default()([\n                                \"fit\",\n                                \"limit\",\n                                \"lfill\"\n                            ], this.getValue(\"crop\")))) {\n                                width = (ref2 = this.get(\"width\")) != null ? ref2.origValue : void 0;\n                                height = (ref3 = this.get(\"height\")) != null ? ref3.origValue : void 0;\n                                if (parseFloat(width) >= 1.0) {\n                                    if (options.width == null) {\n                                        options.width = width;\n                                    }\n                                }\n                                if (parseFloat(height) >= 1.0) {\n                                    if (options.height == null) {\n                                        options.height = height;\n                                    }\n                                }\n                            }\n                            return options;\n                        }\n                    },\n                    {\n                        key: \"toHtml\",\n                        value: /**\n     * Delegate to the parent (up the call chain) to produce HTML\n     * @function Transformation#toHtml\n     * @return {string} HTML representation of the parent if possible.\n     * @example\n     * tag = cloudinary.ImageTag.new(\"sample\", {cloud_name: \"demo\"})\n     * // ImageTag {name: \"img\", publicId: \"sample\"}\n     * tag.toHtml()\n     * // <img src=\"http://res.cloudinary.com/demo/image/upload/sample\">\n     * tag.transformation().crop(\"fit\").width(300).toHtml()\n     * // <img src=\"http://res.cloudinary.com/demo/image/upload/c_fit,w_300/sample\">\n     */ function toHtml() {\n                            var ref;\n                            return (ref = this.getParent()) != null ? typeof ref.toHtml === \"function\" ? ref.toHtml() : void 0 : void 0;\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            return this.serialize();\n                        }\n                    },\n                    {\n                        key: \"clone\",\n                        value: function clone() {\n                            return new this.constructor(this.toOptions(true));\n                        }\n                    }\n                ], [\n                    {\n                        key: \"listNames\",\n                        value: function listNames() {\n                            return transformation_Transformation.methods;\n                        }\n                    },\n                    {\n                        key: \"isValidParamName\",\n                        value: function isValidParamName(name) {\n                            return transformation_Transformation.methods.indexOf(camelCase(name)) >= 0;\n                        }\n                    }\n                ]);\n                return TransformationBase;\n            }();\n            var VAR_NAME_RE = /^\\$[a-zA-Z0-9]+$/;\n            transformation_TransformationBase.prototype.trans_separator = \"/\";\n            transformation_TransformationBase.prototype.param_separator = \",\";\n            function lastArgCallback(args) {\n                var callback;\n                callback = args != null ? args[args.length - 1] : void 0;\n                if (isFunction_root_isFunction_default()(callback)) {\n                    return callback;\n                } else {\n                    return void 0;\n                }\n            }\n            function processVar(varArray) {\n                var j, len, name, results, v;\n                if (isArray_root_isArray_default()(varArray)) {\n                    results = [];\n                    for(j = 0, len = varArray.length; j < len; j++){\n                        var _varArray$j = transformation_slicedToArray(varArray[j], 2);\n                        name = _varArray$j[0];\n                        v = _varArray$j[1];\n                        results.push(\"\".concat(name, \"_\").concat(expression.normalize(v)));\n                    }\n                    return results;\n                } else {\n                    return varArray;\n                }\n            }\n            function processCustomFunction(_ref) {\n                var function_type = _ref.function_type, source = _ref.source;\n                if (function_type === \"remote\") {\n                    return [\n                        function_type,\n                        btoa(source)\n                    ].join(\":\");\n                } else if (function_type === \"wasm\") {\n                    return [\n                        function_type,\n                        source\n                    ].join(\":\");\n                }\n            }\n            /**\n * Transformation Class methods.\n * This is a list of the parameters defined in Transformation.\n * Values are camelCased.\n * @const Transformation.methods\n * @private\n * @ignore\n * @type {Array<string>}\n */ /**\n * Parameters that are filtered out before passing the options to an HTML tag.\n *\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\n * @const {Array<string>} Transformation.PARAM_NAMES\n * @private\n * @ignore\n * @see toHtmlAttributes\n */ var transformation_Transformation = /*#__PURE__*/ function(_TransformationBase) {\n                transformation_inherits(Transformation, _TransformationBase);\n                var _super = transformation_createSuper(Transformation);\n                /**\n   * Represents a single transformation.\n   * @class Transformation\n   * @example\n   * t = new cloudinary.Transformation();\n   * t.angle(20).crop(\"scale\").width(\"auto\");\n   *\n   * // or\n   *\n   * t = new cloudinary.Transformation( {angle: 20, crop: \"scale\", width: \"auto\"});\n   * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\"\n   *  target=\"_blank\">Available image transformations</a>\n   * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\"\n   *  target=\"_blank\">Available video transformations</a>\n   */ function Transformation(options) {\n                    transformation_classCallCheck(this, Transformation);\n                    return _super.call(this, options);\n                }\n                /**\n   * Convenience constructor\n   * @param {Object} options\n   * @return {Transformation}\n   * @example cl = cloudinary.Transformation.new( {angle: 20, crop: \"scale\", width: \"auto\"})\n   */ transformation_createClass(Transformation, [\n                    {\n                        key: \"angle\",\n                        value: /*\n      Transformation Parameters\n    */ function angle(value) {\n                            return this.arrayParam(value, \"angle\", \"a\", \".\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"audioCodec\",\n                        value: function audioCodec(value) {\n                            return this.param(value, \"audio_codec\", \"ac\");\n                        }\n                    },\n                    {\n                        key: \"audioFrequency\",\n                        value: function audioFrequency(value) {\n                            return this.param(value, \"audio_frequency\", \"af\");\n                        }\n                    },\n                    {\n                        key: \"aspectRatio\",\n                        value: function aspectRatio(value) {\n                            return this.param(value, \"aspect_ratio\", \"ar\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"background\",\n                        value: function background(value) {\n                            return this.param(value, \"background\", \"b\", parameters_Param.norm_color);\n                        }\n                    },\n                    {\n                        key: \"bitRate\",\n                        value: function bitRate(value) {\n                            return this.param(value, \"bit_rate\", \"br\");\n                        }\n                    },\n                    {\n                        key: \"border\",\n                        value: function border(value) {\n                            return this.param(value, \"border\", \"bo\", function(border) {\n                                if (isPlainObject_root_isPlainObject_default()(border)) {\n                                    border = assign_root_assign_default()({}, {\n                                        color: \"black\",\n                                        width: 2\n                                    }, border);\n                                    return \"\".concat(border.width, \"px_solid_\").concat(parameters_Param.norm_color(border.color));\n                                } else {\n                                    return border;\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"color\",\n                        value: function color(value) {\n                            return this.param(value, \"color\", \"co\", parameters_Param.norm_color);\n                        }\n                    },\n                    {\n                        key: \"colorSpace\",\n                        value: function colorSpace(value) {\n                            return this.param(value, \"color_space\", \"cs\");\n                        }\n                    },\n                    {\n                        key: \"crop\",\n                        value: function crop(value) {\n                            return this.param(value, \"crop\", \"c\");\n                        }\n                    },\n                    {\n                        key: \"customFunction\",\n                        value: function customFunction(value) {\n                            return this.param(value, \"custom_function\", \"fn\", function() {\n                                return processCustomFunction(value);\n                            });\n                        }\n                    },\n                    {\n                        key: \"customPreFunction\",\n                        value: function customPreFunction(value) {\n                            if (this.get(\"custom_function\")) {\n                                return;\n                            }\n                            return this.rawParam(value, \"custom_function\", \"\", function() {\n                                value = processCustomFunction(value);\n                                return value ? \"fn_pre:\".concat(value) : value;\n                            });\n                        }\n                    },\n                    {\n                        key: \"defaultImage\",\n                        value: function defaultImage(value) {\n                            return this.param(value, \"default_image\", \"d\");\n                        }\n                    },\n                    {\n                        key: \"delay\",\n                        value: function delay(value) {\n                            return this.param(value, \"delay\", \"dl\");\n                        }\n                    },\n                    {\n                        key: \"density\",\n                        value: function density(value) {\n                            return this.param(value, \"density\", \"dn\");\n                        }\n                    },\n                    {\n                        key: \"duration\",\n                        value: function duration(value) {\n                            return this.rangeParam(value, \"duration\", \"du\");\n                        }\n                    },\n                    {\n                        key: \"dpr\",\n                        value: function dpr(value) {\n                            return this.param(value, \"dpr\", \"dpr\", function(dpr) {\n                                dpr = dpr.toString();\n                                if (dpr != null ? dpr.match(/^\\d+$/) : void 0) {\n                                    return dpr + \".0\";\n                                } else {\n                                    return expression.normalize(dpr);\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"effect\",\n                        value: function effect(value) {\n                            return this.arrayParam(value, \"effect\", \"e\", \":\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"else\",\n                        value: function _else() {\n                            return this[\"if\"](\"else\");\n                        }\n                    },\n                    {\n                        key: \"endIf\",\n                        value: function endIf() {\n                            return this[\"if\"](\"end\");\n                        }\n                    },\n                    {\n                        key: \"endOffset\",\n                        value: function endOffset(value) {\n                            return this.rangeParam(value, \"end_offset\", \"eo\");\n                        }\n                    },\n                    {\n                        key: \"fallbackContent\",\n                        value: function fallbackContent(value) {\n                            return this.param(value, \"fallback_content\");\n                        }\n                    },\n                    {\n                        key: \"fetchFormat\",\n                        value: function fetchFormat(value) {\n                            return this.param(value, \"fetch_format\", \"f\");\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(value) {\n                            return this.param(value, \"format\");\n                        }\n                    },\n                    {\n                        key: \"flags\",\n                        value: function flags(value) {\n                            return this.arrayParam(value, \"flags\", \"fl\", \".\");\n                        }\n                    },\n                    {\n                        key: \"gravity\",\n                        value: function gravity(value) {\n                            return this.param(value, \"gravity\", \"g\");\n                        }\n                    },\n                    {\n                        key: \"fps\",\n                        value: function fps(value) {\n                            return this.param(value, \"fps\", \"fps\", function(fps) {\n                                if (isString_root_isString_default()(fps)) {\n                                    return fps;\n                                } else if (isArray_root_isArray_default()(fps)) {\n                                    return fps.join(\"-\");\n                                } else {\n                                    return fps;\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"height\",\n                        value: function height(value) {\n                            var _this3 = this;\n                            return this.param(value, \"height\", \"h\", function() {\n                                if (_this3.getValue(\"crop\") || _this3.getValue(\"overlay\") || _this3.getValue(\"underlay\")) {\n                                    return expression.normalize(value);\n                                } else {\n                                    return null;\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"htmlHeight\",\n                        value: function htmlHeight(value) {\n                            return this.param(value, \"html_height\");\n                        }\n                    },\n                    {\n                        key: \"htmlWidth\",\n                        value: function htmlWidth(value) {\n                            return this.param(value, \"html_width\");\n                        }\n                    },\n                    {\n                        key: \"if\",\n                        value: function _if() {\n                            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n                            var i, ifVal, j, ref, trIf, trRest;\n                            switch(value){\n                                case \"else\":\n                                    this.chain();\n                                    return this.param(value, \"if\", \"if\");\n                                case \"end\":\n                                    this.chain();\n                                    for(i = j = ref = this.chained.length - 1; j >= 0; i = j += -1){\n                                        ifVal = this.chained[i].getValue(\"if\");\n                                        if (ifVal === \"end\") {\n                                            break;\n                                        } else if (ifVal != null) {\n                                            trIf = Transformation[\"new\"]()[\"if\"](ifVal);\n                                            this.chained[i].remove(\"if\");\n                                            trRest = this.chained[i];\n                                            this.chained[i] = Transformation[\"new\"]().transformation([\n                                                trIf,\n                                                trRest\n                                            ]);\n                                            if (ifVal !== \"else\") {\n                                                break;\n                                            }\n                                        }\n                                    }\n                                    return this.param(value, \"if\", \"if\");\n                                case \"\":\n                                    return condition[\"new\"]().setParent(this);\n                                default:\n                                    return this.param(value, \"if\", \"if\", function(value) {\n                                        return condition[\"new\"](value).toString();\n                                    });\n                            }\n                        }\n                    },\n                    {\n                        key: \"keyframeInterval\",\n                        value: function keyframeInterval(value) {\n                            return this.param(value, \"keyframe_interval\", \"ki\");\n                        }\n                    },\n                    {\n                        key: \"ocr\",\n                        value: function ocr(value) {\n                            return this.param(value, \"ocr\", \"ocr\");\n                        }\n                    },\n                    {\n                        key: \"offset\",\n                        value: function offset(value) {\n                            var end_o, start_o;\n                            var _ref2 = isFunction_root_isFunction_default()(value != null ? value.split : void 0) ? value.split(\"..\") : isArray_root_isArray_default()(value) ? value : [\n                                null,\n                                null\n                            ];\n                            var _ref3 = transformation_slicedToArray(_ref2, 2);\n                            start_o = _ref3[0];\n                            end_o = _ref3[1];\n                            if (start_o != null) {\n                                this.startOffset(start_o);\n                            }\n                            if (end_o != null) {\n                                return this.endOffset(end_o);\n                            }\n                        }\n                    },\n                    {\n                        key: \"opacity\",\n                        value: function opacity(value) {\n                            return this.param(value, \"opacity\", \"o\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"overlay\",\n                        value: function overlay(value) {\n                            return this.layerParam(value, \"overlay\", \"l\");\n                        }\n                    },\n                    {\n                        key: \"page\",\n                        value: function page(value) {\n                            return this.param(value, \"page\", \"pg\");\n                        }\n                    },\n                    {\n                        key: \"poster\",\n                        value: function poster(value) {\n                            return this.param(value, \"poster\");\n                        }\n                    },\n                    {\n                        key: \"prefix\",\n                        value: function prefix(value) {\n                            return this.param(value, \"prefix\", \"p\");\n                        }\n                    },\n                    {\n                        key: \"quality\",\n                        value: function quality(value) {\n                            return this.param(value, \"quality\", \"q\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"radius\",\n                        value: function radius(value) {\n                            return this.arrayParam(value, \"radius\", \"r\", \":\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"rawTransformation\",\n                        value: function rawTransformation(value) {\n                            return this.rawParam(value, \"raw_transformation\");\n                        }\n                    },\n                    {\n                        key: \"size\",\n                        value: function size(value) {\n                            var height, width;\n                            if (isFunction_root_isFunction_default()(value != null ? value.split : void 0)) {\n                                var _value$split = value.split(\"x\");\n                                var _value$split2 = transformation_slicedToArray(_value$split, 2);\n                                width = _value$split2[0];\n                                height = _value$split2[1];\n                                this.width(width);\n                                return this.height(height);\n                            }\n                        }\n                    },\n                    {\n                        key: \"sourceTypes\",\n                        value: function sourceTypes(value) {\n                            return this.param(value, \"source_types\");\n                        }\n                    },\n                    {\n                        key: \"sourceTransformation\",\n                        value: function sourceTransformation(value) {\n                            return this.param(value, \"source_transformation\");\n                        }\n                    },\n                    {\n                        key: \"startOffset\",\n                        value: function startOffset(value) {\n                            return this.rangeParam(value, \"start_offset\", \"so\");\n                        }\n                    },\n                    {\n                        key: \"streamingProfile\",\n                        value: function streamingProfile(value) {\n                            return this.param(value, \"streaming_profile\", \"sp\");\n                        }\n                    },\n                    {\n                        key: \"transformation\",\n                        value: function transformation(value) {\n                            return this.transformationParam(value, \"transformation\", \"t\");\n                        }\n                    },\n                    {\n                        key: \"underlay\",\n                        value: function underlay(value) {\n                            return this.layerParam(value, \"underlay\", \"u\");\n                        }\n                    },\n                    {\n                        key: \"variable\",\n                        value: function variable(name, value) {\n                            return this.param(value, name, name);\n                        }\n                    },\n                    {\n                        key: \"variables\",\n                        value: function variables(values) {\n                            return this.arrayParam(values, \"variables\");\n                        }\n                    },\n                    {\n                        key: \"videoCodec\",\n                        value: function videoCodec(value) {\n                            return this.param(value, \"video_codec\", \"vc\", parameters_Param.process_video_params);\n                        }\n                    },\n                    {\n                        key: \"videoSampling\",\n                        value: function videoSampling(value) {\n                            return this.param(value, \"video_sampling\", \"vs\");\n                        }\n                    },\n                    {\n                        key: \"width\",\n                        value: function width(value) {\n                            var _this4 = this;\n                            return this.param(value, \"width\", \"w\", function() {\n                                if (_this4.getValue(\"crop\") || _this4.getValue(\"overlay\") || _this4.getValue(\"underlay\")) {\n                                    return expression.normalize(value);\n                                } else {\n                                    return null;\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"x\",\n                        value: function x(value) {\n                            return this.param(value, \"x\", \"x\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"y\",\n                        value: function y(value) {\n                            return this.param(value, \"y\", \"y\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"zoom\",\n                        value: function zoom(value) {\n                            return this.param(value, \"zoom\", \"z\", expression.normalize);\n                        }\n                    }\n                ], [\n                    {\n                        key: \"new\",\n                        value: function _new(options) {\n                            return new Transformation(options);\n                        }\n                    }\n                ]);\n                return Transformation;\n            }(transformation_TransformationBase);\n            /**\n * Transformation Class methods.\n * This is a list of the parameters defined in Transformation.\n * Values are camelCased.\n */ transformation_Transformation.methods = [\n                \"angle\",\n                \"audioCodec\",\n                \"audioFrequency\",\n                \"aspectRatio\",\n                \"background\",\n                \"bitRate\",\n                \"border\",\n                \"color\",\n                \"colorSpace\",\n                \"crop\",\n                \"customFunction\",\n                \"customPreFunction\",\n                \"defaultImage\",\n                \"delay\",\n                \"density\",\n                \"duration\",\n                \"dpr\",\n                \"effect\",\n                \"else\",\n                \"endIf\",\n                \"endOffset\",\n                \"fallbackContent\",\n                \"fetchFormat\",\n                \"format\",\n                \"flags\",\n                \"gravity\",\n                \"fps\",\n                \"height\",\n                \"htmlHeight\",\n                \"htmlWidth\",\n                \"if\",\n                \"keyframeInterval\",\n                \"ocr\",\n                \"offset\",\n                \"opacity\",\n                \"overlay\",\n                \"page\",\n                \"poster\",\n                \"prefix\",\n                \"quality\",\n                \"radius\",\n                \"rawTransformation\",\n                \"size\",\n                \"sourceTypes\",\n                \"sourceTransformation\",\n                \"startOffset\",\n                \"streamingProfile\",\n                \"transformation\",\n                \"underlay\",\n                \"variable\",\n                \"variables\",\n                \"videoCodec\",\n                \"videoSampling\",\n                \"width\",\n                \"x\",\n                \"y\",\n                \"zoom\"\n            ];\n            /**\n * Parameters that are filtered out before passing the options to an HTML tag.\n *\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\n */ transformation_Transformation.PARAM_NAMES = transformation_Transformation.methods.map(snakeCase).concat(src_configuration.CONFIG_PARAMS);\n            /* harmony default export */ var src_transformation = transformation_Transformation;\n            // CONCATENATED MODULE: ./src/tags/htmltag.js\n            function htmltag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function htmltag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function htmltag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) htmltag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) htmltag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            /**\n * Generic HTML tag\n * Depends on 'transformation', 'util'\n */ /**\n * Represents an HTML (DOM) tag\n * @constructor HtmlTag\n * @param {string} name - the name of the tag\n * @param {string} [publicId]\n * @param {Object} options\n * @example tag = new HtmlTag( 'div', { 'width': 10})\n */ var htmltag_HtmlTag = /*#__PURE__*/ function() {\n                function HtmlTag(name, publicId, options) {\n                    htmltag_classCallCheck(this, HtmlTag);\n                    var transformation;\n                    this.name = name;\n                    this.publicId = publicId;\n                    if (options == null) {\n                        if (isPlainObject_root_isPlainObject_default()(publicId)) {\n                            options = publicId;\n                            this.publicId = void 0;\n                        } else {\n                            options = {};\n                        }\n                    }\n                    transformation = new src_transformation(options);\n                    transformation.setParent(this);\n                    this.transformation = function() {\n                        return transformation;\n                    };\n                }\n                /**\n   * Convenience constructor\n   * Creates a new instance of an HTML (DOM) tag\n   * @function HtmlTag.new\n   * @param {string} name - the name of the tag\n   * @param {string} [publicId]\n   * @param {Object} options\n   * @return {HtmlTag}\n   * @example tag = HtmlTag.new( 'div', { 'width': 10})\n   */ htmltag_createClass(HtmlTag, [\n                    {\n                        key: \"htmlAttrs\",\n                        value: /**\n     * combine key and value from the `attr` to generate an HTML tag attributes string.\n     * `Transformation::toHtmlTagOptions` is used to filter out transformation and configuration keys.\n     * @protected\n     * @param {Object} attrs\n     * @return {string} the attributes in the format `'key1=\"value1\" key2=\"value2\"'`\n     * @ignore\n     */ function htmlAttrs(attrs) {\n                            var key, pairs, value;\n                            return pairs = (function() {\n                                var results;\n                                results = [];\n                                for(key in attrs){\n                                    value = escapeQuotes(attrs[key]);\n                                    if (value) {\n                                        results.push(htmltag_toAttribute(key, value));\n                                    }\n                                }\n                                return results;\n                            })().sort().join(\" \");\n                        }\n                    },\n                    {\n                        key: \"getOptions\",\n                        value: function getOptions() {\n                            return this.transformation().toOptions();\n                        }\n                    },\n                    {\n                        key: \"getOption\",\n                        value: function getOption(name) {\n                            return this.transformation().getValue(name);\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            // The attributes are be computed from the options every time this method is invoked.\n                            var htmlAttributes = this.transformation().toHtmlAttributes();\n                            Object.keys(htmlAttributes).forEach(function(key) {\n                                if (isPlainObject_root_isPlainObject_default()(htmlAttributes[key])) {\n                                    delete htmlAttributes[key];\n                                }\n                            });\n                            if (htmlAttributes.attributes) {\n                                // Currently HTML attributes are defined both at the top level and under 'attributes'\n                                merge_root_merge_default()(htmlAttributes, htmlAttributes.attributes);\n                                delete htmlAttributes.attributes;\n                            }\n                            return htmlAttributes;\n                        }\n                    },\n                    {\n                        key: \"setAttr\",\n                        value: function setAttr(name, value) {\n                            this.transformation().set(\"html_\".concat(name), value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"getAttr\",\n                        value: function getAttr(name) {\n                            return this.attributes()[\"html_\".concat(name)] || this.attributes()[name];\n                        }\n                    },\n                    {\n                        key: \"removeAttr\",\n                        value: function removeAttr(name) {\n                            var ref;\n                            return (ref = this.transformation().remove(\"html_\".concat(name))) != null ? ref : this.transformation().remove(name);\n                        }\n                    },\n                    {\n                        key: \"content\",\n                        value: function content() {\n                            return \"\";\n                        }\n                    },\n                    {\n                        key: \"openTag\",\n                        value: function openTag() {\n                            var tag = \"<\" + this.name;\n                            var htmlAttrs = this.htmlAttrs(this.attributes());\n                            if (htmlAttrs && htmlAttrs.length > 0) {\n                                tag += \" \" + htmlAttrs;\n                            }\n                            return tag + \">\";\n                        }\n                    },\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"</\".concat(this.name, \">\");\n                        }\n                    },\n                    {\n                        key: \"toHtml\",\n                        value: function toHtml() {\n                            return this.openTag() + this.content() + this.closeTag();\n                        }\n                    },\n                    {\n                        key: \"toDOM\",\n                        value: function toDOM() {\n                            var element, name, ref, value;\n                            if (!isFunction_root_isFunction_default()(typeof document !== \"undefined\" && document !== null ? document.createElement : void 0)) {\n                                throw \"Can't create DOM if document is not present!\";\n                            }\n                            element = document.createElement(this.name);\n                            ref = this.attributes();\n                            for(name in ref){\n                                value = ref[name];\n                                element.setAttribute(name, value);\n                            }\n                            return element;\n                        }\n                    }\n                ], [\n                    {\n                        key: \"new\",\n                        value: function _new(name, publicId, options) {\n                            return new this(name, publicId, options);\n                        }\n                    },\n                    {\n                        key: \"isResponsive\",\n                        value: function isResponsive(tag, responsiveClass) {\n                            var dataSrc;\n                            dataSrc = lodash_getData(tag, \"src-cache\") || lodash_getData(tag, \"src\");\n                            return lodash_hasClass(tag, responsiveClass) && /\\bw_auto\\b/.exec(dataSrc);\n                        }\n                    }\n                ]);\n                return HtmlTag;\n            }();\n            ;\n            /**\n * Represent the given key and value as an HTML attribute.\n * @function toAttribute\n * @protected\n * @param {string} key - attribute name\n * @param {*|boolean} value - the value of the attribute. If the value is boolean `true`, return the key only.\n * @returns {string} the attribute\n *\n */ function htmltag_toAttribute(key, value) {\n                if (!value) {\n                    return void 0;\n                } else if (value === true) {\n                    return key;\n                } else {\n                    return \"\".concat(key, '=\"').concat(value, '\"');\n                }\n            }\n            /**\n * If given value is a string, replaces quotes with character entities (&#34;, &#39;)\n * @param value - value to change\n * @returns {*} changed value\n */ function escapeQuotes(value) {\n                return isString_root_isString_default()(value) ? value.replace('\"', \"&#34;\").replace(\"'\", \"&#39;\") : value;\n            }\n            /* harmony default export */ var htmltag = htmltag_HtmlTag;\n            // CONCATENATED MODULE: ./src/url.js\n            var _excluded = [\n                \"placeholder\",\n                \"accessibility\"\n            ];\n            function _objectWithoutProperties(source, excluded) {\n                if (source == null) return {};\n                var target = _objectWithoutPropertiesLoose(source, excluded);\n                var key, i;\n                if (Object.getOwnPropertySymbols) {\n                    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n                    for(i = 0; i < sourceSymbolKeys.length; i++){\n                        key = sourceSymbolKeys[i];\n                        if (excluded.indexOf(key) >= 0) continue;\n                        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n                        target[key] = source[key];\n                    }\n                }\n                return target;\n            }\n            function _objectWithoutPropertiesLoose(source, excluded) {\n                if (source == null) return {};\n                var target = {};\n                var sourceKeys = Object.keys(source);\n                var key, i;\n                for(i = 0; i < sourceKeys.length; i++){\n                    key = sourceKeys[i];\n                    if (excluded.indexOf(key) >= 0) continue;\n                    target[key] = source[key];\n                }\n                return target;\n            }\n            /**\n * Adds protocol, host, pathname prefixes to given string\n * @param str\n * @returns {string}\n */ function makeUrl(str) {\n                var prefix = document.location.protocol + \"//\" + document.location.host;\n                if (str[0] === \"?\") {\n                    prefix += document.location.pathname;\n                } else if (str[0] !== \"/\") {\n                    prefix += document.location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n                }\n                return prefix + str;\n            }\n            /**\n * Check is given string is a url\n * @param str\n * @returns {boolean}\n */ function isUrl(str) {\n                return str ? !!str.match(/^https?:\\//) : false;\n            } // Produce a number between 1 and 5 to be used for cdn sub domains designation\n            function cdnSubdomainNumber(publicId) {\n                return src_crc32(publicId) % 5 + 1;\n            }\n            /**\n * Removes signature from options and returns the signature\n * Makes sure signature is empty or of this format: s--signature--\n * @param {object} options\n * @returns {string} the formatted signature\n */ function handleSignature(options) {\n                var signature = options.signature;\n                var isFormatted = !signature || signature.indexOf(\"s--\") === 0 && signature.substr(-2) === \"--\";\n                delete options.signature;\n                return isFormatted ? signature : \"s--\".concat(signature, \"--\");\n            }\n            /**\n * Create the URL prefix for Cloudinary resources.\n * @param {string} publicId the resource public ID\n * @param {object} options additional options\n * @param {string} options.cloud_name - the cloud name.\n * @param {boolean} [options.cdn_subdomain=false] - Whether to automatically build URLs with\n *  multiple CDN sub-domains.\n * @param {string} [options.private_cdn] - Boolean (default: false). Should be set to true for Advanced plan's users\n *  that have a private CDN distribution.\n * @param {string} [options.protocol=\"http://\"] - the URI protocol to use. If options.secure is true,\n *  the value is overridden to \"https://\"\n * @param {string} [options.secure_distribution] - The domain name of the CDN distribution to use for building HTTPS URLs.\n *  Relevant only for Advanced plan's users that have a private CDN distribution.\n * @param {string} [options.cname] - Custom domain name to use for building HTTP URLs.\n *  Relevant only for Advanced plan's users that have a private CDN distribution and a custom CNAME.\n * @param {boolean} [options.secure_cdn_subdomain=true] - When options.secure is true and this parameter is false,\n *  the subdomain is set to \"res\".\n * @param {boolean} [options.secure=false] - Force HTTPS URLs of images even if embedded in non-secure HTTP pages.\n *  When this value is true, options.secure_distribution will be used as host if provided, and options.protocol is set\n *  to \"https://\".\n * @returns {string} the URL prefix for the resource.\n * @private\n */ function handlePrefix(publicId, options) {\n                if (options.cloud_name && options.cloud_name[0] === \"/\") {\n                    return \"/res\" + options.cloud_name;\n                } // defaults\n                var protocol = \"http://\";\n                var cdnPart = \"\";\n                var subdomain = \"res\";\n                var host = \".cloudinary.com\";\n                var path = \"/\" + options.cloud_name; // modifications\n                if (options.protocol) {\n                    protocol = options.protocol + \"//\";\n                }\n                if (options.private_cdn) {\n                    cdnPart = options.cloud_name + \"-\";\n                    path = \"\";\n                }\n                if (options.cdn_subdomain) {\n                    subdomain = \"res-\" + cdnSubdomainNumber(publicId);\n                }\n                if (options.secure) {\n                    protocol = \"https://\";\n                    if (options.secure_cdn_subdomain === false) {\n                        subdomain = \"res\";\n                    }\n                    if (options.secure_distribution != null && options.secure_distribution !== OLD_AKAMAI_SHARED_CDN && options.secure_distribution !== SHARED_CDN) {\n                        cdnPart = \"\";\n                        subdomain = \"\";\n                        host = options.secure_distribution;\n                    }\n                } else if (options.cname) {\n                    protocol = \"http://\";\n                    cdnPart = \"\";\n                    subdomain = options.cdn_subdomain ? \"a\" + (src_crc32(publicId) % 5 + 1) + \".\" : \"\";\n                    host = options.cname;\n                }\n                return [\n                    protocol,\n                    cdnPart,\n                    subdomain,\n                    host,\n                    path\n                ].join(\"\");\n            }\n            /**\n * Return the resource type and action type based on the given configuration\n * @function Cloudinary#handleResourceType\n * @param {Object|string} resource_type\n * @param {string} [type='upload']\n * @param {string} [url_suffix]\n * @param {boolean} [use_root_path]\n * @param {boolean} [shorten]\n * @returns {string} resource_type/type\n * @ignore\n */ function handleResourceType(_ref) {\n                var _ref$resource_type = _ref.resource_type, resource_type = _ref$resource_type === void 0 ? \"image\" : _ref$resource_type, _ref$type = _ref.type, type = _ref$type === void 0 ? \"upload\" : _ref$type, url_suffix = _ref.url_suffix, use_root_path = _ref.use_root_path, shorten = _ref.shorten;\n                var options, resourceType = resource_type;\n                if (isPlainObject_root_isPlainObject_default()(resourceType)) {\n                    options = resourceType;\n                    resourceType = options.resource_type;\n                    type = options.type;\n                    shorten = options.shorten;\n                }\n                if (type == null) {\n                    type = \"upload\";\n                }\n                if (url_suffix != null) {\n                    resourceType = SEO_TYPES[\"\".concat(resourceType, \"/\").concat(type)];\n                    type = null;\n                    if (resourceType == null) {\n                        throw new Error(\"URL Suffix only supported for \".concat(Object.keys(SEO_TYPES).join(\", \")));\n                    }\n                }\n                if (use_root_path) {\n                    if (resourceType === \"image\" && type === \"upload\" || resourceType === \"images\") {\n                        resourceType = null;\n                        type = null;\n                    } else {\n                        throw new Error(\"Root path only supported for image/upload\");\n                    }\n                }\n                if (shorten && resourceType === \"image\" && type === \"upload\") {\n                    resourceType = \"iu\";\n                    type = null;\n                }\n                return [\n                    resourceType,\n                    type\n                ].join(\"/\");\n            }\n            /**\n * Encode publicId\n * @param publicId\n * @returns {string} encoded publicId\n */ function encodePublicId(publicId) {\n                return encodeURIComponent(publicId).replace(/%3A/g, \":\").replace(/%2F/g, \"/\");\n            }\n            /**\n * Encode and format publicId\n * @param publicId\n * @param options\n * @returns {string} publicId\n */ function formatPublicId(publicId, options) {\n                if (isUrl(publicId)) {\n                    publicId = encodePublicId(publicId);\n                } else {\n                    try {\n                        // Make sure publicId is URI encoded.\n                        publicId = decodeURIComponent(publicId);\n                    } catch (error) {}\n                    publicId = encodePublicId(publicId);\n                    if (options.url_suffix) {\n                        publicId = publicId + \"/\" + options.url_suffix;\n                    }\n                    if (options.format) {\n                        if (!options.trust_public_id) {\n                            publicId = publicId.replace(/\\.(jpg|png|gif|webp)$/, \"\");\n                        }\n                        publicId = publicId + \".\" + options.format;\n                    }\n                }\n                return publicId;\n            }\n            /**\n * Get any error with url options\n * @param options\n * @returns {string} if error, otherwise return undefined\n */ function validate(options) {\n                var cloud_name = options.cloud_name, url_suffix = options.url_suffix;\n                if (!cloud_name) {\n                    return \"Unknown cloud_name\";\n                }\n                if (url_suffix && url_suffix.match(/[\\.\\/]/)) {\n                    return \"url_suffix should not include . or /\";\n                }\n            }\n            /**\n * Get version part of the url\n * @param publicId\n * @param options\n * @returns {string}\n */ function handleVersion(publicId, options) {\n                // force_version param means to make sure there is a version in the url (Default is true)\n                var isForceVersion = options.force_version || typeof options.force_version === \"undefined\"; // Is version included in publicId or in options, or publicId is a url (doesn't need version)\n                var isVersionExist = publicId.indexOf(\"/\") < 0 || publicId.match(/^v[0-9]+/) || isUrl(publicId) || options.version;\n                if (isForceVersion && !isVersionExist) {\n                    options.version = 1;\n                }\n                return options.version ? \"v\".concat(options.version) : \"\";\n            }\n            /**\n * Get final transformation component for url string\n * @param options\n * @returns {string}\n */ function handleTransformation(options) {\n                var _ref2 = options || {}, placeholder = _ref2.placeholder, accessibility = _ref2.accessibility, otherOptions = _objectWithoutProperties(_ref2, _excluded);\n                var result = new src_transformation(otherOptions); // Append accessibility transformations\n                if (accessibility && ACCESSIBILITY_MODES[accessibility]) {\n                    result.chain().effect(ACCESSIBILITY_MODES[accessibility]);\n                } // Append placeholder transformations\n                if (placeholder) {\n                    if (placeholder === \"predominant-color\" && result.getValue(\"width\") && result.getValue(\"height\")) {\n                        placeholder += \"-pixel\";\n                    }\n                    var placeholderTransformations = PLACEHOLDER_IMAGE_MODES[placeholder] || PLACEHOLDER_IMAGE_MODES.blur;\n                    placeholderTransformations.forEach(function(t) {\n                        return result.chain().transformation(t);\n                    });\n                }\n                return result.serialize();\n            }\n            /**\n * If type is 'fetch', update publicId to be a url\n * @param publicId\n * @param type\n * @returns {string}\n */ function preparePublicId(publicId, _ref3) {\n                var type = _ref3.type;\n                return !isUrl(publicId) && type === \"fetch\" ? makeUrl(publicId) : publicId;\n            }\n            /**\n * Generate url string\n * @param publicId\n * @param options\n * @returns {string} final url\n */ function urlString(publicId, options) {\n                if (isUrl(publicId) && (options.type === \"upload\" || options.type === \"asset\")) {\n                    return publicId;\n                }\n                var version = handleVersion(publicId, options);\n                var transformationString = handleTransformation(options);\n                var prefix = handlePrefix(publicId, options);\n                var signature = handleSignature(options);\n                var resourceType = handleResourceType(options);\n                publicId = formatPublicId(publicId, options);\n                return compact_root_compact_default()([\n                    prefix,\n                    resourceType,\n                    signature,\n                    transformationString,\n                    version,\n                    publicId\n                ]).join(\"/\").replace(/([^:])\\/+/g, \"$1/\") // replace '///' with '//'\n                .replace(\" \", \"%20\");\n            }\n            /**\n * Merge options and config with defaults\n * update options fetch_format according to 'type' param\n * @param options\n * @param config\n * @returns {*} updated options\n */ function prepareOptions(options, config) {\n                if (options instanceof src_transformation) {\n                    options = options.toOptions();\n                }\n                options = defaults({}, options, config, DEFAULT_IMAGE_PARAMS);\n                if (options.type === \"fetch\") {\n                    options.fetch_format = options.fetch_format || options.format;\n                }\n                return options;\n            }\n            /**\n * Generates a URL for any asset in your Media library.\n * @function url\n * @ignore\n * @param {string} publicId - The public ID of the media asset.\n * @param {Object} [options={}] - The {@link Transformation} parameters to include in the URL.\n * @param {object} [config={}] - URL configuration parameters\n * @param {type} [options.type='upload'] - The asset's storage type.\n *  For details on all fetch types, see\n * <a href=\"https://cloudinary.com/documentation/image_transformations#fetching_images_from_remote_locations\"\n *  target=\"_blank\">Fetch types</a>.\n * @param {Object} [options.resource_type='image'] - The type of asset. <p>Possible values:<br/>\n *  - `image`<br/>\n *  - `video`<br/>\n *  - `raw`\n * @param {signature} [options.signature='s--12345678--'] - The signature component of a\n *  signed delivery URL of the format: /s--SIGNATURE--/.\n *  For details on signatures, see\n * <a href=\"https://cloudinary.com/documentation/signatures\" target=\"_blank\">Signatures</a>.\n * @return {string} The media asset URL.\n * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\" target=\"_blank\">\n *  Available image transformations</a>\n * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\" target=\"_blank\">\n *  Available video transformations</a>\n */ function url_url(publicId) {\n                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                if (!publicId) {\n                    return publicId;\n                }\n                options = prepareOptions(options, config);\n                publicId = preparePublicId(publicId, options);\n                var error = validate(options);\n                if (error) {\n                    throw error;\n                }\n                var resultUrl = urlString(publicId, options);\n                if (options.urlAnalytics) {\n                    var analyticsOptions = getAnalyticsOptions(options);\n                    var sdkAnalyticsSignature = getSDKAnalyticsSignature(analyticsOptions); // url might already have a '?' query param\n                    var appender = \"?\";\n                    if (resultUrl.indexOf(\"?\") >= 0) {\n                        appender = \"&\";\n                    }\n                    resultUrl = \"\".concat(resultUrl).concat(appender, \"_a=\").concat(sdkAnalyticsSignature);\n                }\n                if (options.auth_token) {\n                    var _appender = resultUrl.indexOf(\"?\") >= 0 ? \"&\" : \"?\";\n                    resultUrl = \"\".concat(resultUrl).concat(_appender, \"__cld_token__=\").concat(options.auth_token);\n                }\n                return resultUrl;\n            }\n            ;\n            // CONCATENATED MODULE: ./src/util/generateBreakpoints.js\n            function generateBreakpoints_slicedToArray(arr, i) {\n                return generateBreakpoints_arrayWithHoles(arr) || generateBreakpoints_iterableToArrayLimit(arr, i) || generateBreakpoints_unsupportedIterableToArray(arr, i) || generateBreakpoints_nonIterableRest();\n            }\n            function generateBreakpoints_nonIterableRest() {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function generateBreakpoints_unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return generateBreakpoints_arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return generateBreakpoints_arrayLikeToArray(o, minLen);\n            }\n            function generateBreakpoints_arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            function generateBreakpoints_iterableToArrayLimit(arr, i) {\n                var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n                if (_i == null) return;\n                var _arr = [];\n                var _n = true;\n                var _d = false;\n                var _s, _e;\n                try {\n                    for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n                        _arr.push(_s.value);\n                        if (i && _arr.length === i) break;\n                    }\n                } catch (err) {\n                    _d = true;\n                    _e = err;\n                } finally{\n                    try {\n                        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n                    } finally{\n                        if (_d) throw _e;\n                    }\n                }\n                return _arr;\n            }\n            function generateBreakpoints_arrayWithHoles(arr) {\n                if (Array.isArray(arr)) return arr;\n            }\n            /**\n * Helper function. Gets or populates srcset breakpoints using provided parameters\n * Either the breakpoints or min_width, max_width, max_images must be provided.\n *\n * @private\n * @param {srcset} srcset Options with either `breakpoints` or `min_width`, `max_width`, and `max_images`\n *\n * @return {number[]} Array of breakpoints\n *\n */ function generateBreakpoints(srcset) {\n                var breakpoints = srcset.breakpoints || [];\n                if (breakpoints.length) {\n                    return breakpoints;\n                }\n                var _map = [\n                    srcset.min_width,\n                    srcset.max_width,\n                    srcset.max_images\n                ].map(Number), _map2 = generateBreakpoints_slicedToArray(_map, 3), min_width = _map2[0], max_width = _map2[1], max_images = _map2[2];\n                if ([\n                    min_width,\n                    max_width,\n                    max_images\n                ].some(isNaN)) {\n                    throw \"Either (min_width, max_width, max_images) \" + \"or breakpoints must be provided to the image srcset attribute\";\n                }\n                if (min_width > max_width) {\n                    throw \"min_width must be less than max_width\";\n                }\n                if (max_images <= 0) {\n                    throw \"max_images must be a positive integer\";\n                } else if (max_images === 1) {\n                    min_width = max_width;\n                }\n                var stepSize = Math.ceil((max_width - min_width) / Math.max(max_images - 1, 1));\n                for(var current = min_width; current < max_width; current += stepSize){\n                    breakpoints.push(current);\n                }\n                breakpoints.push(max_width);\n                return breakpoints;\n            }\n            // CONCATENATED MODULE: ./src/util/srcsetUtils.js\n            var srcsetUtils_isEmpty = isEmpty;\n            /**\n * Options used to generate the srcset attribute.\n * @typedef {object} srcset\n * @property {(number[]|string[])}   [breakpoints] An array of breakpoints.\n * @property {number}                [min_width]   Minimal width of the srcset images.\n * @property {number}                [max_width]   Maximal width of the srcset images.\n * @property {number}                [max_images]  Number of srcset images to generate.\n * @property {object|string}         [transformation] The transformation to use in the srcset urls.\n * @property {boolean}               [sizes] Whether to calculate and add the sizes attribute.\n */ /**\n * Helper function. Generates a single srcset item url\n *\n * @private\n * @param {string} public_id  Public ID of the resource.\n * @param {number} width      Width in pixels of the srcset item.\n * @param {object|string} transformation\n * @param {object} options    Additional options.\n *\n * @return {string} Resulting URL of the item\n */ function scaledUrl(public_id, width, transformation) {\n                var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n                var configParams = extractUrlParams(options);\n                transformation = transformation || options;\n                configParams.raw_transformation = new src_transformation([\n                    merge_root_merge_default.a({}, transformation),\n                    {\n                        crop: \"scale\",\n                        width: width\n                    }\n                ]).toString();\n                return url_url(public_id, configParams);\n            }\n            /**\n * If cache is enabled, get the breakpoints from the cache. If the values were not found in the cache,\n * or cache is not enabled, generate the values.\n * @param {srcset} srcset The srcset configuration parameters\n * @param {string} public_id\n * @param {object} options\n * @return {*|Array}\n */ function getOrGenerateBreakpoints(public_id) {\n                var srcset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                return generateBreakpoints(srcset);\n            }\n            /**\n * Helper function. Generates srcset attribute value of the HTML img tag\n * @private\n *\n * @param {string} public_id  Public ID of the resource\n * @param {number[]} breakpoints An array of breakpoints (in pixels)\n * @param {object} transformation The transformation\n * @param {object} options Includes html tag options, transformation options\n * @return {string} Resulting srcset attribute value\n */ function generateSrcsetAttribute(public_id, breakpoints, transformation, options) {\n                options = cloneDeep_root_cloneDeep_default.a(options);\n                patchFetchFormat(options);\n                return breakpoints.map(function(width) {\n                    return \"\".concat(scaledUrl(public_id, width, transformation, options), \" \").concat(width, \"w\");\n                }).join(\", \");\n            }\n            /**\n * Helper function. Generates sizes attribute value of the HTML img tag\n * @private\n * @param {number[]} breakpoints An array of breakpoints.\n * @return {string} Resulting sizes attribute value\n */ function generateSizesAttribute(breakpoints) {\n                if (breakpoints == null) {\n                    return \"\";\n                }\n                return breakpoints.map(function(width) {\n                    return \"(max-width: \".concat(width, \"px) \").concat(width, \"px\");\n                }).join(\", \");\n            }\n            /**\n * Helper function. Generates srcset and sizes attributes of the image tag\n *\n * Generated attributes are added to attributes argument\n *\n * @private\n * @param {string}    publicId  The public ID of the resource\n * @param {object}    attributes Existing HTML attributes.\n * @param {srcset}    srcsetData\n * @param {object}    options    Additional options.\n *\n * @return array The responsive attributes\n */ function generateImageResponsiveAttributes(publicId) {\n                var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                var srcsetData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n                // Create both srcset and sizes here to avoid fetching breakpoints twice\n                var responsiveAttributes = {};\n                if (srcsetUtils_isEmpty(srcsetData)) {\n                    return responsiveAttributes;\n                }\n                var generateSizes = !attributes.sizes && srcsetData.sizes === true;\n                var generateSrcset = !attributes.srcset;\n                if (generateSrcset || generateSizes) {\n                    var breakpoints = getOrGenerateBreakpoints(publicId, srcsetData, options);\n                    if (generateSrcset) {\n                        var transformation = srcsetData.transformation;\n                        var srcsetAttr = generateSrcsetAttribute(publicId, breakpoints, transformation, options);\n                        if (!srcsetUtils_isEmpty(srcsetAttr)) {\n                            responsiveAttributes.srcset = srcsetAttr;\n                        }\n                    }\n                    if (generateSizes) {\n                        var sizesAttr = generateSizesAttribute(breakpoints);\n                        if (!srcsetUtils_isEmpty(sizesAttr)) {\n                            responsiveAttributes.sizes = sizesAttr;\n                        }\n                    }\n                }\n                return responsiveAttributes;\n            }\n            /**\n * Generate a media query\n *\n * @private\n * @param {object} options configuration options\n * @param {number|string} options.min_width\n * @param {number|string} options.max_width\n * @return {string} a media query string\n */ function generateMediaAttr(options) {\n                var mediaQuery = [];\n                if (options != null) {\n                    if (options.min_width != null) {\n                        mediaQuery.push(\"(min-width: \".concat(options.min_width, \"px)\"));\n                    }\n                    if (options.max_width != null) {\n                        mediaQuery.push(\"(max-width: \".concat(options.max_width, \"px)\"));\n                    }\n                }\n                return mediaQuery.join(\" and \");\n            }\n            var srcsetUrl = scaledUrl;\n            // CONCATENATED MODULE: ./src/tags/imagetag.js\n            function imagetag_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return imagetag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, imagetag_typeof(obj);\n            }\n            function imagetag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function imagetag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function imagetag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) imagetag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) imagetag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function imagetag_get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    imagetag_get = Reflect.get.bind();\n                } else {\n                    imagetag_get = function _get(target, property, receiver) {\n                        var base = imagetag_superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return imagetag_get.apply(this, arguments);\n            }\n            function imagetag_superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = imagetag_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function imagetag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) imagetag_setPrototypeOf(subClass, superClass);\n            }\n            function imagetag_setPrototypeOf(o, p) {\n                imagetag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return imagetag_setPrototypeOf(o, p);\n            }\n            function imagetag_createSuper(Derived) {\n                var hasNativeReflectConstruct = imagetag_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = imagetag_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = imagetag_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return imagetag_possibleConstructorReturn(this, result);\n                };\n            }\n            function imagetag_possibleConstructorReturn(self, call) {\n                if (call && (imagetag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return imagetag_assertThisInitialized(self);\n            }\n            function imagetag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function imagetag_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function imagetag_getPrototypeOf(o) {\n                imagetag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return imagetag_getPrototypeOf(o);\n            }\n            /**\n * Image Tag\n * Depends on 'tags/htmltag', 'cloudinary'\n */ /**\n * Creates an HTML (DOM) Image tag using Cloudinary as the source.\n * @constructor ImageTag\n * @extends HtmlTag\n * @param {string} [publicId]\n * @param {Object} [options]\n */ var imagetag_ImageTag = /*#__PURE__*/ function(_HtmlTag) {\n                imagetag_inherits(ImageTag, _HtmlTag);\n                var _super = imagetag_createSuper(ImageTag);\n                function ImageTag(publicId) {\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    imagetag_classCallCheck(this, ImageTag);\n                    return _super.call(this, \"img\", publicId, options);\n                }\n                /** @override */ imagetag_createClass(ImageTag, [\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"\";\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            var attr, options, srcAttribute;\n                            attr = imagetag_get(imagetag_getPrototypeOf(ImageTag.prototype), \"attributes\", this).call(this) || {};\n                            options = this.getOptions();\n                            var attributes = this.getOption(\"attributes\") || {};\n                            var srcsetParam = this.getOption(\"srcset\") || attributes.srcset;\n                            var responsiveAttributes = {};\n                            if (isString_root_isString_default()(srcsetParam)) {\n                                responsiveAttributes.srcset = srcsetParam;\n                            } else {\n                                responsiveAttributes = generateImageResponsiveAttributes(this.publicId, attributes, srcsetParam, options);\n                            }\n                            if (!isEmpty(responsiveAttributes)) {\n                                delete attr.width;\n                                delete attr.height;\n                            }\n                            merge_root_merge_default()(attr, responsiveAttributes);\n                            srcAttribute = options.responsive && !options.client_hints ? \"data-src\" : \"src\";\n                            if (attr[srcAttribute] == null) {\n                                attr[srcAttribute] = url_url(this.publicId, this.getOptions());\n                            }\n                            return attr;\n                        }\n                    }\n                ]);\n                return ImageTag;\n            }(htmltag);\n            ;\n            /* harmony default export */ var imagetag = imagetag_ImageTag;\n            // CONCATENATED MODULE: ./src/tags/sourcetag.js\n            function sourcetag_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return sourcetag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, sourcetag_typeof(obj);\n            }\n            function sourcetag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function sourcetag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function sourcetag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) sourcetag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) sourcetag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function sourcetag_get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    sourcetag_get = Reflect.get.bind();\n                } else {\n                    sourcetag_get = function _get(target, property, receiver) {\n                        var base = sourcetag_superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return sourcetag_get.apply(this, arguments);\n            }\n            function sourcetag_superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = sourcetag_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function sourcetag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) sourcetag_setPrototypeOf(subClass, superClass);\n            }\n            function sourcetag_setPrototypeOf(o, p) {\n                sourcetag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return sourcetag_setPrototypeOf(o, p);\n            }\n            function sourcetag_createSuper(Derived) {\n                var hasNativeReflectConstruct = sourcetag_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = sourcetag_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = sourcetag_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return sourcetag_possibleConstructorReturn(this, result);\n                };\n            }\n            function sourcetag_possibleConstructorReturn(self, call) {\n                if (call && (sourcetag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return sourcetag_assertThisInitialized(self);\n            }\n            function sourcetag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function sourcetag_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function sourcetag_getPrototypeOf(o) {\n                sourcetag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return sourcetag_getPrototypeOf(o);\n            }\n            /**\n * Image Tag\n * Depends on 'tags/htmltag', 'cloudinary'\n */ /**\n * Creates an HTML (DOM) Image tag using Cloudinary as the source.\n * @constructor SourceTag\n * @extends HtmlTag\n * @param {string} [publicId]\n * @param {Object} [options]\n */ var sourcetag_SourceTag = /*#__PURE__*/ function(_HtmlTag) {\n                sourcetag_inherits(SourceTag, _HtmlTag);\n                var _super = sourcetag_createSuper(SourceTag);\n                function SourceTag(publicId) {\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    sourcetag_classCallCheck(this, SourceTag);\n                    return _super.call(this, \"source\", publicId, options);\n                }\n                /** @override */ sourcetag_createClass(SourceTag, [\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"\";\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            var srcsetParam = this.getOption(\"srcset\");\n                            var attr = sourcetag_get(sourcetag_getPrototypeOf(SourceTag.prototype), \"attributes\", this).call(this) || {};\n                            var options = this.getOptions();\n                            merge_root_merge_default()(attr, generateImageResponsiveAttributes(this.publicId, attr, srcsetParam, options));\n                            if (!attr.srcset) {\n                                attr.srcset = url_url(this.publicId, options);\n                            }\n                            if (!attr.media && options.media) {\n                                attr.media = generateMediaAttr(options.media);\n                            }\n                            return attr;\n                        }\n                    }\n                ]);\n                return SourceTag;\n            }(htmltag);\n            ;\n            /* harmony default export */ var sourcetag = sourcetag_SourceTag;\n            // CONCATENATED MODULE: ./src/tags/picturetag.js\n            function picturetag_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return picturetag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, picturetag_typeof(obj);\n            }\n            function picturetag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function picturetag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function picturetag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) picturetag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) picturetag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function picturetag_get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    picturetag_get = Reflect.get.bind();\n                } else {\n                    picturetag_get = function _get(target, property, receiver) {\n                        var base = picturetag_superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return picturetag_get.apply(this, arguments);\n            }\n            function picturetag_superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = picturetag_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function picturetag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) picturetag_setPrototypeOf(subClass, superClass);\n            }\n            function picturetag_setPrototypeOf(o, p) {\n                picturetag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return picturetag_setPrototypeOf(o, p);\n            }\n            function picturetag_createSuper(Derived) {\n                var hasNativeReflectConstruct = picturetag_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = picturetag_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = picturetag_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return picturetag_possibleConstructorReturn(this, result);\n                };\n            }\n            function picturetag_possibleConstructorReturn(self, call) {\n                if (call && (picturetag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return picturetag_assertThisInitialized(self);\n            }\n            function picturetag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function picturetag_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function picturetag_getPrototypeOf(o) {\n                picturetag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return picturetag_getPrototypeOf(o);\n            }\n            var picturetag_PictureTag = /*#__PURE__*/ function(_HtmlTag) {\n                picturetag_inherits(PictureTag, _HtmlTag);\n                var _super = picturetag_createSuper(PictureTag);\n                function PictureTag(publicId) {\n                    var _this;\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    var sources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n                    picturetag_classCallCheck(this, PictureTag);\n                    _this = _super.call(this, \"picture\", publicId, options);\n                    _this.widthList = sources;\n                    return _this;\n                }\n                /** @override */ picturetag_createClass(PictureTag, [\n                    {\n                        key: \"content\",\n                        value: function content() {\n                            var _this2 = this;\n                            return this.widthList.map(function(_ref) {\n                                var min_width = _ref.min_width, max_width = _ref.max_width, transformation = _ref.transformation;\n                                var options = _this2.getOptions();\n                                var sourceTransformation = new src_transformation(options);\n                                sourceTransformation.chain().fromOptions(typeof transformation === \"string\" ? {\n                                    raw_transformation: transformation\n                                } : transformation);\n                                options = extractUrlParams(options);\n                                options.media = {\n                                    min_width: min_width,\n                                    max_width: max_width\n                                };\n                                options.transformation = sourceTransformation;\n                                return new sourcetag(_this2.publicId, options).toHtml();\n                            }).join(\"\") + new imagetag(this.publicId, this.getOptions()).toHtml();\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            var attr = picturetag_get(picturetag_getPrototypeOf(PictureTag.prototype), \"attributes\", this).call(this);\n                            delete attr.width;\n                            delete attr.height;\n                            return attr;\n                        }\n                    },\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"</\" + this.name + \">\";\n                        }\n                    }\n                ]);\n                return PictureTag;\n            }(htmltag);\n            ;\n            /* harmony default export */ var picturetag = picturetag_PictureTag;\n            // CONCATENATED MODULE: ./src/tags/videotag.js\n            function videotag_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return videotag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, videotag_typeof(obj);\n            }\n            function videotag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function videotag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function videotag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) videotag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) videotag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function videotag_get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    videotag_get = Reflect.get.bind();\n                } else {\n                    videotag_get = function _get(target, property, receiver) {\n                        var base = videotag_superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return videotag_get.apply(this, arguments);\n            }\n            function videotag_superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = videotag_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function videotag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) videotag_setPrototypeOf(subClass, superClass);\n            }\n            function videotag_setPrototypeOf(o, p) {\n                videotag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return videotag_setPrototypeOf(o, p);\n            }\n            function videotag_createSuper(Derived) {\n                var hasNativeReflectConstruct = videotag_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = videotag_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = videotag_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return videotag_possibleConstructorReturn(this, result);\n                };\n            }\n            function videotag_possibleConstructorReturn(self, call) {\n                if (call && (videotag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return videotag_assertThisInitialized(self);\n            }\n            function videotag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function videotag_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function videotag_getPrototypeOf(o) {\n                videotag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return videotag_getPrototypeOf(o);\n            }\n            /**\n * Video Tag\n * Depends on 'tags/htmltag', 'util', 'cloudinary'\n */ var VIDEO_TAG_PARAMS = [\n                \"source_types\",\n                \"source_transformation\",\n                \"fallback_content\",\n                \"poster\",\n                \"sources\"\n            ];\n            var videotag_DEFAULT_VIDEO_SOURCE_TYPES = [\n                \"webm\",\n                \"mp4\",\n                \"ogv\"\n            ];\n            var videotag_DEFAULT_POSTER_OPTIONS = {\n                format: \"jpg\",\n                resource_type: \"video\"\n            };\n            /**\n * Creates an HTML (DOM) Video tag using Cloudinary as the source.\n * @constructor VideoTag\n * @extends HtmlTag\n * @param {string} [publicId]\n * @param {Object} [options]\n */ var videotag_VideoTag = /*#__PURE__*/ function(_HtmlTag) {\n                videotag_inherits(VideoTag, _HtmlTag);\n                var _super = videotag_createSuper(VideoTag);\n                function VideoTag(publicId) {\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    videotag_classCallCheck(this, VideoTag);\n                    options = defaults({}, options, DEFAULT_VIDEO_PARAMS);\n                    return _super.call(this, \"video\", publicId.replace(/\\.(mp4|ogv|webm)$/, \"\"), options);\n                }\n                /**\n   * Set the transformation to apply on each source\n   * @function VideoTag#setSourceTransformation\n   * @param {Object} an object with pairs of source type and source transformation\n   * @returns {VideoTag} Returns this instance for chaining purposes.\n   */ videotag_createClass(VideoTag, [\n                    {\n                        key: \"setSourceTransformation\",\n                        value: function setSourceTransformation(value) {\n                            this.transformation().sourceTransformation(value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"setSourceTypes\",\n                        value: function setSourceTypes(value) {\n                            this.transformation().sourceTypes(value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"setPoster\",\n                        value: function setPoster(value) {\n                            this.transformation().poster(value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"setFallbackContent\",\n                        value: function setFallbackContent(value) {\n                            this.transformation().fallbackContent(value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"content\",\n                        value: function content() {\n                            var _this = this;\n                            var sourceTypes = this.transformation().getValue(\"source_types\");\n                            var sourceTransformation = this.transformation().getValue(\"source_transformation\");\n                            var fallback = this.transformation().getValue(\"fallback_content\");\n                            var sources = this.getOption(\"sources\");\n                            var innerTags = [];\n                            if (isArray_root_isArray_default()(sources) && !isEmpty(sources)) {\n                                innerTags = sources.map(function(source) {\n                                    var src = url_url(_this.publicId, defaults({}, source.transformations || {}, {\n                                        resource_type: \"video\",\n                                        format: source.type\n                                    }), _this.getOptions());\n                                    return _this.createSourceTag(src, source.type, source.codecs);\n                                });\n                            } else {\n                                if (isEmpty(sourceTypes)) {\n                                    sourceTypes = videotag_DEFAULT_VIDEO_SOURCE_TYPES;\n                                }\n                                if (isArray_root_isArray_default()(sourceTypes)) {\n                                    innerTags = sourceTypes.map(function(srcType) {\n                                        var src = url_url(_this.publicId, defaults({}, sourceTransformation[srcType] || {}, {\n                                            resource_type: \"video\",\n                                            format: srcType\n                                        }), _this.getOptions());\n                                        return _this.createSourceTag(src, srcType);\n                                    });\n                                }\n                            }\n                            return innerTags.join(\"\") + fallback;\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            var sourceTypes = this.getOption(\"source_types\");\n                            var poster = this.getOption(\"poster\");\n                            if (poster === undefined) {\n                                poster = {};\n                            }\n                            if (isPlainObject_root_isPlainObject_default()(poster)) {\n                                var defaultOptions = poster.public_id != null ? DEFAULT_IMAGE_PARAMS : videotag_DEFAULT_POSTER_OPTIONS;\n                                poster = url_url(poster.public_id || this.publicId, defaults({}, poster, defaultOptions, this.getOptions()));\n                            }\n                            var attr = videotag_get(videotag_getPrototypeOf(VideoTag.prototype), \"attributes\", this).call(this) || {};\n                            attr = omit(attr, VIDEO_TAG_PARAMS);\n                            var sources = this.getOption(\"sources\"); // In case of empty sourceTypes - fallback to default source types is used.\n                            var hasSourceTags = !isEmpty(sources) || isEmpty(sourceTypes) || isArray_root_isArray_default()(sourceTypes);\n                            if (!hasSourceTags) {\n                                attr[\"src\"] = url_url(this.publicId, this.getOptions(), {\n                                    resource_type: \"video\",\n                                    format: sourceTypes\n                                });\n                            }\n                            if (poster != null) {\n                                attr[\"poster\"] = poster;\n                            }\n                            return attr;\n                        }\n                    },\n                    {\n                        key: \"createSourceTag\",\n                        value: function createSourceTag(src, sourceType) {\n                            var codecs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n                            var mimeType = null;\n                            if (!isEmpty(sourceType)) {\n                                var videoType = sourceType === \"ogv\" ? \"ogg\" : sourceType;\n                                mimeType = \"video/\" + videoType;\n                                if (!isEmpty(codecs)) {\n                                    var codecsStr = isArray_root_isArray_default()(codecs) ? codecs.join(\", \") : codecs;\n                                    mimeType += \"; codecs=\" + codecsStr;\n                                }\n                            }\n                            return \"<source \" + this.htmlAttrs({\n                                src: src,\n                                type: mimeType\n                            }) + \">\";\n                        }\n                    }\n                ]);\n                return VideoTag;\n            }(htmltag);\n            /* harmony default export */ var videotag = videotag_VideoTag;\n            // CONCATENATED MODULE: ./src/tags/clienthintsmetatag.js\n            function clienthintsmetatag_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return clienthintsmetatag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, clienthintsmetatag_typeof(obj);\n            }\n            function clienthintsmetatag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function clienthintsmetatag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function clienthintsmetatag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) clienthintsmetatag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) clienthintsmetatag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function clienthintsmetatag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) clienthintsmetatag_setPrototypeOf(subClass, superClass);\n            }\n            function clienthintsmetatag_setPrototypeOf(o, p) {\n                clienthintsmetatag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return clienthintsmetatag_setPrototypeOf(o, p);\n            }\n            function clienthintsmetatag_createSuper(Derived) {\n                var hasNativeReflectConstruct = clienthintsmetatag_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = clienthintsmetatag_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = clienthintsmetatag_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return clienthintsmetatag_possibleConstructorReturn(this, result);\n                };\n            }\n            function clienthintsmetatag_possibleConstructorReturn(self, call) {\n                if (call && (clienthintsmetatag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return clienthintsmetatag_assertThisInitialized(self);\n            }\n            function clienthintsmetatag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function clienthintsmetatag_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function clienthintsmetatag_getPrototypeOf(o) {\n                clienthintsmetatag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return clienthintsmetatag_getPrototypeOf(o);\n            }\n            /**\n * Image Tag\n * Depends on 'tags/htmltag', 'cloudinary'\n */ /**\n * Creates an HTML (DOM) Meta tag that enables Client-Hints for the HTML page. <br/>\n *  See\n *  <a href=\"https://cloudinary.com/documentation/responsive_images#automating_responsive_images_with_client_hints\"\n *  target=\"_new\">Automating responsive images with Client Hints</a> for more details.\n * @constructor ClientHintsMetaTag\n * @extends HtmlTag\n * @param {object} options\n * @example\n * tag = new ClientHintsMetaTag()\n * //returns: <meta http-equiv=\"Accept-CH\" content=\"DPR, Viewport-Width, Width\">\n */ var clienthintsmetatag_ClientHintsMetaTag = /*#__PURE__*/ function(_HtmlTag) {\n                clienthintsmetatag_inherits(ClientHintsMetaTag, _HtmlTag);\n                var _super = clienthintsmetatag_createSuper(ClientHintsMetaTag);\n                function ClientHintsMetaTag(options) {\n                    clienthintsmetatag_classCallCheck(this, ClientHintsMetaTag);\n                    return _super.call(this, \"meta\", void 0, assign_root_assign_default()({\n                        \"http-equiv\": \"Accept-CH\",\n                        content: \"DPR, Viewport-Width, Width\"\n                    }, options));\n                }\n                /** @override */ clienthintsmetatag_createClass(ClientHintsMetaTag, [\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"\";\n                        }\n                    }\n                ]);\n                return ClientHintsMetaTag;\n            }(htmltag);\n            ;\n            /* harmony default export */ var clienthintsmetatag = clienthintsmetatag_ClientHintsMetaTag;\n            // CONCATENATED MODULE: ./src/util/parse/normalizeToArray.js\n            function normalizeToArray_toConsumableArray(arr) {\n                return normalizeToArray_arrayWithoutHoles(arr) || normalizeToArray_iterableToArray(arr) || normalizeToArray_unsupportedIterableToArray(arr) || normalizeToArray_nonIterableSpread();\n            }\n            function normalizeToArray_nonIterableSpread() {\n                throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function normalizeToArray_unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return normalizeToArray_arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return normalizeToArray_arrayLikeToArray(o, minLen);\n            }\n            function normalizeToArray_iterableToArray(iter) {\n                if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n            }\n            function normalizeToArray_arrayWithoutHoles(arr) {\n                if (Array.isArray(arr)) return normalizeToArray_arrayLikeToArray(arr);\n            }\n            function normalizeToArray_arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            /**\n * @desc normalize elements, support a single element, array or nodelist, always outputs array\n * @param elements<HTMLElement[]>\n * @returns {[]}\n */ function normalizeToArray(elements) {\n                if (isArray_root_isArray_default()(elements)) {\n                    return elements;\n                } else if (elements.constructor.name === \"NodeList\") {\n                    return normalizeToArray_toConsumableArray(elements); // ensure an array is always returned, even if nodelist\n                } else if (isString_root_isString_default()(elements)) {\n                    return Array.prototype.slice.call(document.querySelectorAll(elements), 0);\n                } else {\n                    return [\n                        elements\n                    ];\n                }\n            }\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/mountCloudinaryVideoTag.js\n            /**\n * @param {HTMLElement} htmlElContainer\n * @param {object} clInstance cloudinary instance\n * @param {string} publicId\n * @param {object} options - TransformationOptions\n * @returns Promise<HTMLElement>\n */ function mountCloudinaryVideoTag(htmlElContainer, clInstance, publicId, options) {\n                return new Promise(function(resolve, reject) {\n                    htmlElContainer.innerHTML = clInstance.videoTag(publicId, options).toHtml(); // All videos under the html container must have a width of 100%, or they might overflow from the container\n                    var cloudinaryVideoElement = htmlElContainer.querySelector(\".cld-transparent-video\");\n                    cloudinaryVideoElement.style.width = \"100%\";\n                    resolve(htmlElContainer);\n                });\n            }\n            /* harmony default export */ var transparentVideo_mountCloudinaryVideoTag = mountCloudinaryVideoTag;\n            // CONCATENATED MODULE: ./src/util/transformations/addFlag.js\n            /**\n * @description - Function will push a flag to incoming options\n * @param {{transformation} | {...transformation}} options - These options are the same options provided to all our SDK methods\n *                           We expect options to either be the transformation itself, or an object containing\n *                           an array of transformations\n *\n * @param {string} flag\n * @returns the mutated options object\n */ function addFlagToOptions(options, flag) {\n                // Do we have transformation\n                if (options.transformation) {\n                    options.transformation.push({\n                        flags: [\n                            flag\n                        ]\n                    });\n                } else {\n                    // no transformation\n                    // ensure the flags are extended\n                    if (!options.flags) {\n                        options.flags = [];\n                    }\n                    if (typeof options.flags === \"string\") {\n                        options.flags = [\n                            options.flags\n                        ];\n                    }\n                    options.flags.push(flag);\n                }\n            }\n            /* harmony default export */ var addFlag = addFlagToOptions;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/enforceOptionsForTransparentVideo.js\n            /**\n * @description - Enforce option structure, sets defaults and ensures alpha flag exists\n * @param options {TransformationOptions}\n */ function enforceOptionsForTransparentVideo(options) {\n                options.autoplay = true;\n                options.muted = true;\n                options.controls = false;\n                options.max_timeout_ms = options.max_timeout_ms || DEFAULT_TIMEOUT_MS;\n                options[\"class\"] = options[\"class\"] || \"\";\n                options[\"class\"] += \" cld-transparent-video\";\n                options.externalLibraries = options.externalLibraries || {};\n                if (!options.externalLibraries.seeThru) {\n                    options.externalLibraries.seeThru = DEFAULT_EXTERNAL_LIBRARIES.seeThru;\n                } // ensure there's an alpha transformation present\n                // this is a non documented internal flag\n                addFlag(options, \"alpha\");\n            }\n            /* harmony default export */ var transparentVideo_enforceOptionsForTransparentVideo = enforceOptionsForTransparentVideo;\n            // CONCATENATED MODULE: ./src/util/xhr/loadScript.js\n            /**\n * @description - Given a string URL, this function will load the script and resolve the promise.\n *                The function doesn't resolve any value,\n *                this is not a UMD loader where you can get your library name back.\n * @param scriptURL {string}\n * @param {number} max_timeout_ms - Time to elapse before promise is rejected\n * @param isAlreadyLoaded {boolean} if true, the loadScript resolves immediately\n *                                  this is used for multiple invocations - prevents the script from being loaded multiple times\n * @return {Promise<any | {status:string, message:string}>}\n */ function loadScript(scriptURL, max_timeout_ms, isAlreadyLoaded) {\n                return new Promise(function(resolve, reject) {\n                    if (isAlreadyLoaded) {\n                        resolve();\n                    } else {\n                        var scriptTag = document.createElement(\"script\");\n                        scriptTag.src = scriptURL;\n                        var timerID = setTimeout(function() {\n                            reject({\n                                status: \"error\",\n                                message: \"Timeout loading script \".concat(scriptURL)\n                            });\n                        }, max_timeout_ms); // 10 seconds for timeout\n                        scriptTag.onerror = function() {\n                            clearTimeout(timerID); // clear timeout reject error\n                            reject({\n                                status: \"error\",\n                                message: \"Error loading \".concat(scriptURL)\n                            });\n                        };\n                        scriptTag.onload = function() {\n                            clearTimeout(timerID); // clear timeout reject error\n                            resolve();\n                        };\n                        document.head.appendChild(scriptTag);\n                    }\n                });\n            }\n            /* harmony default export */ var xhr_loadScript = loadScript;\n            // CONCATENATED MODULE: ./src/util/xhr/getBlobFromURL.js\n            /**\n * Reject on timeout\n * @param maxTimeoutMS\n * @param reject\n * @returns {number} timerID\n */ function rejectOnTimeout(maxTimeoutMS, reject) {\n                return setTimeout(function() {\n                    reject({\n                        status: \"error\",\n                        message: \"Timeout loading Blob URL\"\n                    });\n                }, maxTimeoutMS);\n            }\n            /**\n * @description Converts a URL to a BLOB URL\n * @param {string} urlToLoad\n * @param {number} max_timeout_ms - Time to elapse before promise is rejected\n * @return {Promise<{\n *   status: 'success' | 'error'\n *   message?: string,\n *    payload: {\n *      url: string\n *    }\n * }>}\n */ function getBlobFromURL(urlToLoad, maxTimeoutMS) {\n                return new Promise(function(resolve, reject) {\n                    var timerID = rejectOnTimeout(maxTimeoutMS, reject); // If fetch exists, use it to fetch blob, otherwise use XHR.\n                    // XHR causes issues on safari 14.1 so we prefer fetch\n                    var fetchBlob = typeof fetch !== \"undefined\" && fetch ? loadUrlUsingFetch : loadUrlUsingXhr;\n                    fetchBlob(urlToLoad).then(function(blob) {\n                        resolve({\n                            status: \"success\",\n                            payload: {\n                                blobURL: URL.createObjectURL(blob)\n                            }\n                        });\n                    })[\"catch\"](function() {\n                        reject({\n                            status: \"error\",\n                            message: \"Error loading Blob URL\"\n                        });\n                    })[\"finally\"](function() {\n                        // Clear the timeout timer on fail or success.\n                        clearTimeout(timerID);\n                    });\n                });\n            }\n            /**\n * Use fetch function to fetch file\n * @param urlToLoad\n * @returns {Promise<unknown>}\n */ function loadUrlUsingFetch(urlToLoad) {\n                return new Promise(function(resolve, reject) {\n                    fetch(urlToLoad).then(function(response) {\n                        response.blob().then(function(blob) {\n                            resolve(blob);\n                        });\n                    })[\"catch\"](function() {\n                        reject(\"error\");\n                    });\n                });\n            }\n            /**\n * Use XHR to fetch file\n * @param urlToLoad\n * @returns {Promise<unknown>}\n */ function loadUrlUsingXhr(urlToLoad) {\n                return new Promise(function(resolve, reject) {\n                    var xhr = new XMLHttpRequest();\n                    xhr.responseType = \"blob\";\n                    xhr.onload = function(response) {\n                        resolve(xhr.response);\n                    };\n                    xhr.onerror = function() {\n                        reject(\"error\");\n                    };\n                    xhr.open(\"GET\", urlToLoad, true);\n                    xhr.send();\n                });\n            }\n            /* harmony default export */ var xhr_getBlobFromURL = getBlobFromURL;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/createHiddenVideoTag.js\n            /**\n * @description Creates a hidden HTMLVideoElement with the specified videoOptions\n * @param {{autoplay, playsinline, loop, muted, poster, blobURL, videoURL }} videoOptions\n * @param {boolean} videoOptions.autoplay - autoplays the video if true\n * @param {string} videoOptions.blobURL - the blobURL to set as video.src\n * @param {string} videoOptions.videoURL - the original videoURL the user created (with transformations)\n * @return {HTMLVideoElement}\n */ function createHiddenVideoTag(videoOptions) {\n                var autoplay = videoOptions.autoplay, playsinline = videoOptions.playsinline, loop = videoOptions.loop, muted = videoOptions.muted, poster = videoOptions.poster, blobURL = videoOptions.blobURL, videoURL = videoOptions.videoURL;\n                var el = document.createElement(\"video\");\n                el.style.visibility = \"hidden\";\n                el.position = \"absolute\";\n                el.x = 0;\n                el.y = 0;\n                el.src = blobURL;\n                el.setAttribute(\"data-video-url\", videoURL); // for debugging/testing\n                autoplay && el.setAttribute(\"autoplay\", autoplay);\n                playsinline && el.setAttribute(\"playsinline\", playsinline);\n                loop && el.setAttribute(\"loop\", loop);\n                muted && el.setAttribute(\"muted\", muted);\n                muted && (el.muted = muted); // this is also needed for autoplay, on top of setAttribute\n                poster && el.setAttribute(\"poster\", poster); // Free memory at the end of the file loading.\n                el.onload = function() {\n                    URL.revokeObjectURL(blobURL);\n                };\n                return el;\n            }\n            /* harmony default export */ var transparentVideo_createHiddenVideoTag = createHiddenVideoTag;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/instantiateSeeThru.js\n            /**\n * @description This function creates a new instanc eof seeThru (seeThru.create()) and returns a promise of the seeThru instance\n * @param {HTMLVideoElement} videoElement\n * @param {number} max_timeout_ms - Time to elapse before promise is rejected\n * @param {string} customClass - A classname to be added to the canvas element created by seeThru\n * @param {boolean} autoPlay\n * @return {Promise<any>} SeeThru instance or rejection error\n */ function instantiateSeeThru(videoElement, max_timeout_ms, customClass, autoPlay) {\n                var _window = window, seeThru = _window.seeThru, setTimeout1 = _window.setTimeout, clearTimeout1 = _window.clearTimeout;\n                return new Promise(function(resolve, reject) {\n                    var timerID = setTimeout1(function() {\n                        reject({\n                            status: \"error\",\n                            message: \"Timeout instantiating seeThru instance\"\n                        });\n                    }, max_timeout_ms);\n                    if (seeThru) {\n                        var seeThruInstance = seeThru.create(videoElement).ready(function() {\n                            // clear timeout reject error\n                            clearTimeout1(timerID); // force container width, else the canvas can overflow out\n                            var canvasElement = seeThruInstance.getCanvas();\n                            canvasElement.style.width = \"100%\";\n                            canvasElement.className += \" \" + customClass; // start the video if autoplay is set\n                            if (autoPlay) {\n                                seeThruInstance.play();\n                            }\n                            resolve(seeThruInstance);\n                        });\n                    } else {\n                        reject({\n                            status: \"error\",\n                            message: \"Error instantiating seeThru instance\"\n                        });\n                    }\n                });\n            }\n            /* harmony default export */ var transparentVideo_instantiateSeeThru = instantiateSeeThru;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/mountSeeThruCanvasTag.js\n            /**\n *\n * @param {HTMLElement} htmlElContainer\n * @param {string} videoURL\n * @param {TransformationOptions} options\n * @return {Promise<any>}\n */ function mountSeeThruCanvasTag(htmlElContainer, videoURL, options) {\n                var poster = options.poster, autoplay = options.autoplay, playsinline = options.playsinline, loop = options.loop, muted = options.muted;\n                videoURL = videoURL + \".mp4\"; // seeThru always uses mp4\n                return new Promise(function(resolve, reject) {\n                    xhr_loadScript(options.externalLibraries.seeThru, options.max_timeout_ms, window.seeThru).then(function() {\n                        xhr_getBlobFromURL(videoURL, options.max_timeout_ms).then(function(_ref) {\n                            var payload = _ref.payload;\n                            var videoElement = transparentVideo_createHiddenVideoTag({\n                                blobURL: payload.blobURL,\n                                videoURL: videoURL,\n                                // for debugging/testing\n                                poster: poster,\n                                autoplay: autoplay,\n                                playsinline: playsinline,\n                                loop: loop,\n                                muted: muted\n                            });\n                            htmlElContainer.appendChild(videoElement);\n                            transparentVideo_instantiateSeeThru(videoElement, options.max_timeout_ms, options[\"class\"], options.autoplay).then(function() {\n                                resolve(htmlElContainer);\n                            })[\"catch\"](function(err) {\n                                reject(err);\n                            }); // catch for getBlobFromURL()\n                        })[\"catch\"](function(_ref2) {\n                            var status = _ref2.status, message = _ref2.message;\n                            reject({\n                                status: status,\n                                message: message\n                            });\n                        }); // catch for loadScript()\n                    })[\"catch\"](function(_ref3) {\n                        var status = _ref3.status, message = _ref3.message;\n                        reject({\n                            status: status,\n                            message: message\n                        });\n                    });\n                });\n            }\n            /* harmony default export */ var transparentVideo_mountSeeThruCanvasTag = mountSeeThruCanvasTag;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/checkSupportForTransparency.js\n            /**\n * @return {Promise<boolean>} - Whether the browser supports transparent videos or not\n */ function checkSupportForTransparency() {\n                return new Promise(function(resolve, reject) {\n                    // Resolve early for safari.\n                    // Currently (29 December 2021) Safari can play webm/vp9,\n                    // but it does not support transparent video in the format we're outputting\n                    if (isSafari()) {\n                        resolve(false);\n                    }\n                    var video = document.createElement(\"video\");\n                    var canPlay = video.canPlayType && video.canPlayType('video/webm; codecs=\"vp9\"');\n                    resolve(canPlay === \"maybe\" || canPlay === \"probably\");\n                });\n            }\n            /* harmony default export */ var transparentVideo_checkSupportForTransparency = checkSupportForTransparency;\n            // CONCATENATED MODULE: ./src/cloudinary.js\n            function cloudinary_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function cloudinary_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function cloudinary_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) cloudinary_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) cloudinary_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            var applyBreakpoints, closestAbove, defaultBreakpoints, cloudinary_findContainerWidth, cloudinary_maxWidth, updateDpr;\n            //\n            defaultBreakpoints = function defaultBreakpoints(width) {\n                var steps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n                return steps * Math.ceil(width / steps);\n            };\n            closestAbove = function closestAbove(list, value) {\n                var i;\n                i = list.length - 2;\n                while(i >= 0 && list[i] >= value){\n                    i--;\n                }\n                return list[i + 1];\n            };\n            applyBreakpoints = function applyBreakpoints(tag, width, steps, options) {\n                var ref, ref1, ref2, responsive_use_breakpoints;\n                responsive_use_breakpoints = (ref = (ref1 = (ref2 = options[\"responsive_use_breakpoints\"]) != null ? ref2 : options[\"responsive_use_stoppoints\"]) != null ? ref1 : this.config(\"responsive_use_breakpoints\")) != null ? ref : this.config(\"responsive_use_stoppoints\");\n                if (!responsive_use_breakpoints || responsive_use_breakpoints === \"resize\" && !options.resizing) {\n                    return width;\n                } else {\n                    return this.calc_breakpoint(tag, width, steps);\n                }\n            };\n            cloudinary_findContainerWidth = function findContainerWidth(element) {\n                var containerWidth, style;\n                containerWidth = 0;\n                while((element = element != null ? element.parentNode : void 0) instanceof Element && !containerWidth){\n                    style = window.getComputedStyle(element);\n                    if (!/^inline/.test(style.display)) {\n                        containerWidth = lodash_width(element);\n                    }\n                }\n                return containerWidth;\n            };\n            updateDpr = function updateDpr(dataSrc, roundDpr) {\n                return dataSrc.replace(/\\bdpr_(1\\.0|auto)\\b/g, \"dpr_\" + this.device_pixel_ratio(roundDpr));\n            };\n            cloudinary_maxWidth = function maxWidth(requiredWidth, tag) {\n                var imageWidth;\n                imageWidth = lodash_getData(tag, \"width\") || 0;\n                if (requiredWidth > imageWidth) {\n                    imageWidth = requiredWidth;\n                    lodash_setData(tag, \"width\", requiredWidth);\n                }\n                return imageWidth;\n            };\n            var cloudinary_Cloudinary = /*#__PURE__*/ function() {\n                /**\n   * Creates a new Cloudinary instance.\n   * @class Cloudinary\n   * @classdesc Main class for accessing Cloudinary functionality.\n   * @param {Object} options - A {@link Configuration} object for globally configuring Cloudinary account settings.\n   * @example<br/>\n   *  var cl = new cloudinary.Cloudinary( { cloud_name: \"mycloud\"});<br/>\n   *  var imgTag = cl.image(\"myPicID\");\n   * @see <a href=\"https://cloudinary.com/documentation/solution_overview#configuration_parameters\" target=\"_blank\">\n   *  Available configuration options</a>\n   */ function Cloudinary(options) {\n                    cloudinary_classCallCheck(this, Cloudinary);\n                    var configuration;\n                    this.devicePixelRatioCache = {};\n                    this.responsiveConfig = {};\n                    this.responsiveResizeInitialized = false;\n                    configuration = new src_configuration(options); // Provided for backward compatibility\n                    this.config = function(newConfig, newValue) {\n                        return configuration.config(newConfig, newValue);\n                    };\n                    /**\n     * Use \\<meta\\> tags in the document to configure this `cloudinary` instance.\n     * @return This {Cloudinary} instance for chaining.\n     */ this.fromDocument = function() {\n                        configuration.fromDocument();\n                        return this;\n                    };\n                    /**\n     * Use environment variables to configure this `cloudinary` instance.\n     * @return This {Cloudinary} instance for chaining.\n     */ this.fromEnvironment = function() {\n                        configuration.fromEnvironment();\n                        return this;\n                    };\n                    /**\n     * Initializes the configuration of this `cloudinary` instance.\n     *  This is a convenience method that invokes both {@link Configuration#fromEnvironment|fromEnvironment()}\n     *  (Node.js environment only) and {@link Configuration#fromDocument|fromDocument()}.\n     *  It first tries to retrieve the configuration from the environment variable.\n     *  If not available, it tries from the document meta tags.\n     * @function Cloudinary#init\n     * @see Configuration#init\n     * @return This {Cloudinary} instance for chaining.\n     */ this.init = function() {\n                        configuration.init();\n                        return this;\n                    };\n                }\n                /**\n   * Convenience constructor\n   * @param {Object} options\n   * @return {Cloudinary}\n   * @example cl = cloudinary.Cloudinary.new( { cloud_name: \"mycloud\"})\n   */ cloudinary_createClass(Cloudinary, [\n                    {\n                        key: \"url\",\n                        value: /**\n     * Generates a URL for any asset in your Media library.\n     * @function Cloudinary#url\n     * @param {string} publicId - The public ID of the media asset.\n     * @param {Object} [options] - The {@link Transformation} parameters to include in the URL.\n     * @param {type} [options.type='upload'] - The asset's storage type.\n     *  For details on all fetch types, see\n     * <a href=\"https://cloudinary.com/documentation/image_transformations#fetching_images_from_remote_locations\"\n     *  target=\"_blank\">Fetch types</a>.\n     * @param {resourceType} [options.resource_type='image'] - The type of asset. Possible values:<br/>\n     *  - `image`<br/>\n     *  - `video`<br/>\n     *  - `raw`\n     * @return {string} The media asset URL.\n     * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\" target=\"_blank\">\n     *  Available image transformations</a>\n     * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\" target=\"_blank\">\n     *  Available video transformations</a>\n     */ function url(publicId) {\n                            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                            return url_url(publicId, options, this.config());\n                        }\n                    },\n                    {\n                        key: \"video_url\",\n                        value: function video_url(publicId, options) {\n                            options = assign_root_assign_default()({\n                                resource_type: \"video\"\n                            }, options);\n                            return this.url(publicId, options);\n                        }\n                    },\n                    {\n                        key: \"video_thumbnail_url\",\n                        value: function video_thumbnail_url(publicId, options) {\n                            options = assign_root_assign_default()({}, DEFAULT_POSTER_OPTIONS, options);\n                            return this.url(publicId, options);\n                        }\n                    },\n                    {\n                        key: \"transformation_string\",\n                        value: function transformation_string(options) {\n                            return new src_transformation(options).serialize();\n                        }\n                    },\n                    {\n                        key: \"image\",\n                        value: function image(publicId) {\n                            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                            var client_hints, img, ref;\n                            img = this.imageTag(publicId, options);\n                            client_hints = (ref = options.client_hints != null ? options.client_hints : this.config(\"client_hints\")) != null ? ref : false;\n                            if (options.src == null && !client_hints) {\n                                // src must be removed before creating the DOM element to avoid loading the image\n                                img.setAttr(\"src\", \"\");\n                            }\n                            img = img.toDOM();\n                            if (!client_hints) {\n                                // cache the image src\n                                lodash_setData(img, \"src-cache\", this.url(publicId, options)); // set image src taking responsiveness in account\n                                this.cloudinary_update(img, options);\n                            }\n                            return img;\n                        }\n                    },\n                    {\n                        key: \"imageTag\",\n                        value: function imageTag(publicId, options) {\n                            var tag;\n                            tag = new imagetag(publicId, this.config());\n                            tag.transformation().fromOptions(options);\n                            return tag;\n                        }\n                    },\n                    {\n                        key: \"pictureTag\",\n                        value: function pictureTag(publicId, options, sources) {\n                            var tag;\n                            tag = new picturetag(publicId, this.config(), sources);\n                            tag.transformation().fromOptions(options);\n                            return tag;\n                        }\n                    },\n                    {\n                        key: \"sourceTag\",\n                        value: function sourceTag(publicId, options) {\n                            var tag;\n                            tag = new sourcetag(publicId, this.config());\n                            tag.transformation().fromOptions(options);\n                            return tag;\n                        }\n                    },\n                    {\n                        key: \"video_thumbnail\",\n                        value: function video_thumbnail(publicId, options) {\n                            return this.image(publicId, merge_root_merge_default()({}, DEFAULT_POSTER_OPTIONS, options));\n                        }\n                    },\n                    {\n                        key: \"facebook_profile_image\",\n                        value: function facebook_profile_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"facebook\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"twitter_profile_image\",\n                        value: function twitter_profile_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"twitter\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"twitter_name_profile_image\",\n                        value: function twitter_name_profile_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"twitter_name\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"gravatar_image\",\n                        value: function gravatar_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"gravatar\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"fetch_image\",\n                        value: function fetch_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"fetch\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"video\",\n                        value: function video(publicId) {\n                            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                            return this.videoTag(publicId, options).toHtml();\n                        }\n                    },\n                    {\n                        key: \"videoTag\",\n                        value: function videoTag(publicId, options) {\n                            options = defaults({}, options, this.config());\n                            return new videotag(publicId, options);\n                        }\n                    },\n                    {\n                        key: \"sprite_css\",\n                        value: function sprite_css(publicId, options) {\n                            options = assign_root_assign_default()({\n                                type: \"sprite\"\n                            }, options);\n                            if (!publicId.match(/.css$/)) {\n                                options.format = \"css\";\n                            }\n                            return this.url(publicId, options);\n                        }\n                    },\n                    {\n                        key: \"responsive\",\n                        value: function responsive(options) {\n                            var _this = this;\n                            var bootstrap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n                            var ref, ref1, ref2, responsiveClass, responsiveResize, timeout;\n                            this.responsiveConfig = merge_root_merge_default()(this.responsiveConfig || {}, options);\n                            responsiveClass = (ref = this.responsiveConfig.responsive_class) != null ? ref : this.config(\"responsive_class\");\n                            if (bootstrap) {\n                                this.cloudinary_update(\"img.\".concat(responsiveClass, \", img.cld-hidpi\"), this.responsiveConfig);\n                            }\n                            responsiveResize = (ref1 = (ref2 = this.responsiveConfig.responsive_resize) != null ? ref2 : this.config(\"responsive_resize\")) != null ? ref1 : true;\n                            if (responsiveResize && !this.responsiveResizeInitialized) {\n                                this.responsiveConfig.resizing = this.responsiveResizeInitialized = true;\n                                timeout = null;\n                                var makeResponsive = function makeResponsive() {\n                                    var debounce, ref3, ref4, reset, run, wait, waitFunc;\n                                    debounce = (ref3 = (ref4 = _this.responsiveConfig.responsive_debounce) != null ? ref4 : _this.config(\"responsive_debounce\")) != null ? ref3 : 100;\n                                    reset = function reset() {\n                                        if (timeout) {\n                                            clearTimeout(timeout);\n                                            timeout = null;\n                                        }\n                                    };\n                                    run = function run() {\n                                        return _this.cloudinary_update(\"img.\".concat(responsiveClass), _this.responsiveConfig);\n                                    };\n                                    waitFunc = function waitFunc() {\n                                        reset();\n                                        return run();\n                                    };\n                                    wait = function wait() {\n                                        reset();\n                                        timeout = setTimeout(waitFunc, debounce);\n                                    };\n                                    if (debounce) {\n                                        return wait();\n                                    } else {\n                                        return run();\n                                    }\n                                };\n                                window.addEventListener(\"resize\", makeResponsive);\n                                return function() {\n                                    return window.removeEventListener(\"resize\", makeResponsive);\n                                };\n                            }\n                        }\n                    },\n                    {\n                        key: \"calc_breakpoint\",\n                        value: function calc_breakpoint(element, width, steps) {\n                            var breakpoints = lodash_getData(element, \"breakpoints\") || lodash_getData(element, \"stoppoints\") || this.config(\"breakpoints\") || this.config(\"stoppoints\") || defaultBreakpoints;\n                            if (isFunction_root_isFunction_default()(breakpoints)) {\n                                return breakpoints(width, steps);\n                            } else {\n                                if (isString_root_isString_default()(breakpoints)) {\n                                    breakpoints = breakpoints.split(\",\").map(function(point) {\n                                        return parseInt(point);\n                                    }).sort(function(a, b) {\n                                        return a - b;\n                                    });\n                                }\n                                return closestAbove(breakpoints, width);\n                            }\n                        }\n                    },\n                    {\n                        key: \"calc_stoppoint\",\n                        value: function calc_stoppoint(element, width, steps) {\n                            return this.calc_breakpoint(element, width, steps);\n                        }\n                    },\n                    {\n                        key: \"device_pixel_ratio\",\n                        value: function device_pixel_ratio(roundDpr) {\n                            roundDpr = roundDpr == null ? true : roundDpr;\n                            var dpr = ( false ? 0 : void 0) || 1;\n                            if (roundDpr) {\n                                dpr = Math.ceil(dpr);\n                            }\n                            if (dpr <= 0 || dpr === 0 / 0) {\n                                dpr = 1;\n                            }\n                            var dprString = dpr.toString();\n                            if (dprString.match(/^\\d+$/)) {\n                                dprString += \".0\";\n                            }\n                            return dprString;\n                        }\n                    },\n                    {\n                        key: \"processImageTags\",\n                        value: function processImageTags(nodes, options) {\n                            if (isEmpty(nodes)) {\n                                // similar to `$.fn.cloudinary`\n                                return this;\n                            }\n                            options = defaults({}, options || {}, this.config());\n                            var images = nodes.filter(function(node) {\n                                return /^img$/i.test(node.tagName);\n                            }).map(function(node) {\n                                var imgOptions = assign_root_assign_default()({\n                                    width: node.getAttribute(\"width\"),\n                                    height: node.getAttribute(\"height\"),\n                                    src: node.getAttribute(\"src\")\n                                }, options);\n                                var publicId = imgOptions[\"source\"] || imgOptions[\"src\"];\n                                delete imgOptions[\"source\"];\n                                delete imgOptions[\"src\"];\n                                var attr = new src_transformation(imgOptions).toHtmlAttributes();\n                                lodash_setData(node, \"src-cache\", url_url(publicId, imgOptions));\n                                node.setAttribute(\"width\", attr.width);\n                                node.setAttribute(\"height\", attr.height);\n                                return node;\n                            });\n                            this.cloudinary_update(images, options);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"cloudinary_update\",\n                        value: function cloudinary_update(elements, options) {\n                            var _this2 = this;\n                            var containerWidth, dataSrc, match, ref4, requiredWidth;\n                            if (elements === null) {\n                                return this;\n                            }\n                            if (options == null) {\n                                options = {};\n                            }\n                            var responsive = options.responsive != null ? options.responsive : this.config(\"responsive\");\n                            elements = normalizeToArray(elements);\n                            var responsiveClass;\n                            if (this.responsiveConfig && this.responsiveConfig.responsive_class != null) {\n                                responsiveClass = this.responsiveConfig.responsive_class;\n                            } else if (options.responsive_class != null) {\n                                responsiveClass = options.responsive_class;\n                            } else {\n                                responsiveClass = this.config(\"responsive_class\");\n                            }\n                            var roundDpr = options.round_dpr != null ? options.round_dpr : this.config(\"round_dpr\");\n                            elements.forEach(function(tag) {\n                                if (/img/i.test(tag.tagName)) {\n                                    var setUrl = true;\n                                    if (responsive) {\n                                        lodash_addClass(tag, responsiveClass);\n                                    }\n                                    dataSrc = lodash_getData(tag, \"src-cache\") || lodash_getData(tag, \"src\");\n                                    if (!isEmpty(dataSrc)) {\n                                        // Update dpr according to the device's devicePixelRatio\n                                        dataSrc = updateDpr.call(_this2, dataSrc, roundDpr);\n                                        if (htmltag.isResponsive(tag, responsiveClass)) {\n                                            containerWidth = cloudinary_findContainerWidth(tag);\n                                            if (containerWidth !== 0) {\n                                                if (/w_auto:breakpoints/.test(dataSrc)) {\n                                                    requiredWidth = cloudinary_maxWidth(containerWidth, tag);\n                                                    if (requiredWidth) {\n                                                        dataSrc = dataSrc.replace(/w_auto:breakpoints([_0-9]*)(:[0-9]+)?/, \"w_auto:breakpoints$1:\".concat(requiredWidth));\n                                                    } else {\n                                                        setUrl = false;\n                                                    }\n                                                } else {\n                                                    match = /w_auto(:(\\d+))?/.exec(dataSrc);\n                                                    if (match) {\n                                                        requiredWidth = applyBreakpoints.call(_this2, tag, containerWidth, match[2], options);\n                                                        requiredWidth = cloudinary_maxWidth(requiredWidth, tag);\n                                                        if (requiredWidth) {\n                                                            dataSrc = dataSrc.replace(/w_auto[^,\\/]*/g, \"w_\".concat(requiredWidth));\n                                                        } else {\n                                                            setUrl = false;\n                                                        }\n                                                    }\n                                                }\n                                                lodash_removeAttribute(tag, \"width\");\n                                                if (!options.responsive_preserve_height) {\n                                                    lodash_removeAttribute(tag, \"height\");\n                                                }\n                                            } else {\n                                                // Container doesn't know the size yet - usually because the image is hidden or outside the DOM.\n                                                setUrl = false;\n                                            }\n                                        }\n                                        var isLazyLoading = options.loading === \"lazy\" && !_this2.isNativeLazyLoadSupported() && _this2.isLazyLoadSupported() && !elements[0].getAttribute(\"src\");\n                                        if (setUrl || isLazyLoading) {\n                                            // If data-width exists, set width to be data-width\n                                            _this2.setAttributeIfExists(elements[0], \"width\", \"data-width\");\n                                        }\n                                        if (setUrl && !isLazyLoading) {\n                                            lodash_setAttribute(tag, \"src\", dataSrc);\n                                        }\n                                    }\n                                }\n                            });\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"setAttributeIfExists\",\n                        value: function setAttributeIfExists(element, toAttribute, fromAttribute) {\n                            var attributeValue = element.getAttribute(fromAttribute);\n                            if (attributeValue != null) {\n                                lodash_setAttribute(element, toAttribute, attributeValue);\n                            }\n                        }\n                    },\n                    {\n                        key: \"isLazyLoadSupported\",\n                        value: function isLazyLoadSupported() {\n                            return window && \"IntersectionObserver\" in window;\n                        }\n                    },\n                    {\n                        key: \"isNativeLazyLoadSupported\",\n                        value: function isNativeLazyLoadSupported() {\n                            return \"loading\" in HTMLImageElement.prototype;\n                        }\n                    },\n                    {\n                        key: \"transformation\",\n                        value: function transformation(options) {\n                            return src_transformation[\"new\"](this.config()).fromOptions(options).setParent(this);\n                        }\n                    },\n                    {\n                        key: \"injectTransparentVideoElement\",\n                        value: function injectTransparentVideoElement(htmlElContainer, publicId) {\n                            var _this3 = this;\n                            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                            return new Promise(function(resolve, reject) {\n                                if (!htmlElContainer) {\n                                    reject({\n                                        status: \"error\",\n                                        message: \"Expecting htmlElContainer to be HTMLElement\"\n                                    });\n                                }\n                                transparentVideo_enforceOptionsForTransparentVideo(options);\n                                var videoURL = _this3.video_url(publicId, options);\n                                transparentVideo_checkSupportForTransparency().then(function(isNativelyTransparent) {\n                                    var mountPromise;\n                                    if (isNativelyTransparent) {\n                                        mountPromise = transparentVideo_mountCloudinaryVideoTag(htmlElContainer, _this3, publicId, options);\n                                        resolve(htmlElContainer);\n                                    } else {\n                                        mountPromise = transparentVideo_mountSeeThruCanvasTag(htmlElContainer, videoURL, options);\n                                    }\n                                    mountPromise.then(function() {\n                                        resolve(htmlElContainer);\n                                    })[\"catch\"](function(_ref) {\n                                        var status = _ref.status, message = _ref.message;\n                                        reject({\n                                            status: status,\n                                            message: message\n                                        });\n                                    }); // catch for checkSupportForTransparency()\n                                })[\"catch\"](function(_ref2) {\n                                    var status = _ref2.status, message = _ref2.message;\n                                    reject({\n                                        status: status,\n                                        message: message\n                                    });\n                                });\n                            });\n                        }\n                    }\n                ], [\n                    {\n                        key: \"new\",\n                        value: function _new(options) {\n                            return new this(options);\n                        }\n                    }\n                ]);\n                return Cloudinary;\n            }();\n            assign_root_assign_default()(cloudinary_Cloudinary, constants_namespaceObject);\n            /* harmony default export */ var cloudinary = cloudinary_Cloudinary;\n            // CONCATENATED MODULE: ./src/namespace/cloudinary-core.js\n            /**\n * Creates the namespace for Cloudinary\n */ /* harmony default export */ var cloudinary_core = __nested_webpack_exports__[\"default\"] = {\n                ClientHintsMetaTag: clienthintsmetatag,\n                Cloudinary: cloudinary,\n                Condition: condition,\n                Configuration: src_configuration,\n                crc32: src_crc32,\n                Expression: expression,\n                FetchLayer: fetchlayer,\n                HtmlTag: htmltag,\n                ImageTag: imagetag,\n                Layer: layer_layer,\n                PictureTag: picturetag,\n                SubtitlesLayer: subtitleslayer,\n                TextLayer: textlayer,\n                Transformation: src_transformation,\n                utf8_encode: src_utf8_encode,\n                Util: lodash_namespaceObject,\n                VideoTag: videotag\n            };\n        /***/ },\n        /***/ \"lodash/assign\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_assign__;\n        /***/ },\n        /***/ \"lodash/cloneDeep\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_cloneDeep__;\n        /***/ },\n        /***/ \"lodash/compact\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_compact__;\n        /***/ },\n        /***/ \"lodash/difference\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_difference__;\n        /***/ },\n        /***/ \"lodash/functions\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_functions__;\n        /***/ },\n        /***/ \"lodash/identity\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_identity__;\n        /***/ },\n        /***/ \"lodash/includes\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_includes__;\n        /***/ },\n        /***/ \"lodash/isArray\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isArray__;\n        /***/ },\n        /***/ \"lodash/isElement\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isElement__;\n        /***/ },\n        /***/ \"lodash/isFunction\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isFunction__;\n        /***/ },\n        /***/ \"lodash/isPlainObject\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isPlainObject__;\n        /***/ },\n        /***/ \"lodash/isString\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isString__;\n        /***/ },\n        /***/ \"lodash/merge\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_merge__;\n        /***/ },\n        /***/ \"lodash/trim\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_trim__;\n        /***/ }\n    });\n}); //# sourceMappingURL=cloudinary-core.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2xvdWRpbmFyeS1jb3JlL2Nsb3VkaW5hcnktY29yZS5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7OztHQU1HLEdBQ0YsVUFBU0EsaUNBQWlDQyxJQUFJLEVBQUVDLE9BQU87SUFDdkQsSUFBRyxJQUFpRCxFQUNuREUsT0FBT0QsT0FBTyxHQUFHRCxRQUFRRyxtQkFBT0EsQ0FBQyxvQ0FBZSxHQUFHQSxtQkFBT0EsQ0FBQywwQ0FBa0IsR0FBR0EsbUJBQU9BLENBQUMsc0NBQWdCLEdBQUdBLG1CQUFPQSxDQUFDLDRDQUFtQixHQUFHQSxtQkFBT0EsQ0FBQywwQ0FBa0IsR0FBR0EsbUJBQU9BLENBQUMsd0NBQWlCLEdBQUdBLG1CQUFPQSxDQUFDLHdDQUFpQixHQUFHQSxtQkFBT0EsQ0FBQyxzQ0FBZ0IsR0FBR0EsbUJBQU9BLENBQUMsMENBQWtCLEdBQUdBLG1CQUFPQSxDQUFDLDRDQUFtQixHQUFHQSxtQkFBT0EsQ0FBQyxrREFBc0IsR0FBR0EsbUJBQU9BLENBQUMsd0NBQWlCLEdBQUdBLG1CQUFPQSxDQUFDLGtDQUFjLEdBQUdBLG1CQUFPQSxDQUFDLGdDQUFhO1NBQzNaLEVBSzRWO0FBQ2xXLEdBQUcsUUFBTSxTQUFTRyx5Q0FBeUMsRUFBRUMsNENBQTRDLEVBQUVDLDBDQUEwQyxFQUFFQyw2Q0FBNkMsRUFBRUMsNENBQTRDLEVBQUVDLDJDQUEyQyxFQUFFQywyQ0FBMkMsRUFBRUMsMENBQTBDLEVBQUVDLDRDQUE0QyxFQUFFQyw2Q0FBNkMsRUFBRUMsZ0RBQWdELEVBQUVDLDJDQUEyQyxFQUFFQyx3Q0FBd0MsRUFBRUMsdUNBQXVDO0lBQ3ZvQixPQUFnQixNQUFILEdBQUksU0FBU0MsT0FBTztRQUNqQyxNQUFNLEdBQUksbUJBQW1CO1FBQzdCLE1BQU0sR0FBSSxJQUFJQyxtQkFBbUIsQ0FBQztRQUNsQyxNQUFNLEdBQ04sTUFBTSxHQUFJLHVCQUF1QjtRQUNqQyxNQUFNLEdBQUksU0FBU0MsK0JBQW1CQSxDQUFDQyxR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RWpCLEdBQUcsR0FBRztRQUVOLEdBQUcsR0FBRyxlQUNOLEdBQUcsR0FBSSxTQUFTaEIsT0FBTSxFQUFFRCxRQUFPO1lBRS9CQyxRQUFPRCxPQUFPLEdBQUdrQjtRQUVqQixHQUFHLEdBQUc7SUFFRztBQUNULElBQ0EsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2lyY2hvb2xhci8uL25vZGVfbW9kdWxlcy9jbG91ZGluYXJ5LWNvcmUvY2xvdWRpbmFyeS1jb3JlLmpzP2Y3M2MiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gICAqIGNsb3VkaW5hcnktY29yZS5qc1xuICAgKiBDbG91ZGluYXJ5J3MgSmF2YVNjcmlwdCBsaWJyYXJ5IC0gVmVyc2lvbiAyLjEzLjBcbiAgICogQ29weXJpZ2h0IENsb3VkaW5hcnlcbiAgICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jbG91ZGluYXJ5L2Nsb3VkaW5hcnlfanNcbiAgICpcbiAgICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJsb2Rhc2gvYXNzaWduXCIpLCByZXF1aXJlKFwibG9kYXNoL2Nsb25lRGVlcFwiKSwgcmVxdWlyZShcImxvZGFzaC9jb21wYWN0XCIpLCByZXF1aXJlKFwibG9kYXNoL2RpZmZlcmVuY2VcIiksIHJlcXVpcmUoXCJsb2Rhc2gvZnVuY3Rpb25zXCIpLCByZXF1aXJlKFwibG9kYXNoL2lkZW50aXR5XCIpLCByZXF1aXJlKFwibG9kYXNoL2luY2x1ZGVzXCIpLCByZXF1aXJlKFwibG9kYXNoL2lzQXJyYXlcIiksIHJlcXVpcmUoXCJsb2Rhc2gvaXNFbGVtZW50XCIpLCByZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIiksIHJlcXVpcmUoXCJsb2Rhc2gvaXNQbGFpbk9iamVjdFwiKSwgcmVxdWlyZShcImxvZGFzaC9pc1N0cmluZ1wiKSwgcmVxdWlyZShcImxvZGFzaC9tZXJnZVwiKSwgcmVxdWlyZShcImxvZGFzaC90cmltXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcImxvZGFzaC9hc3NpZ25cIiwgXCJsb2Rhc2gvY2xvbmVEZWVwXCIsIFwibG9kYXNoL2NvbXBhY3RcIiwgXCJsb2Rhc2gvZGlmZmVyZW5jZVwiLCBcImxvZGFzaC9mdW5jdGlvbnNcIiwgXCJsb2Rhc2gvaWRlbnRpdHlcIiwgXCJsb2Rhc2gvaW5jbHVkZXNcIiwgXCJsb2Rhc2gvaXNBcnJheVwiLCBcImxvZGFzaC9pc0VsZW1lbnRcIiwgXCJsb2Rhc2gvaXNGdW5jdGlvblwiLCBcImxvZGFzaC9pc1BsYWluT2JqZWN0XCIsIFwibG9kYXNoL2lzU3RyaW5nXCIsIFwibG9kYXNoL21lcmdlXCIsIFwibG9kYXNoL3RyaW1cIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiY2xvdWRpbmFyeVwiXSA9IGZhY3RvcnkocmVxdWlyZShcImxvZGFzaC9hc3NpZ25cIiksIHJlcXVpcmUoXCJsb2Rhc2gvY2xvbmVEZWVwXCIpLCByZXF1aXJlKFwibG9kYXNoL2NvbXBhY3RcIiksIHJlcXVpcmUoXCJsb2Rhc2gvZGlmZmVyZW5jZVwiKSwgcmVxdWlyZShcImxvZGFzaC9mdW5jdGlvbnNcIiksIHJlcXVpcmUoXCJsb2Rhc2gvaWRlbnRpdHlcIiksIHJlcXVpcmUoXCJsb2Rhc2gvaW5jbHVkZXNcIiksIHJlcXVpcmUoXCJsb2Rhc2gvaXNBcnJheVwiKSwgcmVxdWlyZShcImxvZGFzaC9pc0VsZW1lbnRcIiksIHJlcXVpcmUoXCJsb2Rhc2gvaXNGdW5jdGlvblwiKSwgcmVxdWlyZShcImxvZGFzaC9pc1BsYWluT2JqZWN0XCIpLCByZXF1aXJlKFwibG9kYXNoL2lzU3RyaW5nXCIpLCByZXF1aXJlKFwibG9kYXNoL21lcmdlXCIpLCByZXF1aXJlKFwibG9kYXNoL3RyaW1cIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImNsb3VkaW5hcnlcIl0gPSBmYWN0b3J5KHJvb3RbXCJfXCJdW1wiYXNzaWduXCJdLCByb290W1wiX1wiXVtcImNsb25lRGVlcFwiXSwgcm9vdFtcIl9cIl1bXCJjb21wYWN0XCJdLCByb290W1wiX1wiXVtcImRpZmZlcmVuY2VcIl0sIHJvb3RbXCJfXCJdW1wiZnVuY3Rpb25zXCJdLCByb290W1wiX1wiXVtcImlkZW50aXR5XCJdLCByb290W1wiX1wiXVtcImluY2x1ZGVzXCJdLCByb290W1wiX1wiXVtcImlzQXJyYXlcIl0sIHJvb3RbXCJfXCJdW1wiaXNFbGVtZW50XCJdLCByb290W1wiX1wiXVtcImlzRnVuY3Rpb25cIl0sIHJvb3RbXCJfXCJdW1wiaXNQbGFpbk9iamVjdFwiXSwgcm9vdFtcIl9cIl1bXCJpc1N0cmluZ1wiXSwgcm9vdFtcIl9cIl1bXCJtZXJnZVwiXSwgcm9vdFtcIl9cIl1bXCJ0cmltXCJdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2Fzc2lnbl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9jbG9uZURlZXBfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfY29tcGFjdF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9kaWZmZXJlbmNlX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2Z1bmN0aW9uc19fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pZGVudGl0eV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pbmNsdWRlc19fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc0FycmF5X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzRWxlbWVudF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc0Z1bmN0aW9uX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzUGxhaW5PYmplY3RfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNTdHJpbmdfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfbWVyZ2VfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfdHJpbV9fKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL25hbWVzcGFjZS9jbG91ZGluYXJ5LWNvcmUuanNcIik7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovICh7XG5cbi8qKiovIFwiLi9zcmMvbmFtZXNwYWNlL2Nsb3VkaW5hcnktY29yZS5qc1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8vIEVTTSBDT01QQVQgRkxBR1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuXG4vLyBFWFBPUlRTXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJDbGllbnRIaW50c01ldGFUYWdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBjbGllbnRoaW50c21ldGF0YWc7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiQ2xvdWRpbmFyeVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGNsb3VkaW5hcnk7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiQ29uZGl0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gY29uZGl0aW9uOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkNvbmZpZ3VyYXRpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBzcmNfY29uZmlndXJhdGlvbjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjcmMzMlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIHNyY19jcmMzMjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJFeHByZXNzaW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gZXhwcmVzc2lvbjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJGZXRjaExheWVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gZmV0Y2hsYXllcjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJIdG1sVGFnXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gaHRtbHRhZzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJJbWFnZVRhZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGltYWdldGFnOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkxheWVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gbGF5ZXJfbGF5ZXI7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiUGljdHVyZVRhZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIHBpY3R1cmV0YWc7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiU3VidGl0bGVzTGF5ZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBzdWJ0aXRsZXNsYXllcjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJUZXh0TGF5ZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyB0ZXh0bGF5ZXI7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVHJhbnNmb3JtYXRpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBzcmNfdHJhbnNmb3JtYXRpb247IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwidXRmOF9lbmNvZGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBzcmNfdXRmOF9lbmNvZGU7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVXRpbFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGxvZGFzaF9uYW1lc3BhY2VPYmplY3Q7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVmlkZW9UYWdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyB2aWRlb3RhZzsgfSk7XG5cbi8vIE5BTUVTUEFDRSBPQkpFQ1Q6IC4vc3JjL2NvbnN0YW50cy5qc1xudmFyIGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QgPSB7fTtcbl9fd2VicGFja19yZXF1aXJlX18ucihjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIlZFUlNJT05cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBWRVJTSU9OOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIkNGX1NIQVJFRF9DRE5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBDRl9TSEFSRURfQ0ROOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIk9MRF9BS0FNQUlfU0hBUkVEX0NETlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIE9MRF9BS0FNQUlfU0hBUkVEX0NETjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJBS0FNQUlfU0hBUkVEX0NETlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEFLQU1BSV9TSEFSRURfQ0ROOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIlNIQVJFRF9DRE5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTSEFSRURfQ0ROOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIkRFRkFVTFRfVElNRU9VVF9NU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIERFRkFVTFRfVElNRU9VVF9NUzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJERUZBVUxUX1BPU1RFUl9PUFRJT05TXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gREVGQVVMVF9QT1NURVJfT1BUSU9OUzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJERUZBVUxUX1ZJREVPX1NPVVJDRV9UWVBFU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIERFRkFVTFRfVklERU9fU09VUkNFX1RZUEVTOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIlNFT19UWVBFU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFNFT19UWVBFUzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJERUZBVUxUX0lNQUdFX1BBUkFNU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIERFRkFVTFRfSU1BR0VfUEFSQU1TOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIkRFRkFVTFRfVklERU9fUEFSQU1TXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gREVGQVVMVF9WSURFT19QQVJBTVM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiREVGQVVMVF9WSURFT19TT1VSQ0VTXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gREVGQVVMVF9WSURFT19TT1VSQ0VTOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIkRFRkFVTFRfRVhURVJOQUxfTElCUkFSSUVTXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gREVGQVVMVF9FWFRFUk5BTF9MSUJSQVJJRVM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiUExBQ0VIT0xERVJfSU1BR0VfTU9ERVNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBQTEFDRUhPTERFUl9JTUFHRV9NT0RFUzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJBQ0NFU1NJQklMSVRZX01PREVTXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQUNDRVNTSUJJTElUWV9NT0RFUzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJVUkxfS0VZU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFVSTF9LRVlTOyB9KTtcblxuLy8gTkFNRVNQQUNFIE9CSkVDVDogLi9zcmMvdXRpbC9sb2Rhc2guanNcbnZhciBsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0ID0ge307XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIobG9kYXNoX25hbWVzcGFjZU9iamVjdCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJnZXRTREtBbmFseXRpY3NTaWduYXR1cmVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRTREtBbmFseXRpY3NTaWduYXR1cmU7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiZ2V0QW5hbHl0aWNzT3B0aW9uc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldEFuYWx5dGljc09wdGlvbnM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiYXNzaWduXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJjbG9uZURlZXBcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjbG9uZURlZXBfcm9vdF9jbG9uZURlZXBfZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImNvbXBhY3RcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjb21wYWN0X3Jvb3RfY29tcGFjdF9kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiZGlmZmVyZW5jZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRpZmZlcmVuY2Vfcm9vdF9kaWZmZXJlbmNlX2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJmdW5jdGlvbnNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBmdW5jdGlvbnNfcm9vdF9mdW5jdGlvbnNfZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlkZW50aXR5XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaWRlbnRpdHlfcm9vdF9pZGVudGl0eV9kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaW5jbHVkZXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpbmNsdWRlc19yb290X2luY2x1ZGVzX2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc0FycmF5XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzUGxhaW5PYmplY3RcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNTdHJpbmdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJtZXJnZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG1lcmdlX3Jvb3RfbWVyZ2VfZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImNvbnRhaW5zXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaW5jbHVkZXNfcm9vdF9pbmNsdWRlc19kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNJbnRlcnNlY3Rpb25PYnNlcnZlclN1cHBvcnRlZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzSW50ZXJzZWN0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWQ7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNOYXRpdmVMYXp5TG9hZFN1cHBvcnRlZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzTmF0aXZlTGF6eUxvYWRTdXBwb3J0ZWQ7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiZGV0ZWN0SW50ZXJzZWN0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZGV0ZWN0SW50ZXJzZWN0aW9uOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcIm9taXRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBvbWl0OyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImFsbFN0cmluZ3NcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBiYXNldXRpbF9hbGxTdHJpbmdzOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcIndpdGhvdXRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB3aXRob3V0OyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzTnVtYmVyTGlrZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzTnVtYmVyTGlrZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJzbWFydEVzY2FwZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNtYXJ0RXNjYXBlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImRlZmF1bHRzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZGVmYXVsdHM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwib2JqZWN0UHJvdG9cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBvYmplY3RQcm90bzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJvYmpUb1N0cmluZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG9ialRvU3RyaW5nOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzT2JqZWN0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNPYmplY3Q7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiZnVuY1RhZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZ1bmNUYWc7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwicmVXb3Jkc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHJlV29yZHM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiY2FtZWxDYXNlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY2FtZWxDYXNlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcInNuYWtlQ2FzZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNuYWtlQ2FzZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJjb252ZXJ0S2V5c1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNvbnZlcnRLZXlzOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcIndpdGhDYW1lbENhc2VLZXlzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gd2l0aENhbWVsQ2FzZUtleXM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwid2l0aFNuYWtlQ2FzZUtleXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB3aXRoU25ha2VDYXNlS2V5czsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJiYXNlNjRFbmNvZGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBiYXNlNjRFbmNvZGU7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiYmFzZTY0RW5jb2RlVVJMXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYmFzZTY0RW5jb2RlVVJMOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImV4dHJhY3RVcmxQYXJhbXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBleHRyYWN0VXJsUGFyYW1zOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcInBhdGNoRmV0Y2hGb3JtYXRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBwYXRjaEZldGNoRm9ybWF0OyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcIm9wdGlvbkNvbnN1bWVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBvcHRpb25Db25zdW1lOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzRW1wdHlcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0VtcHR5OyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzQW5kcm9pZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzQW5kcm9pZDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc0VkZ2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0VkZ2U7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNDaHJvbWVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0Nocm9tZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc1NhZmFyaVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzU2FmYXJpOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzRWxlbWVudFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzRWxlbWVudF9yb290X2lzRWxlbWVudF9kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNGdW5jdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJ0cmltXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJpbV9yb290X3RyaW1fZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImdldERhdGFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsb2Rhc2hfZ2V0RGF0YTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJzZXREYXRhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbG9kYXNoX3NldERhdGE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiZ2V0QXR0cmlidXRlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbG9kYXNoX2dldEF0dHJpYnV0ZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJzZXRBdHRyaWJ1dGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsb2Rhc2hfc2V0QXR0cmlidXRlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcInJlbW92ZUF0dHJpYnV0ZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGxvZGFzaF9yZW1vdmVBdHRyaWJ1dGU7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwic2V0QXR0cmlidXRlc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNldEF0dHJpYnV0ZXM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaGFzQ2xhc3NcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsb2Rhc2hfaGFzQ2xhc3M7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiYWRkQ2xhc3NcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsb2Rhc2hfYWRkQ2xhc3M7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiZ2V0U3R5bGVzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0U3R5bGVzOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImNzc0V4cGFuZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNzc0V4cGFuZDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJkb21TdHlsZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRvbVN0eWxlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImN1ckNTU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGN1ckNTUzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJjc3NWYWx1ZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNzc1ZhbHVlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImF1Z21lbnRXaWR0aE9ySGVpZ2h0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXVnbWVudFdpZHRoT3JIZWlnaHQ7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiZ2V0V2lkdGhPckhlaWdodFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldFdpZHRoT3JIZWlnaHQ7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwid2lkdGhcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsb2Rhc2hfd2lkdGg7IH0pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGY4X2VuY29kZS5qc1xuLyoqXG4gKiBVVEY4IGVuY29kZXJcbiAqIEBwcml2YXRlXG4gKi9cbnZhciB1dGY4X2VuY29kZTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNyY191dGY4X2VuY29kZSA9ICh1dGY4X2VuY29kZSA9IGZ1bmN0aW9uIHV0ZjhfZW5jb2RlKGFyZ1N0cmluZykge1xuICB2YXIgYzEsIGVuYywgZW5kLCBuLCBzdGFydCwgc3RyaW5nLCBzdHJpbmdsLCB1dGZ0ZXh0OyAvLyBodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldFxuICAvLyArICAgb3JpZ2luYWwgYnk6IFdlYnRvb2xraXQuaW5mbyAoaHR0cDovL3d3dy53ZWJ0b29sa2l0LmluZm8vKVxuICAvLyArICAgaW1wcm92ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxuICAvLyArICAgaW1wcm92ZWQgYnk6IHNvd2JlcnJ5XG4gIC8vICsgICAgdHdlYWtlZCBieTogSmFja1xuICAvLyArICAgYnVnZml4ZWQgYnk6IE9ubm8gTWFyc21hblxuICAvLyArICAgaW1wcm92ZWQgYnk6IFl2ZXMgU3VjYWV0XG4gIC8vICsgICBidWdmaXhlZCBieTogT25ubyBNYXJzbWFuXG4gIC8vICsgICBidWdmaXhlZCBieTogVWxyaWNoXG4gIC8vICsgICBidWdmaXhlZCBieTogUmFmYWwgS3VrYXdza2lcbiAgLy8gKyAgIGltcHJvdmVkIGJ5OiBraXJpbGxvaWRcbiAgLy8gKiAgICAgZXhhbXBsZSAxOiB1dGY4X2VuY29kZSgnS2V2aW4gdmFuIFpvbm5ldmVsZCcpO1xuICAvLyAqICAgICByZXR1cm5zIDE6ICdLZXZpbiB2YW4gWm9ubmV2ZWxkJ1xuXG4gIGlmIChhcmdTdHJpbmcgPT09IG51bGwgfHwgdHlwZW9mIGFyZ1N0cmluZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBzdHJpbmcgPSBhcmdTdHJpbmcgKyAnJzsgLy8gLnJlcGxhY2UoL1xcclxcbi9nLCBcIlxcblwiKS5yZXBsYWNlKC9cXHIvZywgXCJcXG5cIik7XG5cbiAgdXRmdGV4dCA9ICcnO1xuICBzdGFydCA9IHZvaWQgMDtcbiAgZW5kID0gdm9pZCAwO1xuICBzdHJpbmdsID0gMDtcbiAgc3RhcnQgPSBlbmQgPSAwO1xuICBzdHJpbmdsID0gc3RyaW5nLmxlbmd0aDtcbiAgbiA9IDA7XG5cbiAgd2hpbGUgKG4gPCBzdHJpbmdsKSB7XG4gICAgYzEgPSBzdHJpbmcuY2hhckNvZGVBdChuKTtcbiAgICBlbmMgPSBudWxsO1xuXG4gICAgaWYgKGMxIDwgMTI4KSB7XG4gICAgICBlbmQrKztcbiAgICB9IGVsc2UgaWYgKGMxID4gMTI3ICYmIGMxIDwgMjA0OCkge1xuICAgICAgZW5jID0gU3RyaW5nLmZyb21DaGFyQ29kZShjMSA+PiA2IHwgMTkyLCBjMSAmIDYzIHwgMTI4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jID0gU3RyaW5nLmZyb21DaGFyQ29kZShjMSA+PiAxMiB8IDIyNCwgYzEgPj4gNiAmIDYzIHwgMTI4LCBjMSAmIDYzIHwgMTI4KTtcbiAgICB9XG5cbiAgICBpZiAoZW5jICE9PSBudWxsKSB7XG4gICAgICBpZiAoZW5kID4gc3RhcnQpIHtcbiAgICAgICAgdXRmdGV4dCArPSBzdHJpbmcuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICB9XG5cbiAgICAgIHV0ZnRleHQgKz0gZW5jO1xuICAgICAgc3RhcnQgPSBlbmQgPSBuICsgMTtcbiAgICB9XG5cbiAgICBuKys7XG4gIH1cblxuICBpZiAoZW5kID4gc3RhcnQpIHtcbiAgICB1dGZ0ZXh0ICs9IHN0cmluZy5zbGljZShzdGFydCwgc3RyaW5nbCk7XG4gIH1cblxuICByZXR1cm4gdXRmdGV4dDtcbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY3JjMzIuanNcblxuLyoqXG4gKiBDUkMzMiBjYWxjdWxhdG9yXG4gKiBEZXBlbmRzIG9uICd1dGY4X2VuY29kZSdcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gVGhlIHN0cmluZyB0byBjYWxjdWxhdGUgdGhlIENSQzMyIGZvci5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5mdW5jdGlvbiBjcmMzMihzdHIpIHtcbiAgdmFyIGNyYywgaSwgaVRvcCwgdGFibGUsIHgsIHk7IC8vIGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0XG4gIC8vICsgICBvcmlnaW5hbCBieTogV2VidG9vbGtpdC5pbmZvIChodHRwOi8vd3d3LndlYnRvb2xraXQuaW5mby8pXG4gIC8vICsgICBpbXByb3ZlZCBieTogVDBic25cbiAgLy8gKyAgIGltcHJvdmVkIGJ5OiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI2NDc5MzUvamF2YXNjcmlwdC1jcmMzMi1mdW5jdGlvbi1hbmQtcGhwLWNyYzMyLW5vdC1tYXRjaGluZ1xuICAvLyAtICAgIGRlcGVuZHMgb246IHV0ZjhfZW5jb2RlXG4gIC8vICogICAgIGV4YW1wbGUgMTogY3JjMzIoJ0tldmluIHZhbiBab25uZXZlbGQnKTtcbiAgLy8gKiAgICAgcmV0dXJucyAxOiAxMjQ5OTkxMjQ5XG5cbiAgc3RyID0gc3JjX3V0ZjhfZW5jb2RlKHN0cik7XG4gIHRhYmxlID0gJzAwMDAwMDAwIDc3MDczMDk2IEVFMEU2MTJDIDk5MDk1MUJBIDA3NkRDNDE5IDcwNkFGNDhGIEU5NjNBNTM1IDlFNjQ5NUEzIDBFREI4ODMyIDc5RENCOEE0IEUwRDVFOTFFIDk3RDJEOTg4IDA5QjY0QzJCIDdFQjE3Q0JEIEU3QjgyRDA3IDkwQkYxRDkxIDFEQjcxMDY0IDZBQjAyMEYyIEYzQjk3MTQ4IDg0QkU0MURFIDFBREFENDdEIDZERERFNEVCIEY0RDRCNTUxIDgzRDM4NUM3IDEzNkM5ODU2IDY0NkJBOEMwIEZENjJGOTdBIDhBNjVDOUVDIDE0MDE1QzRGIDYzMDY2Q0Q5IEZBMEYzRDYzIDhEMDgwREY1IDNCNkUyMEM4IDRDNjkxMDVFIEQ1NjA0MUU0IEEyNjc3MTcyIDNDMDNFNEQxIDRCMDRENDQ3IEQyMEQ4NUZEIEE1MEFCNTZCIDM1QjVBOEZBIDQyQjI5ODZDIERCQkJDOUQ2IEFDQkNGOTQwIDMyRDg2Q0UzIDQ1REY1Qzc1IERDRDYwRENGIEFCRDEzRDU5IDI2RDkzMEFDIDUxREUwMDNBIEM4RDc1MTgwIEJGRDA2MTE2IDIxQjRGNEI1IDU2QjNDNDIzIENGQkE5NTk5IEI4QkRBNTBGIDI4MDJCODlFIDVGMDU4ODA4IEM2MENEOUIyIEIxMEJFOTI0IDJGNkY3Qzg3IDU4Njg0QzExIEMxNjExREFCIEI2NjYyRDNEIDc2REM0MTkwIDAxREI3MTA2IDk4RDIyMEJDIEVGRDUxMDJBIDcxQjE4NTg5IDA2QjZCNTFGIDlGQkZFNEE1IEU4QjhENDMzIDc4MDdDOUEyIDBGMDBGOTM0IDk2MDlBODhFIEUxMEU5ODE4IDdGNkEwREJCIDA4NkQzRDJEIDkxNjQ2Qzk3IEU2NjM1QzAxIDZCNkI1MUY0IDFDNkM2MTYyIDg1NjUzMEQ4IEYyNjIwMDRFIDZDMDY5NUVEIDFCMDFBNTdCIDgyMDhGNEMxIEY1MEZDNDU3IDY1QjBEOUM2IDEyQjdFOTUwIDhCQkVCOEVBIEZDQjk4ODdDIDYyREQxRERGIDE1REEyRDQ5IDhDRDM3Q0YzIEZCRDQ0QzY1IDREQjI2MTU4IDNBQjU1MUNFIEEzQkMwMDc0IEQ0QkIzMEUyIDRBREZBNTQxIDNERDg5NUQ3IEE0RDFDNDZEIEQzRDZGNEZCIDQzNjlFOTZBIDM0NkVEOUZDIEFENjc4ODQ2IERBNjBCOEQwIDQ0MDQyRDczIDMzMDMxREU1IEFBMEE0QzVGIEREMEQ3Q0M5IDUwMDU3MTNDIDI3MDI0MUFBIEJFMEIxMDEwIEM5MEMyMDg2IDU3NjhCNTI1IDIwNkY4NUIzIEI5NjZENDA5IENFNjFFNDlGIDVFREVGOTBFIDI5RDlDOTk4IEIwRDA5ODIyIEM3RDdBOEI0IDU5QjMzRDE3IDJFQjQwRDgxIEI3QkQ1QzNCIEMwQkE2Q0FEIEVEQjg4MzIwIDlBQkZCM0I2IDAzQjZFMjBDIDc0QjFEMjlBIEVBRDU0NzM5IDlERDI3N0FGIDA0REIyNjE1IDczREMxNjgzIEUzNjMwQjEyIDk0NjQzQjg0IDBENkQ2QTNFIDdBNkE1QUE4IEU0MEVDRjBCIDkzMDlGRjlEIDBBMDBBRTI3IDdEMDc5RUIxIEYwMEY5MzQ0IDg3MDhBM0QyIDFFMDFGMjY4IDY5MDZDMkZFIEY3NjI1NzVEIDgwNjU2N0NCIDE5NkMzNjcxIDZFNkIwNkU3IEZFRDQxQjc2IDg5RDMyQkUwIDEwREE3QTVBIDY3REQ0QUNDIEY5QjlERjZGIDhFQkVFRkY5IDE3QjdCRTQzIDYwQjA4RUQ1IEQ2RDZBM0U4IEExRDE5MzdFIDM4RDhDMkM0IDRGREZGMjUyIEQxQkI2N0YxIEE2QkM1NzY3IDNGQjUwNkREIDQ4QjIzNjRCIEQ4MEQyQkRBIEFGMEExQjRDIDM2MDM0QUY2IDQxMDQ3QTYwIERGNjBFRkMzIEE4NjdERjU1IDMxNkU4RUVGIDQ2NjlCRTc5IENCNjFCMzhDIEJDNjY4MzFBIDI1NkZEMkEwIDUyNjhFMjM2IENDMEM3Nzk1IEJCMEI0NzAzIDIyMDIxNkI5IDU1MDUyNjJGIEM1QkEzQkJFIEIyQkQwQjI4IDJCQjQ1QTkyIDVDQjM2QTA0IEMyRDdGRkE3IEI1RDBDRjMxIDJDRDk5RThCIDVCREVBRTFEIDlCNjRDMkIwIEVDNjNGMjI2IDc1NkFBMzlDIDAyNkQ5MzBBIDlDMDkwNkE5IEVCMEUzNjNGIDcyMDc2Nzg1IDA1MDA1NzEzIDk1QkY0QTgyIEUyQjg3QTE0IDdCQjEyQkFFIDBDQjYxQjM4IDkyRDI4RTlCIEU1RDVCRTBEIDdDRENFRkI3IDBCREJERjIxIDg2RDNEMkQ0IEYxRDRFMjQyIDY4RERCM0Y4IDFGREE4MzZFIDgxQkUxNkNEIEY2QjkyNjVCIDZGQjA3N0UxIDE4Qjc0Nzc3IDg4MDg1QUU2IEZGMEY2QTcwIDY2MDYzQkNBIDExMDEwQjVDIDhGNjU5RUZGIEY4NjJBRTY5IDYxNkJGRkQzIDE2NkNDRjQ1IEEwMEFFMjc4IEQ3MEREMkVFIDRFMDQ4MzU0IDM5MDNCM0MyIEE3NjcyNjYxIEQwNjAxNkY3IDQ5Njk0NzREIDNFNkU3N0RCIEFFRDE2QTRBIEQ5RDY1QURDIDQwREYwQjY2IDM3RDgzQkYwIEE5QkNBRTUzIERFQkI5RUM1IDQ3QjJDRjdGIDMwQjVGRkU5IEJEQkRGMjFDIENBQkFDMjhBIDUzQjM5MzMwIDI0QjRBM0E2IEJBRDAzNjA1IENERDcwNjkzIDU0REU1NzI5IDIzRDk2N0JGIEIzNjY3QTJFIEM0NjE0QUI4IDVENjgxQjAyIDJBNkYyQjk0IEI0MEJCRTM3IEMzMEM4RUExIDVBMDVERjFCIDJEMDJFRjhEJztcbiAgY3JjID0gMDtcbiAgeCA9IDA7XG4gIHkgPSAwO1xuICBjcmMgPSBjcmMgXiAtMTtcbiAgaSA9IDA7XG4gIGlUb3AgPSBzdHIubGVuZ3RoO1xuXG4gIHdoaWxlIChpIDwgaVRvcCkge1xuICAgIHkgPSAoY3JjIF4gc3RyLmNoYXJDb2RlQXQoaSkpICYgMHhGRjtcbiAgICB4ID0gJzB4JyArIHRhYmxlLnN1YnN0cih5ICogOSwgOCk7XG4gICAgY3JjID0gY3JjID4+PiA4IF4geDtcbiAgICBpKys7XG4gIH1cblxuICBjcmMgPSBjcmMgXiAtMTsgLy9jb252ZXJ0IHRvIHVuc2lnbmVkIDMyLWJpdCBpbnQgaWYgbmVlZGVkXG5cbiAgaWYgKGNyYyA8IDApIHtcbiAgICBjcmMgKz0gNDI5NDk2NzI5NjtcbiAgfVxuXG4gIHJldHVybiBjcmM7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNyY19jcmMzMiA9IChjcmMzMik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zZGtBbmFseXRpY3Mvc3RyaW5nUGFkLmpzXG5mdW5jdGlvbiBzdHJpbmdQYWQodmFsdWUsIHRhcmdldExlbmd0aCwgcGFkU3RyaW5nKSB7XG4gIHRhcmdldExlbmd0aCA9IHRhcmdldExlbmd0aCA+PiAwOyAvL3RydW5jYXRlIGlmIG51bWJlciBvciBjb252ZXJ0IG5vbi1udW1iZXIgdG8gMDtcblxuICBwYWRTdHJpbmcgPSBTdHJpbmcodHlwZW9mIHBhZFN0cmluZyAhPT0gJ3VuZGVmaW5lZCcgPyBwYWRTdHJpbmcgOiAnICcpO1xuXG4gIGlmICh2YWx1ZS5sZW5ndGggPiB0YXJnZXRMZW5ndGgpIHtcbiAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXRMZW5ndGggPSB0YXJnZXRMZW5ndGggLSB2YWx1ZS5sZW5ndGg7XG5cbiAgICBpZiAodGFyZ2V0TGVuZ3RoID4gcGFkU3RyaW5nLmxlbmd0aCkge1xuICAgICAgcGFkU3RyaW5nICs9IHJlcGVhdFN0cmluZ051bVRpbWVzKHBhZFN0cmluZywgdGFyZ2V0TGVuZ3RoIC8gcGFkU3RyaW5nLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhZFN0cmluZy5zbGljZSgwLCB0YXJnZXRMZW5ndGgpICsgU3RyaW5nKHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXBlYXRTdHJpbmdOdW1UaW1lcyhzdHJpbmcsIHRpbWVzKSB7XG4gIHZhciByZXBlYXRlZFN0cmluZyA9IFwiXCI7XG5cbiAgd2hpbGUgKHRpbWVzID4gMCkge1xuICAgIHJlcGVhdGVkU3RyaW5nICs9IHN0cmluZztcbiAgICB0aW1lcy0tO1xuICB9XG5cbiAgcmV0dXJuIHJlcGVhdGVkU3RyaW5nO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc2RrQW5hbHl0aWNzL2Jhc2U2NE1hcC5qc1xuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5cbnZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbnZhciBiYXNlNjRNYXBfbnVtID0gMDtcbnZhciBtYXAgPSB7fTtcblxuX3RvQ29uc3VtYWJsZUFycmF5KGNoYXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChfY2hhcikge1xuICB2YXIga2V5ID0gYmFzZTY0TWFwX251bS50b1N0cmluZygyKTtcbiAga2V5ID0gc3RyaW5nUGFkKGtleSwgNiwgJzAnKTtcbiAgbWFwW2tleV0gPSBfY2hhcjtcbiAgYmFzZTY0TWFwX251bSsrO1xufSk7XG4vKipcbiAqIE1hcCBvZiBzaXgtYml0IGJpbmFyeSBjb2RlcyB0byBCYXNlNjQgY2hhcmFjdGVyc1xuICovXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgYmFzZTY0TWFwID0gKG1hcCk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zZGtBbmFseXRpY3MvcmV2ZXJzZVZlcnNpb24uanNcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gQSBzZW1WZXIgbGlrZSBzdHJpbmcsIHgueS56IG9yIHgueSBpcyBhbGxvd2VkXG4gKiAgICAgICAgICAgICAgUmV2ZXJzZXMgdGhlIHZlcnNpb24gcG9zaXRpb25zLCB4LnkueiB0dXJucyB0byB6LnkueFxuICogICAgICAgICAgICAgIFBhZHMgZWFjaCBzZWdtZW50IHdpdGggJzAnIHNvIHRoZXkgaGF2ZSBsZW5ndGggb2YgMlxuICogICAgICAgICAgICAgIEV4YW1wbGU6IDEuMi4zIC0+IDAzLjAyLjAxXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VtVmVyIElucHV0IGNhbiBiZSBlaXRoZXIgeC55Lnogb3IgeC55XG4gKiBAcmV0dXJuIHtzdHJpbmd9IGluIHRoZSBmb3JtIG9mIHp6Lnl5Lnh4IChcbiAqL1xuXG5mdW5jdGlvbiByZXZlcnNlVmVyc2lvbihzZW1WZXIpIHtcbiAgaWYgKHNlbVZlci5zcGxpdCgnLicpLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2VtVmVyLCBtdXN0IGhhdmUgYXQgbGVhc3QgdHdvIHNlZ21lbnRzJyk7XG4gIH0gLy8gU3BsaXQgYnkgJy4nLCByZXZlcnNlLCBjcmVhdGUgbmV3IGFycmF5IHdpdGggcGFkZGVkIHZhbHVlcyBhbmQgY29uY2F0IGl0IHRvZ2V0aGVyXG5cblxuICByZXR1cm4gc2VtVmVyLnNwbGl0KCcuJykucmV2ZXJzZSgpLm1hcChmdW5jdGlvbiAoc2VnbWVudCkge1xuICAgIHJldHVybiBzdHJpbmdQYWQoc2VnbWVudCwgMiwgJzAnKTtcbiAgfSkuam9pbignLicpO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc2RrQW5hbHl0aWNzL2VuY29kZVZlcnNpb24uanNcblxuXG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIEVuY29kZXMgYSBzZW1WZXItbGlrZSB2ZXJzaW9uIHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IHNlbVZlciBJbnB1dCBjYW4gYmUgZWl0aGVyIHgueS56IG9yIHgueVxuICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyBidWlsdCBmcm9tIDMgY2hhcmFjdGVycyBvZiB0aGUgYmFzZTY0IHRhYmxlIHRoYXQgZW5jb2RlIHRoZSBzZW1WZXJcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVWZXJzaW9uKHNlbVZlcikge1xuICB2YXIgc3RyUmVzdWx0ID0gJyc7IC8vIHN1cHBvcnQgeC55IG9yIHgueS56IGJ5IHVzaW5nICdwYXJ0cycgYXMgYSB2YXJpYWJsZVxuXG4gIHZhciBwYXJ0cyA9IHNlbVZlci5zcGxpdCgnLicpLmxlbmd0aDtcbiAgdmFyIHBhZGRlZFN0cmluZ0xlbmd0aCA9IHBhcnRzICogNjsgLy8gd2UgcGFkIHRvIGVpdGhlciAxMiBvciAxOCBjaGFyYWN0ZXJzXG4gIC8vIHJldmVyc2UgKGJ1dCBkb24ndCBtaXJyb3IpIHRoZSB2ZXJzaW9uLiAxLjUuMTUgLT4gMTUuNS4xXG4gIC8vIFBhZCB0byB0d28gc3BhY2VzLCAxNS41LjEgLT4gMTUuMDUuMDFcblxuICB2YXIgcGFkZGVkUmV2ZXJzZWRTZW12ZXIgPSByZXZlcnNlVmVyc2lvbihzZW1WZXIpOyAvLyB0dXJuIDE1LjA1LjAxIHRvIGEgc3RyaW5nICcxNTA1MDEnIHRoZW4gdG8gYSBudW1iZXIgMTUwNTAxXG5cbiAgdmFyIG51bSA9IHBhcnNlSW50KHBhZGRlZFJldmVyc2VkU2VtdmVyLnNwbGl0KCcuJykuam9pbignJykpOyAvLyBSZXByZXNlbnQgYXMgYmluYXJ5LCBhZGQgbGVmdCBwYWRkaW5nIHRvIDEyIG9yIDE4IGNoYXJhY3RlcnMuXG4gIC8vIDE1MCw1MDEgLT4gMTAwMTAwMTAxMTExMTAwMTAxXG5cbiAgdmFyIHBhZGRlZEJpbmFyeSA9IG51bS50b1N0cmluZygyKTtcbiAgcGFkZGVkQmluYXJ5ID0gc3RyaW5nUGFkKHBhZGRlZEJpbmFyeSwgcGFkZGVkU3RyaW5nTGVuZ3RoLCAnMCcpOyAvLyBTdG9wIGluIGNhc2UgYW4gaW52YWxpZCB2ZXJzaW9uIG51bWJlciB3YXMgcHJvdmlkZWRcbiAgLy8gcGFkZGVkQmluYXJ5IG11c3QgYmUgYnVpbHQgZnJvbSBzZWN0aW9ucyBvZiA2IGJpdHNcblxuICBpZiAocGFkZGVkQmluYXJ5Lmxlbmd0aCAlIDYgIT09IDApIHtcbiAgICB0aHJvdyAnVmVyc2lvbiBtdXN0IGJlIHNtYWxsZXIgdGhhbiA0My4yMS4yNiknO1xuICB9IC8vIHR1cm4gZXZlcnkgNiBiaXRzIGludG8gYSBjaGFyYWN0ZXIgdXNpbmcgdGhlIGJhc2U2NE1hcFxuXG5cbiAgcGFkZGVkQmluYXJ5Lm1hdGNoKC8uezEsNn0vZykuZm9yRWFjaChmdW5jdGlvbiAoYml0U3RyaW5nKSB7XG4gICAgLy8gY29uc29sZS5sb2coYml0U3RyaW5nKTtcbiAgICBzdHJSZXN1bHQgKz0gYmFzZTY0TWFwW2JpdFN0cmluZ107XG4gIH0pO1xuICByZXR1cm4gc3RyUmVzdWx0O1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc2RrQW5hbHl0aWNzL2dldFNES0FuYWx5dGljc1NpZ25hdHVyZS5qc1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBHZXRzIHRoZSBTREsgc2lnbmF0dXJlIGJ5IGVuY29kaW5nIHRoZSBTREsgdmVyc2lvbiBhbmQgdGVjaCB2ZXJzaW9uXG4gKiBAcGFyYW0ge3tcbiAqICAgIFt0ZWNoVmVyc2lvbl06c3RyaW5nLFxuICogICAgW3Nka1NlbXZlcl06IHN0cmluZyxcbiAqICAgIFtzZGtDb2RlXTogc3RyaW5nLFxuICogICAgW2ZlYXR1cmVdOiBzdHJpbmdcbiAqIH19IGFuYWx5dGljc09wdGlvbnNcbiAqIEByZXR1cm4ge3N0cmluZ30gc2RrQW5hbHl0aWNzU2lnbmF0dXJlXG4gKi9cblxuZnVuY3Rpb24gZ2V0U0RLQW5hbHl0aWNzU2lnbmF0dXJlKCkge1xuICB2YXIgYW5hbHl0aWNzT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgdHJ5IHtcbiAgICB2YXIgdHdvUGFydFZlcnNpb24gPSByZW1vdmVQYXRjaEZyb21TZW12ZXIoYW5hbHl0aWNzT3B0aW9ucy50ZWNoVmVyc2lvbik7XG4gICAgdmFyIGVuY29kZWRTREtWZXJzaW9uID0gZW5jb2RlVmVyc2lvbihhbmFseXRpY3NPcHRpb25zLnNka1NlbXZlcik7XG4gICAgdmFyIGVuY29kZWRUZWNoVmVyc2lvbiA9IGVuY29kZVZlcnNpb24odHdvUGFydFZlcnNpb24pO1xuICAgIHZhciBmZWF0dXJlQ29kZSA9IGFuYWx5dGljc09wdGlvbnMuZmVhdHVyZTtcbiAgICB2YXIgU0RLQ29kZSA9IGFuYWx5dGljc09wdGlvbnMuc2RrQ29kZTtcbiAgICB2YXIgYWxnb1ZlcnNpb24gPSAnQSc7IC8vIFRoZSBhbGdvIHZlcnNpb24gaXMgZGV0ZXJtaW5lZCBoZXJlLCBpdCBzaG91bGQgbm90IGJlIGFuIGFyZ3VtZW50XG5cbiAgICByZXR1cm4gXCJcIi5jb25jYXQoYWxnb1ZlcnNpb24pLmNvbmNhdChTREtDb2RlKS5jb25jYXQoZW5jb2RlZFNES1ZlcnNpb24pLmNvbmNhdChlbmNvZGVkVGVjaFZlcnNpb24pLmNvbmNhdChmZWF0dXJlQ29kZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBFaXRoZXIgU0RLIG9yIE5vZGUgdmVyc2lvbnMgd2VyZSB1bnBhcnNhYmxlXG4gICAgcmV0dXJuICdFJztcbiAgfVxufVxuLyoqXG4gKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyBwYXRjaCB2ZXJzaW9uIGZyb20gdGhlIHNlbXZlciBpZiBpdCBleGlzdHNcbiAqICAgICAgICAgICAgICBUdXJucyB4LnkueiBPUiB4LnkgaW50byB4LnlcbiAqIEBwYXJhbSB7J3gueS56JyB8fCAneC55JyB8fCBzdHJpbmd9IHNlbVZlclN0clxuICovXG5cbmZ1bmN0aW9uIHJlbW92ZVBhdGNoRnJvbVNlbXZlcihzZW1WZXJTdHIpIHtcbiAgdmFyIHBhcnRzID0gc2VtVmVyU3RyLnNwbGl0KCcuJyk7XG4gIHJldHVybiBcIlwiLmNvbmNhdChwYXJ0c1swXSwgXCIuXCIpLmNvbmNhdChwYXJ0c1sxXSk7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zZGtBbmFseXRpY3MvZ2V0QW5hbHl0aWNzT3B0aW9ucy5qc1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gR2V0cyB0aGUgYW5hbHl0aWNzT3B0aW9ucyBmcm9tIG9wdGlvbnMtIHNob3VsZCBpbmNsdWRlIHNka1NlbXZlciwgdGVjaFZlcnNpb24sIHNka0NvZGUsIGFuZCBmZWF0dXJlXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybnMge3tzZGtTZW12ZXI6IChzdHJpbmcpLCBzZGtDb2RlLCBmZWF0dXJlOiBzdHJpbmcsIHRlY2hWZXJzaW9uOiAoc3RyaW5nKX0gfHwge319XG4gKi9cbmZ1bmN0aW9uIGdldEFuYWx5dGljc09wdGlvbnMob3B0aW9ucykge1xuICB2YXIgYW5hbHl0aWNzT3B0aW9ucyA9IHtcbiAgICBzZGtTZW12ZXI6IG9wdGlvbnMuc2RrU2VtdmVyLFxuICAgIHRlY2hWZXJzaW9uOiBvcHRpb25zLnRlY2hWZXJzaW9uLFxuICAgIHNka0NvZGU6IG9wdGlvbnMuc2RrQ29kZSxcbiAgICBmZWF0dXJlOiAnMCdcbiAgfTtcblxuICBpZiAob3B0aW9ucy51cmxBbmFseXRpY3MpIHtcbiAgICBpZiAob3B0aW9ucy5hY2Nlc3NpYmlsaXR5KSB7XG4gICAgICBhbmFseXRpY3NPcHRpb25zLmZlYXR1cmUgPSAnRCc7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubG9hZGluZyA9PT0gJ2xhenknKSB7XG4gICAgICBhbmFseXRpY3NPcHRpb25zLmZlYXR1cmUgPSAnQyc7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgYW5hbHl0aWNzT3B0aW9ucy5mZWF0dXJlID0gJ0EnO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnBsYWNlaG9sZGVyKSB7XG4gICAgICBhbmFseXRpY3NPcHRpb25zLmZlYXR1cmUgPSAnQic7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuYWx5dGljc09wdGlvbnM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJsb2Rhc2gvYXNzaWduXCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9hc3NpZ25cIixcImFtZFwiOlwibG9kYXNoL2Fzc2lnblwiLFwicm9vdFwiOltcIl9cIixcImFzc2lnblwiXX1cbnZhciBhc3NpZ25fcm9vdF9hc3NpZ25fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImxvZGFzaC9hc3NpZ25cIik7XG52YXIgYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGFzc2lnbl9yb290X2Fzc2lnbl8pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJsb2Rhc2gvY2xvbmVEZWVwXCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9jbG9uZURlZXBcIixcImFtZFwiOlwibG9kYXNoL2Nsb25lRGVlcFwiLFwicm9vdFwiOltcIl9cIixcImNsb25lRGVlcFwiXX1cbnZhciBjbG9uZURlZXBfcm9vdF9jbG9uZURlZXBfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImxvZGFzaC9jbG9uZURlZXBcIik7XG52YXIgY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNsb25lRGVlcF9yb290X2Nsb25lRGVlcF8pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJsb2Rhc2gvY29tcGFjdFwiLFwiY29tbW9uanMyXCI6XCJsb2Rhc2gvY29tcGFjdFwiLFwiYW1kXCI6XCJsb2Rhc2gvY29tcGFjdFwiLFwicm9vdFwiOltcIl9cIixcImNvbXBhY3RcIl19XG52YXIgY29tcGFjdF9yb290X2NvbXBhY3RfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImxvZGFzaC9jb21wYWN0XCIpO1xudmFyIGNvbXBhY3Rfcm9vdF9jb21wYWN0X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvbXBhY3Rfcm9vdF9jb21wYWN0Xyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9kaWZmZXJlbmNlXCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9kaWZmZXJlbmNlXCIsXCJhbWRcIjpcImxvZGFzaC9kaWZmZXJlbmNlXCIsXCJyb290XCI6W1wiX1wiLFwiZGlmZmVyZW5jZVwiXX1cbnZhciBkaWZmZXJlbmNlX3Jvb3RfZGlmZmVyZW5jZV8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2RpZmZlcmVuY2VcIik7XG52YXIgZGlmZmVyZW5jZV9yb290X2RpZmZlcmVuY2VfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oZGlmZmVyZW5jZV9yb290X2RpZmZlcmVuY2VfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL2Z1bmN0aW9uc1wiLFwiY29tbW9uanMyXCI6XCJsb2Rhc2gvZnVuY3Rpb25zXCIsXCJhbWRcIjpcImxvZGFzaC9mdW5jdGlvbnNcIixcInJvb3RcIjpbXCJfXCIsXCJmdW5jdGlvbnNcIl19XG52YXIgZnVuY3Rpb25zX3Jvb3RfZnVuY3Rpb25zXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvZnVuY3Rpb25zXCIpO1xudmFyIGZ1bmN0aW9uc19yb290X2Z1bmN0aW9uc19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihmdW5jdGlvbnNfcm9vdF9mdW5jdGlvbnNfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL2lkZW50aXR5XCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9pZGVudGl0eVwiLFwiYW1kXCI6XCJsb2Rhc2gvaWRlbnRpdHlcIixcInJvb3RcIjpbXCJfXCIsXCJpZGVudGl0eVwiXX1cbnZhciBpZGVudGl0eV9yb290X2lkZW50aXR5XyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvaWRlbnRpdHlcIik7XG52YXIgaWRlbnRpdHlfcm9vdF9pZGVudGl0eV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihpZGVudGl0eV9yb290X2lkZW50aXR5Xyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9pbmNsdWRlc1wiLFwiY29tbW9uanMyXCI6XCJsb2Rhc2gvaW5jbHVkZXNcIixcImFtZFwiOlwibG9kYXNoL2luY2x1ZGVzXCIsXCJyb290XCI6W1wiX1wiLFwiaW5jbHVkZXNcIl19XG52YXIgaW5jbHVkZXNfcm9vdF9pbmNsdWRlc18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2luY2x1ZGVzXCIpO1xudmFyIGluY2x1ZGVzX3Jvb3RfaW5jbHVkZXNfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaW5jbHVkZXNfcm9vdF9pbmNsdWRlc18pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJsb2Rhc2gvaXNBcnJheVwiLFwiY29tbW9uanMyXCI6XCJsb2Rhc2gvaXNBcnJheVwiLFwiYW1kXCI6XCJsb2Rhc2gvaXNBcnJheVwiLFwicm9vdFwiOltcIl9cIixcImlzQXJyYXlcIl19XG52YXIgaXNBcnJheV9yb290X2lzQXJyYXlfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImxvZGFzaC9pc0FycmF5XCIpO1xudmFyIGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGlzQXJyYXlfcm9vdF9pc0FycmF5Xyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9pc1BsYWluT2JqZWN0XCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9pc1BsYWluT2JqZWN0XCIsXCJhbWRcIjpcImxvZGFzaC9pc1BsYWluT2JqZWN0XCIsXCJyb290XCI6W1wiX1wiLFwiaXNQbGFpbk9iamVjdFwiXX1cbnZhciBpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2lzUGxhaW5PYmplY3RcIik7XG52YXIgaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL2lzU3RyaW5nXCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9pc1N0cmluZ1wiLFwiYW1kXCI6XCJsb2Rhc2gvaXNTdHJpbmdcIixcInJvb3RcIjpbXCJfXCIsXCJpc1N0cmluZ1wiXX1cbnZhciBpc1N0cmluZ19yb290X2lzU3RyaW5nXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvaXNTdHJpbmdcIik7XG52YXIgaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihpc1N0cmluZ19yb290X2lzU3RyaW5nXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9tZXJnZVwiLFwiY29tbW9uanMyXCI6XCJsb2Rhc2gvbWVyZ2VcIixcImFtZFwiOlwibG9kYXNoL21lcmdlXCIsXCJyb290XCI6W1wiX1wiLFwibWVyZ2VcIl19XG52YXIgbWVyZ2Vfcm9vdF9tZXJnZV8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL21lcmdlXCIpO1xudmFyIG1lcmdlX3Jvb3RfbWVyZ2VfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4obWVyZ2Vfcm9vdF9tZXJnZV8pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJsb2Rhc2gvaXNFbGVtZW50XCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9pc0VsZW1lbnRcIixcImFtZFwiOlwibG9kYXNoL2lzRWxlbWVudFwiLFwicm9vdFwiOltcIl9cIixcImlzRWxlbWVudFwiXX1cbnZhciBpc0VsZW1lbnRfcm9vdF9pc0VsZW1lbnRfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImxvZGFzaC9pc0VsZW1lbnRcIik7XG52YXIgaXNFbGVtZW50X3Jvb3RfaXNFbGVtZW50X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGlzRWxlbWVudF9yb290X2lzRWxlbWVudF8pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJsb2Rhc2gvaXNGdW5jdGlvblwiLFwiY29tbW9uanMyXCI6XCJsb2Rhc2gvaXNGdW5jdGlvblwiLFwiYW1kXCI6XCJsb2Rhc2gvaXNGdW5jdGlvblwiLFwicm9vdFwiOltcIl9cIixcImlzRnVuY3Rpb25cIl19XG52YXIgaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImxvZGFzaC9pc0Z1bmN0aW9uXCIpO1xudmFyIGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC90cmltXCIsXCJjb21tb25qczJcIjpcImxvZGFzaC90cmltXCIsXCJhbWRcIjpcImxvZGFzaC90cmltXCIsXCJyb290XCI6W1wiX1wiLFwidHJpbVwiXX1cbnZhciB0cmltX3Jvb3RfdHJpbV8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL3RyaW1cIik7XG52YXIgdHJpbV9yb290X3RyaW1fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4odHJpbV9yb290X3RyaW1fKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9sYXp5TG9hZC5qc1xuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxuXG4vKlxuICogSW5jbHVkZXMgdXRpbGl0eSBtZXRob2RzIGZvciBsYXp5IGxvYWRpbmcgbWVkaWFcbiAqL1xuXG4vKipcbiAqIENoZWNrIGlmIEludGVyc2VjdGlvbk9ic2VydmVyIGlzIHN1cHBvcnRlZFxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB3aW5kb3cuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaXMgZGVmaW5lZFxuICovXG5mdW5jdGlvbiBpc0ludGVyc2VjdGlvbk9ic2VydmVyU3VwcG9ydGVkKCkge1xuICAvLyBDaGVjayB0aGF0ICdJbnRlcnNlY3Rpb25PYnNlcnZlcicgcHJvcGVydHkgaXMgZGVmaW5lZCBvbiB3aW5kb3dcbiAgcmV0dXJuICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yod2luZG93KSkgPT09IFwib2JqZWN0XCIgJiYgd2luZG93LkludGVyc2VjdGlvbk9ic2VydmVyO1xufVxuLyoqXG4gKiBDaGVjayBpZiBuYXRpdmUgbGF6eSBsb2FkaW5nIGlzIHN1cHBvcnRlZFxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiAnbG9hZGluZycgcHJvcGVydHkgaXMgZGVmaW5lZCBmb3IgSFRNTEltYWdlRWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGlzTmF0aXZlTGF6eUxvYWRTdXBwb3J0ZWQoKSB7XG4gIHJldHVybiAodHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihIVE1MSW1hZ2VFbGVtZW50KSkgPT09IFwib2JqZWN0XCIgJiYgSFRNTEltYWdlRWxlbWVudC5wcm90b3R5cGUubG9hZGluZztcbn1cbi8qKlxuICogQ2FsbHMgb25JbnRlcnNlY3QoKSB3aGVuIGludGVyc2VjdGlvbiBpcyBkZXRlY3RlZCwgb3Igd2hlblxuICogbm8gbmF0aXZlIGxhenkgbG9hZGluZyBvciB3aGVuIEludGVyc2VjdGlvbk9ic2VydmVyIGlzbid0IHN1cHBvcnRlZC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWwgLSB0aGUgZWxlbWVudCB0byBvYnNlcnZlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbkludGVyc2VjdCAtIGNhbGxlZCB3aGVuIHRoZSBnaXZlbiBlbGVtZW50IGlzIGluIHZpZXdcbiAqL1xuXG5mdW5jdGlvbiBkZXRlY3RJbnRlcnNlY3Rpb24oZWwsIG9uSW50ZXJzZWN0KSB7XG4gIHRyeSB7XG4gICAgaWYgKGlzTmF0aXZlTGF6eUxvYWRTdXBwb3J0ZWQoKSB8fCAhaXNJbnRlcnNlY3Rpb25PYnNlcnZlclN1cHBvcnRlZCgpKSB7XG4gICAgICAvLyBSZXR1cm4gaWYgdGhlcmUncyBubyBuZWVkIG9yIHBvc3NpYmlsaXR5IHRvIGRldGVjdCBpbnRlcnNlY3Rpb25cbiAgICAgIG9uSW50ZXJzZWN0KCk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBEZXRlY3QgaW50ZXJzZWN0aW9uIHdpdGggZ2l2ZW4gZWxlbWVudCB1c2luZyBJbnRlcnNlY3Rpb25PYnNlcnZlclxuXG5cbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICAgIGVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgaWYgKGVudHJ5LmlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgb25JbnRlcnNlY3QoKTtcbiAgICAgICAgICBvYnNlcnZlci51bm9ic2VydmUoZW50cnkudGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwge1xuICAgICAgdGhyZXNob2xkOiBbMCwgMC4wMV1cbiAgICB9KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGVsKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIG9uSW50ZXJzZWN0KCk7XG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbnN0YW50cy5qc1xudmFyIFZFUlNJT04gPSBcIjIuNS4wXCI7XG52YXIgQ0ZfU0hBUkVEX0NETiA9IFwiZDNqcGw5MXB4ZXZia2guY2xvdWRmcm9udC5uZXRcIjtcbnZhciBPTERfQUtBTUFJX1NIQVJFRF9DRE4gPSBcImNsb3VkaW5hcnktYS5ha2FtYWloZC5uZXRcIjtcbnZhciBBS0FNQUlfU0hBUkVEX0NETiA9IFwicmVzLmNsb3VkaW5hcnkuY29tXCI7XG52YXIgU0hBUkVEX0NETiA9IEFLQU1BSV9TSEFSRURfQ0ROO1xudmFyIERFRkFVTFRfVElNRU9VVF9NUyA9IDEwMDAwO1xudmFyIERFRkFVTFRfUE9TVEVSX09QVElPTlMgPSB7XG4gIGZvcm1hdDogJ2pwZycsXG4gIHJlc291cmNlX3R5cGU6ICd2aWRlbydcbn07XG52YXIgREVGQVVMVF9WSURFT19TT1VSQ0VfVFlQRVMgPSBbJ3dlYm0nLCAnbXA0JywgJ29ndiddO1xudmFyIFNFT19UWVBFUyA9IHtcbiAgXCJpbWFnZS91cGxvYWRcIjogXCJpbWFnZXNcIixcbiAgXCJpbWFnZS9wcml2YXRlXCI6IFwicHJpdmF0ZV9pbWFnZXNcIixcbiAgXCJpbWFnZS9hdXRoZW50aWNhdGVkXCI6IFwiYXV0aGVudGljYXRlZF9pbWFnZXNcIixcbiAgXCJyYXcvdXBsb2FkXCI6IFwiZmlsZXNcIixcbiAgXCJ2aWRlby91cGxvYWRcIjogXCJ2aWRlb3NcIlxufTtcbi8qKlxuKiBAY29uc3Qge09iamVjdH0gQ2xvdWRpbmFyeS5ERUZBVUxUX0lNQUdFX1BBUkFNU1xuKiBEZWZhdWx0cyB2YWx1ZXMgZm9yIGltYWdlIHBhcmFtZXRlcnMuXG4qXG4qIChQcmV2aW91c2x5IGRlZmluZWQgdXNpbmcgb3B0aW9uX2NvbnN1bWUoKSApXG4gKi9cblxudmFyIERFRkFVTFRfSU1BR0VfUEFSQU1TID0ge1xuICByZXNvdXJjZV90eXBlOiBcImltYWdlXCIsXG4gIHRyYW5zZm9ybWF0aW9uOiBbXSxcbiAgdHlwZTogJ3VwbG9hZCdcbn07XG4vKipcbiogRGVmYXVsdHMgdmFsdWVzIGZvciB2aWRlbyBwYXJhbWV0ZXJzLlxuKiBAY29uc3Qge09iamVjdH0gQ2xvdWRpbmFyeS5ERUZBVUxUX1ZJREVPX1BBUkFNU1xuKiAoUHJldmlvdXNseSBkZWZpbmVkIHVzaW5nIG9wdGlvbl9jb25zdW1lKCkgKVxuICovXG5cbnZhciBERUZBVUxUX1ZJREVPX1BBUkFNUyA9IHtcbiAgZmFsbGJhY2tfY29udGVudDogJycsXG4gIHJlc291cmNlX3R5cGU6IFwidmlkZW9cIixcbiAgc291cmNlX3RyYW5zZm9ybWF0aW9uOiB7fSxcbiAgc291cmNlX3R5cGVzOiBERUZBVUxUX1ZJREVPX1NPVVJDRV9UWVBFUyxcbiAgdHJhbnNmb3JtYXRpb246IFtdLFxuICB0eXBlOiAndXBsb2FkJ1xufTtcbi8qKlxuICogUmVjb21tZW5kZWQgc291cmNlcyBmb3IgdmlkZW8gdGFnXG4gKiBAY29uc3Qge09iamVjdH0gQ2xvdWRpbmFyeS5ERUZBVUxUX1ZJREVPX1NPVVJDRVNcbiAqL1xuXG52YXIgREVGQVVMVF9WSURFT19TT1VSQ0VTID0gW3tcbiAgdHlwZTogXCJtcDRcIixcbiAgY29kZWNzOiBcImhldjFcIixcbiAgdHJhbnNmb3JtYXRpb25zOiB7XG4gICAgdmlkZW9fY29kZWM6IFwiaDI2NVwiXG4gIH1cbn0sIHtcbiAgdHlwZTogXCJ3ZWJtXCIsXG4gIGNvZGVjczogXCJ2cDlcIixcbiAgdHJhbnNmb3JtYXRpb25zOiB7XG4gICAgdmlkZW9fY29kZWM6IFwidnA5XCJcbiAgfVxufSwge1xuICB0eXBlOiBcIm1wNFwiLFxuICB0cmFuc2Zvcm1hdGlvbnM6IHtcbiAgICB2aWRlb19jb2RlYzogXCJhdXRvXCJcbiAgfVxufSwge1xuICB0eXBlOiBcIndlYm1cIixcbiAgdHJhbnNmb3JtYXRpb25zOiB7XG4gICAgdmlkZW9fY29kZWM6IFwiYXV0b1wiXG4gIH1cbn1dO1xudmFyIERFRkFVTFRfRVhURVJOQUxfTElCUkFSSUVTID0ge1xuICBzZWVUaHJ1OiAnaHR0cHM6Ly91bnBrZy5jb20vc2VldGhydUA0L2Rpc3Qvc2VlVGhydS5taW4uanMnXG59O1xuLyoqXG4gKiBQcmVkZWZpbmVkIHBsYWNlaG9sZGVyIHRyYW5zZm9ybWF0aW9uc1xuICogQGNvbnN0IHtPYmplY3R9IENsb3VkaW5hcnkuUExBQ0VIT0xERVJfSU1BR0VfTU9ERVNcbiAqL1xuXG52YXIgUExBQ0VIT0xERVJfSU1BR0VfTU9ERVMgPSB7XG4gICdibHVyJzogW3tcbiAgICBlZmZlY3Q6ICdibHVyOjIwMDAnLFxuICAgIHF1YWxpdHk6IDEsXG4gICAgZmV0Y2hfZm9ybWF0OiAnYXV0bydcbiAgfV0sXG4gIC8vIERlZmF1bHRcbiAgJ3BpeGVsYXRlJzogW3tcbiAgICBlZmZlY3Q6ICdwaXhlbGF0ZScsXG4gICAgcXVhbGl0eTogMSxcbiAgICBmZXRjaF9mb3JtYXQ6ICdhdXRvJ1xuICB9XSxcbiAgLy8gR2VuZXJhdGVzIGEgcGl4ZWwgc2l6ZSBpbWFnZSB3aGljaCBjb2xvciBpcyB0aGUgcHJlZG9taW5hbnQgY29sb3Igb2YgdGhlIG9yaWdpbmFsIGltYWdlLlxuICAncHJlZG9taW5hbnQtY29sb3ItcGl4ZWwnOiBbe1xuICAgIHdpZHRoOiAnaXdfZGl2XzInLFxuICAgIGFzcGVjdF9yYXRpbzogMSxcbiAgICBjcm9wOiAncGFkJyxcbiAgICBiYWNrZ3JvdW5kOiAnYXV0bydcbiAgfSwge1xuICAgIGNyb3A6ICdjcm9wJyxcbiAgICB3aWR0aDogMSxcbiAgICBoZWlnaHQ6IDEsXG4gICAgZ3Jhdml0eTogJ25vcnRoX2Vhc3QnXG4gIH0sIHtcbiAgICBmZXRjaF9mb3JtYXQ6ICdhdXRvJyxcbiAgICBxdWFsaXR5OiAnYXV0bydcbiAgfV0sXG4gIC8vIEdlbmVyYXRlcyBhbiBpbWFnZSB3aGljaCBjb2xvciBpcyB0aGUgcHJlZG9taW5hbnQgY29sb3Igb2YgdGhlIG9yaWdpbmFsIGltYWdlLlxuICAncHJlZG9taW5hbnQtY29sb3InOiBbe1xuICAgIHZhcmlhYmxlczogW1snJGN1cnJXaWR0aCcsICd3J10sIFsnJGN1cnJIZWlnaHQnLCAnaCddXVxuICB9LCB7XG4gICAgd2lkdGg6ICdpd19kaXZfMicsXG4gICAgYXNwZWN0X3JhdGlvOiAxLFxuICAgIGNyb3A6ICdwYWQnLFxuICAgIGJhY2tncm91bmQ6ICdhdXRvJ1xuICB9LCB7XG4gICAgY3JvcDogJ2Nyb3AnLFxuICAgIHdpZHRoOiAxMCxcbiAgICBoZWlnaHQ6IDEwLFxuICAgIGdyYXZpdHk6ICdub3J0aF9lYXN0J1xuICB9LCB7XG4gICAgd2lkdGg6ICckY3VycldpZHRoJyxcbiAgICBoZWlnaHQ6ICckY3VyckhlaWdodCcsXG4gICAgY3JvcDogJ2ZpbGwnXG4gIH0sIHtcbiAgICBmZXRjaF9mb3JtYXQ6ICdhdXRvJyxcbiAgICBxdWFsaXR5OiAnYXV0bydcbiAgfV0sXG4gICd2ZWN0b3JpemUnOiBbe1xuICAgIGVmZmVjdDogJ3ZlY3Rvcml6ZTozOjAuMScsXG4gICAgZmV0Y2hfZm9ybWF0OiAnc3ZnJ1xuICB9XVxufTtcbi8qKlxuICogUHJlZGVmaW5lZCBhY2Nlc3NpYmlsaXR5IHRyYW5zZm9ybWF0aW9uc1xuICogQGNvbnN0IHtPYmplY3R9IENsb3VkaW5hcnkuQUNDRVNTSUJJTElUWV9NT0RFU1xuICovXG5cbnZhciBBQ0NFU1NJQklMSVRZX01PREVTID0ge1xuICBkYXJrbW9kZTogJ3RpbnQ6NzU6YmxhY2snLFxuICBicmlnaHRtb2RlOiAndGludDo1MDp3aGl0ZScsXG4gIG1vbm9jaHJvbWU6ICdncmF5c2NhbGUnLFxuICBjb2xvcmJsaW5kOiAnYXNzaXN0X2NvbG9yYmxpbmQnXG59O1xuLyoqXG4gKiBBIGxpc3Qgb2Yga2V5cyB1c2VkIGJ5IHRoZSB1cmwoKSBmdW5jdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIFVSTF9LRVlTID0gWydhY2Nlc3NpYmlsaXR5JywgJ2FwaV9zZWNyZXQnLCAnYXV0aF90b2tlbicsICdjZG5fc3ViZG9tYWluJywgJ2Nsb3VkX25hbWUnLCAnY25hbWUnLCAnZm9ybWF0JywgJ3BsYWNlaG9sZGVyJywgJ3ByaXZhdGVfY2RuJywgJ3Jlc291cmNlX3R5cGUnLCAnc2VjdXJlJywgJ3NlY3VyZV9jZG5fc3ViZG9tYWluJywgJ3NlY3VyZV9kaXN0cmlidXRpb24nLCAnc2hvcnRlbicsICdzaWduX3VybCcsICdzaWduYXR1cmUnLCAnc3NsX2RldGVjdGVkJywgJ3R5cGUnLCAndXJsX3N1ZmZpeCcsICd1c2Vfcm9vdF9wYXRoJywgJ3ZlcnNpb24nXTtcbi8qKlxuICogVGhlIHJlc291cmNlIHN0b3JhZ2UgdHlwZVxuICogQHR5cGVkZWYgdHlwZVxuICogQGVudW0ge3N0cmluZ31cbiAqIEBwcm9wZXJ0eSAge3N0cmluZ30gJ3VwbG9hZCcgQSByZXNvdXJjZSB1cGxvYWRlZCBkaXJlY3RseSB0byBDbG91ZGluYXJ5XG4gKiBAcHJvcGVydHkgIHtzdHJpbmd9ICdmZXRjaCcgQSByZXNvdXJjZSBmZXRjaGVkIGJ5IENsb3VkaW5hcnkgZnJvbSBhIDNyZCBwYXJ0eSBzdG9yYWdlXG4gKiBAcHJvcGVydHkgIHtzdHJpbmd9ICdwcml2YXRlJ1xuICogQHByb3BlcnR5ICB7c3RyaW5nfSAnYXV0aGVudGljYXRlZCdcbiAqIEBwcm9wZXJ0eSAge3N0cmluZ30gJ3Nwcml0ZSdcbiAqIEBwcm9wZXJ0eSAge3N0cmluZ30gJ2ZhY2Vib29rJ1xuICogQHByb3BlcnR5ICB7c3RyaW5nfSAndHdpdHRlcidcbiAqIEBwcm9wZXJ0eSAge3N0cmluZ30gJ3lvdXR1YmUnXG4gKiBAcHJvcGVydHkgIHtzdHJpbmd9ICd2aW1lbydcbiAqXG4gKi9cblxuLyoqXG4gKiBUaGUgcmVzb3VyY2UgdHlwZVxuICogQHR5cGVkZWYgcmVzb3VyY2VUeXBlXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQHByb3BlcnR5IHtzdHJpbmd9ICdpbWFnZScgQW4gaW1hZ2UgZmlsZVxuICogQHByb3BlcnR5IHtzdHJpbmd9ICd2aWRlbycgQSB2aWRlbyBmaWxlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gJ3JhdycgICBBIHJhdyBmaWxlXG4gKi9cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvYmFzZXV0aWwuanNcbmZ1bmN0aW9uIGJhc2V1dGlsX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gYmFzZXV0aWxfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgYmFzZXV0aWxfdHlwZW9mKG9iaik7IH1cblxuLypcbiAqIEluY2x1ZGVzIGNvbW1vbiB1dGlsaXR5IG1ldGhvZHMgYW5kIHNoaW1zXG4gKi9cblxuXG5mdW5jdGlvbiBvbWl0KG9iaiwga2V5cykge1xuICBvYmogPSBvYmogfHwge307XG4gIHZhciBzcmNLZXlzID0gT2JqZWN0LmtleXMob2JqKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhaW5jbHVkZXNfcm9vdF9pbmNsdWRlc19kZWZhdWx0KCkoa2V5cywga2V5KTtcbiAgfSk7XG4gIHZhciBmaWx0ZXJlZCA9IHt9O1xuICBzcmNLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBmaWx0ZXJlZFtrZXldID0gb2JqW2tleV07XG4gIH0pO1xuICByZXR1cm4gZmlsdGVyZWQ7XG59XG4vKipcbiAqIFJldHVybiB0cnVlIGlmIGFsbCBpdGVtcyBpbiBsaXN0IGFyZSBzdHJpbmdzXG4gKiBAZnVuY3Rpb24gVXRpbC5hbGxTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgLSBhbiBhcnJheSBvZiBpdGVtc1xuICovXG5cbnZhciBiYXNldXRpbF9hbGxTdHJpbmdzID0gZnVuY3Rpb24gYWxsU3RyaW5ncyhsaXN0KSB7XG4gIHJldHVybiBsaXN0Lmxlbmd0aCAmJiBsaXN0LmV2ZXJ5KGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdC5hKTtcbn07XG4vKipcbiogQ3JlYXRlcyBhIG5ldyBhcnJheSB3aXRob3V0IHRoZSBnaXZlbiBpdGVtLlxuKiBAZnVuY3Rpb24gVXRpbC53aXRob3V0XG4qIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gb3JpZ2luYWwgYXJyYXlcbiogQHBhcmFtIHsqfSBpdGVtIC0gdGhlIGl0ZW0gdG8gZXhjbHVkZSBmcm9tIHRoZSBuZXcgYXJyYXlcbiogQHJldHVybiB7QXJyYXl9IGEgbmV3IGFycmF5IG1hZGUgb2YgdGhlIG9yaWdpbmFsIGFycmF5J3MgaXRlbXMgZXhjZXB0IGZvciBgaXRlbWBcbiAqL1xuXG52YXIgd2l0aG91dCA9IGZ1bmN0aW9uIHdpdGhvdXQoYXJyYXksIGl0ZW0pIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcihmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB2ICE9PSBpdGVtO1xuICB9KTtcbn07XG4vKipcbiogUmV0dXJuIHRydWUgaXMgdmFsdWUgaXMgYSBudW1iZXIgb3IgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBudW1iZXIuXG4qIEBmdW5jdGlvbiBVdGlsLmlzTnVtYmVyTGlrZVxuKiBAcGFyYW0geyp9IHZhbHVlXG4qIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHZhbHVlIGlzIGEgbnVtYmVyXG4qIEBleGFtcGxlXG4qICAgIFV0aWwuaXNOdW1iZXIoMCkgLy8gdHJ1ZVxuKiAgICBVdGlsLmlzTnVtYmVyKFwiMS4zXCIpIC8vIHRydWVcbiogICAgVXRpbC5pc051bWJlcihcIlwiKSAvLyBmYWxzZVxuKiAgICBVdGlsLmlzTnVtYmVyKHVuZGVmaW5lZCkgLy8gZmFsc2VcbiAqL1xuXG52YXIgaXNOdW1iZXJMaWtlID0gZnVuY3Rpb24gaXNOdW1iZXJMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICFpc05hTihwYXJzZUZsb2F0KHZhbHVlKSk7XG59O1xuLyoqXG4gKiBFc2NhcGUgYWxsIGNoYXJhY3RlcnMgbWF0Y2hpbmcgdW5zYWZlIGluIHRoZSBnaXZlbiBzdHJpbmdcbiAqIEBmdW5jdGlvbiBVdGlsLnNtYXJ0RXNjYXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIC0gc291cmNlIHN0cmluZyB0byBlc2NhcGVcbiAqIEBwYXJhbSB7UmVnRXhwfSB1bnNhZmUgLSBjaGFyYWN0ZXJzIHRoYXQgbXVzdCBiZSBlc2NhcGVkXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGVzY2FwZWQgc3RyaW5nXG4gKi9cblxudmFyIHNtYXJ0RXNjYXBlID0gZnVuY3Rpb24gc21hcnRFc2NhcGUoc3RyaW5nKSB7XG4gIHZhciB1bnNhZmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IC8oW15hLXpBLVowLTlfLlxcLVxcLzpdKykvZztcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHVuc2FmZSwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIG1hdGNoLnNwbGl0KFwiXCIpLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIFwiJVwiICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIH0pLmpvaW4oXCJcIik7XG4gIH0pO1xufTtcbi8qKlxuICogQXNzaWduIHZhbHVlcyBmcm9tIHNvdXJjZXMgaWYgdGhleSBhcmUgbm90IGRlZmluZWQgaW4gdGhlIGRlc3RpbmF0aW9uLlxuICogT25jZSBhIHZhbHVlIGlzIHNldCBpdCBkb2VzIG5vdCBjaGFuZ2VcbiAqIEBmdW5jdGlvbiBVdGlsLmRlZmF1bHRzXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdGluYXRpb24gLSB0aGUgb2JqZWN0IHRvIGFzc2lnbiBkZWZhdWx0cyB0b1xuICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZSAtIHRoZSBzb3VyY2Ugb2JqZWN0KHMpIHRvIGFzc2lnbiBkZWZhdWx0cyBmcm9tXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlc3RpbmF0aW9uIGFmdGVyIGl0IHdhcyBtb2RpZmllZFxuICovXG5cbnZhciBkZWZhdWx0cyA9IGZ1bmN0aW9uIGRlZmF1bHRzKGRlc3RpbmF0aW9uKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzb3VyY2VzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBzb3VyY2VzLnJlZHVjZShmdW5jdGlvbiAoZGVzdCwgc291cmNlKSB7XG4gICAgdmFyIGtleSwgdmFsdWU7XG5cbiAgICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIHZhbHVlID0gc291cmNlW2tleV07XG5cbiAgICAgIGlmIChkZXN0W2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgICBkZXN0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGVzdDtcbiAgfSwgZGVzdGluYXRpb24pO1xufTtcbi8qKioqKioqKioqKiBsb2Rhc2ggZnVuY3Rpb25zICovXG5cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cblxudmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBbbGFuZ3VhZ2UgdHlwZV0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OCkgb2YgYE9iamVjdGAuXG4gKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4jaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiNpc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiNpc09iamVjdCgxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cblxudmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGU7IC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gIHR5cGUgPSBiYXNldXRpbF90eXBlb2YodmFsdWUpO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJyk7XG59O1xudmFyIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuLyoqXG4qIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiogQGZ1bmN0aW9uIFV0aWwuaXNGdW5jdGlvblxuKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiogQGV4YW1wbGVcbipcbiogZnVuY3Rpb24gRm9vKCl7fTtcbiogaXNGdW5jdGlvbihGb28pO1xuKiAvLyA9PiB0cnVlXG4qXG4qIGlzRnVuY3Rpb24oL2FiYy8pO1xuKiAvLyA9PiBmYWxzZVxuICovXG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmkgd2hpY2ggcmV0dXJuICdmdW5jdGlvbicgZm9yIHJlZ2V4ZXNcbiAgLy8gYW5kIFNhZmFyaSA4IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9ycy5cbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gZnVuY1RhZztcbn07XG4vKioqKioqKioqKiogbG9kYXNoIGZ1bmN0aW9ucyAqL1xuXG4vKiogVXNlZCB0byBtYXRjaCB3b3JkcyB0byBjcmVhdGUgY29tcG91bmQgd29yZHMuICovXG5cbnZhciByZVdvcmRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbG93ZXIsIHVwcGVyO1xuICB1cHBlciA9ICdbQS1aXSc7XG4gIGxvd2VyID0gJ1thLXpdKyc7XG4gIHJldHVybiBSZWdFeHAodXBwZXIgKyAnKyg/PScgKyB1cHBlciArIGxvd2VyICsgJyl8JyArIHVwcGVyICsgJz8nICsgbG93ZXIgKyAnfCcgKyB1cHBlciArICcrfFswLTldKycsICdnJyk7XG59KCk7XG4vKipcbiogQ29udmVydCBzdHJpbmcgdG8gY2FtZWxDYXNlXG4qIEBmdW5jdGlvbiBVdGlsLmNhbWVsQ2FzZVxuKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIC0gdGhlIHN0cmluZyB0byBjb252ZXJ0XG4qIEByZXR1cm4ge3N0cmluZ30gaW4gY2FtZWxDYXNlIGZvcm1hdFxuICovXG5cbnZhciBjYW1lbENhc2UgPSBmdW5jdGlvbiBjYW1lbENhc2Uoc291cmNlKSB7XG4gIHZhciB3b3JkcyA9IHNvdXJjZS5tYXRjaChyZVdvcmRzKTtcbiAgd29yZHMgPSB3b3Jkcy5tYXAoZnVuY3Rpb24gKHdvcmQpIHtcbiAgICByZXR1cm4gd29yZC5jaGFyQXQoMCkudG9Mb2NhbGVVcHBlckNhc2UoKSArIHdvcmQuc2xpY2UoMSkudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgfSk7XG4gIHdvcmRzWzBdID0gd29yZHNbMF0udG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgcmV0dXJuIHdvcmRzLmpvaW4oJycpO1xufTtcbi8qKlxuICogQ29udmVydCBzdHJpbmcgdG8gc25ha2VfY2FzZVxuICogQGZ1bmN0aW9uIFV0aWwuc25ha2VDYXNlXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIC0gdGhlIHN0cmluZyB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIHtzdHJpbmd9IGluIHNuYWtlX2Nhc2UgZm9ybWF0XG4gKi9cblxudmFyIHNuYWtlQ2FzZSA9IGZ1bmN0aW9uIHNuYWtlQ2FzZShzb3VyY2UpIHtcbiAgdmFyIHdvcmRzID0gc291cmNlLm1hdGNoKHJlV29yZHMpO1xuICB3b3JkcyA9IHdvcmRzLm1hcChmdW5jdGlvbiAod29yZCkge1xuICAgIHJldHVybiB3b3JkLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gIH0pO1xuICByZXR1cm4gd29yZHMuam9pbignXycpO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBvYmplY3QgZnJvbSBzb3VyY2UsIHdpdGggdGhlIGtleXMgdHJhbnNmb3JtZWQgdXNpbmcgdGhlIGNvbnZlcnRlci5cbiAqIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb258bnVsbH0gY29udmVydGVyXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5cbnZhciBjb252ZXJ0S2V5cyA9IGZ1bmN0aW9uIGNvbnZlcnRLZXlzKHNvdXJjZSwgY29udmVydGVyKSB7XG4gIHZhciByZXN1bHQsIHZhbHVlO1xuICByZXN1bHQgPSB7fTtcblxuICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgdmFsdWUgPSBzb3VyY2Vba2V5XTtcblxuICAgIGlmIChjb252ZXJ0ZXIpIHtcbiAgICAgIGtleSA9IGNvbnZlcnRlcihrZXkpO1xuICAgIH1cblxuICAgIGlmICghaXNFbXB0eShrZXkpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBDcmVhdGUgYSBjb3B5IG9mIHRoZSBzb3VyY2Ugb2JqZWN0IHdpdGggYWxsIGtleXMgaW4gY2FtZWxDYXNlXG4gKiBAZnVuY3Rpb24gVXRpbC53aXRoQ2FtZWxDYXNlS2V5c1xuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIC0gdGhlIG9iamVjdCB0byBjb3B5XG4gKiBAcmV0dXJuIHtPYmplY3R9IGEgbmV3IG9iamVjdFxuICovXG5cbnZhciB3aXRoQ2FtZWxDYXNlS2V5cyA9IGZ1bmN0aW9uIHdpdGhDYW1lbENhc2VLZXlzKHNvdXJjZSkge1xuICByZXR1cm4gY29udmVydEtleXMoc291cmNlLCBjYW1lbENhc2UpO1xufTtcbi8qKlxuICogQ3JlYXRlIGEgY29weSBvZiB0aGUgc291cmNlIG9iamVjdCB3aXRoIGFsbCBrZXlzIGluIHNuYWtlX2Nhc2VcbiAqIEBmdW5jdGlvbiBVdGlsLndpdGhTbmFrZUNhc2VLZXlzXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgLSB0aGUgb2JqZWN0IHRvIGNvcHlcbiAqIEByZXR1cm4ge09iamVjdH0gYSBuZXcgb2JqZWN0XG4gKi9cblxudmFyIHdpdGhTbmFrZUNhc2VLZXlzID0gZnVuY3Rpb24gd2l0aFNuYWtlQ2FzZUtleXMoc291cmNlKSB7XG4gIHJldHVybiBjb252ZXJ0S2V5cyhzb3VyY2UsIHNuYWtlQ2FzZSk7XG59OyAvLyBCcm93c2VyXG4vLyBOb2RlLmpzXG5cbnZhciBiYXNlNjRFbmNvZGUgPSB0eXBlb2YgYnRvYSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNGdW5jdGlvbihidG9hKSA/IGJ0b2EgOiB0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBpc0Z1bmN0aW9uKEJ1ZmZlcikgPyBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgaWYgKCEoaW5wdXQgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgaW5wdXQgPSBuZXcgQnVmZmVyLmZyb20oU3RyaW5nKGlucHV0KSwgJ2JpbmFyeScpO1xuICB9XG5cbiAgcmV0dXJuIGlucHV0LnRvU3RyaW5nKCdiYXNlNjQnKTtcbn0gOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYmFzZTY0IGVuY29kaW5nIGZ1bmN0aW9uIGZvdW5kXCIpO1xufTtcbi8qKlxuKiBSZXR1cm5zIHRoZSBCYXNlNjQtZGVjb2RlZCB2ZXJzaW9uIG9mIHVybC48YnI+XG4qIFRoaXMgbWV0aG9kIGRlbGVnYXRlcyB0byBgYnRvYWAgaWYgcHJlc2VudC4gT3RoZXJ3aXNlIGl0IHRyaWVzIGBCdWZmZXJgLlxuKiBAZnVuY3Rpb24gVXRpbC5iYXNlNjRFbmNvZGVVUkxcbiogQHBhcmFtIHtzdHJpbmd9IHVybCAtIHRoZSB1cmwgdG8gZW5jb2RlLiB0aGUgdmFsdWUgaXMgVVJJZGVjb2RlZCBhbmQgdGhlbiByZS1lbmNvZGVkIGJlZm9yZSBjb252ZXJ0aW5nIHRvIGJhc2U2NCByZXByZXNlbnRhdGlvblxuKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBiYXNlNjQgcmVwcmVzZW50YXRpb24gb2YgdGhlIFVSTFxuICovXG5cbnZhciBiYXNlNjRFbmNvZGVVUkwgPSBmdW5jdGlvbiBiYXNlNjRFbmNvZGVVUkwodXJsKSB7XG4gIHRyeSB7XG4gICAgdXJsID0gZGVjb2RlVVJJKHVybCk7XG4gIH0gZmluYWxseSB7XG4gICAgdXJsID0gZW5jb2RlVVJJKHVybCk7XG4gIH1cblxuICByZXR1cm4gYmFzZTY0RW5jb2RlKHVybCk7XG59O1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgb2JqZWN0IHdpdGggb25seSBVUkwgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgVGhlIHNvdXJjZSBvYmplY3RcbiAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgb25seSBVUkwgcGFyYW1ldGVyc1xuICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RVcmxQYXJhbXMob3B0aW9ucykge1xuICByZXR1cm4gVVJMX0tFWVMucmVkdWNlKGZ1bmN0aW9uIChvYmosIGtleSkge1xuICAgIGlmIChvcHRpb25zW2tleV0gIT0gbnVsbCkge1xuICAgICAgb2JqW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfSwge30pO1xufVxuLyoqXG4gKiBIYW5kbGUgdGhlIGZvcm1hdCBwYXJhbWV0ZXIgZm9yIGZldGNoIHVybHNcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gb3B0aW9ucyB1cmwgYW5kIHRyYW5zZm9ybWF0aW9uIG9wdGlvbnMuIFRoaXMgYXJndW1lbnQgbWF5IGJlIGNoYW5nZWQgYnkgdGhlIGZ1bmN0aW9uIVxuICovXG5cbmZ1bmN0aW9uIHBhdGNoRmV0Y2hGb3JtYXQob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgaWYgKG9wdGlvbnMudHlwZSA9PT0gXCJmZXRjaFwiKSB7XG4gICAgaWYgKG9wdGlvbnMuZmV0Y2hfZm9ybWF0ID09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMuZmV0Y2hfZm9ybWF0ID0gb3B0aW9uQ29uc3VtZShvcHRpb25zLCBcImZvcm1hdFwiKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRGVsZXRlcyBgb3B0aW9uX25hbWVgIGZyb20gYG9wdGlvbnNgIGFuZCByZXR1cm4gdGhlIHZhbHVlIGlmIHByZXNlbnQuXG4gKiBJZiBgb3B0aW9uc2AgZG9lc24ndCBjb250YWluIGBvcHRpb25fbmFtZWAgdGhlIGRlZmF1bHQgdmFsdWUgaXMgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBhIGNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25fbmFtZSB0aGUgbmFtZSAoa2V5KSBvZiB0aGUgZGVzaXJlZCB2YWx1ZVxuICogQHBhcmFtIHsqfSBbZGVmYXVsdF92YWx1ZV0gdGhlIHZhbHVlIHRvIHJldHVybiBpcyBvcHRpb25fbmFtZSBpcyBtaXNzaW5nXG4gKi9cblxuZnVuY3Rpb24gb3B0aW9uQ29uc3VtZShvcHRpb25zLCBvcHRpb25fbmFtZSwgZGVmYXVsdF92YWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb3B0aW9uc1tvcHRpb25fbmFtZV07XG4gIGRlbGV0ZSBvcHRpb25zW29wdGlvbl9uYW1lXTtcblxuICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkZWZhdWx0X3ZhbHVlO1xuICB9XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBlbXB0eTpcbiAqIDx1bD5cbiAqICAgPGxpPnZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkPC9saT5cbiAqICAgPGxpPnZhbHVlIGlzIGFuIGFycmF5IG9yIHN0cmluZyBvZiBsZW5ndGggMDwvbGk+XG4gKiAgIDxsaT52YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBubyBrZXlzPC9saT5cbiAqIDwvdWw+XG4gKiBAZnVuY3Rpb24gVXRpbC5pc0VtcHR5XG4gKiBAcGFyYW0gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHZhbHVlIGlzIGVtcHR5XG4gKi9cblxuZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZS5sZW5ndGggPT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPT09IDA7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlLnNpemUgPT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiB2YWx1ZS5zaXplID09PSAwO1xuICB9XG5cbiAgaWYgKGJhc2V1dGlsX3R5cGVvZih2YWx1ZSkgPT0gXCJvYmplY3RcIikge1xuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL2Jyb3dzZXIuanNcbi8qKlxuICogQmFzZWQgb24gdmlkZW8uanMgaW1wbGVtZW50YXRpb246XG4gKiBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9ibG9iLzQyMzhmNWMxZDg4ODkwNTQ3MTUzZTdlMWRlN2JkMGQxZDhlMGIyMzYvc3JjL2pzL3V0aWxzL2Jyb3dzZXIuanNcbiAqL1xuXG4vKipcbiogUmV0cmlldmUgZnJvbSB0aGUgbmF2aWdhdG9yIHRoZSB1c2VyIGFnZW50IHByb3BlcnR5LlxuKiBAcmV0dXJucyB1c2VyIGFnZW50IHByb3BlcnR5LlxuKi9cbmZ1bmN0aW9uIGdldFVzZXJBZ2VudCgpIHtcbiAgcmV0dXJuIG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnO1xufVxuLyoqXG4gKiBEZXRlY3QgaWYgY3VycmVudCBicm93c2VyIGlzIGFueSBBbmRyb2lkXG4gKiBAcmV0dXJucyB0cnVlIGlmIGN1cnJlbnQgYnJvd3NlciBpcyBBbmRyb2lkLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblxuXG5mdW5jdGlvbiBpc0FuZHJvaWQoKSB7XG4gIHZhciB1c2VyQWdlbnQgPSBnZXRVc2VyQWdlbnQoKTtcbiAgcmV0dXJuIC9BbmRyb2lkL2kudGVzdCh1c2VyQWdlbnQpO1xufVxuLyoqXG4gKiBEZXRlY3QgaWYgY3VycmVudCBicm93c2VyIGlzIGFueSBFZGdlXG4gKiBAcmV0dXJucyB0cnVlIGlmIGN1cnJlbnQgYnJvd3NlciBpcyBFZGdlLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblxuZnVuY3Rpb24gaXNFZGdlKCkge1xuICB2YXIgdXNlckFnZW50ID0gZ2V0VXNlckFnZW50KCk7XG4gIHJldHVybiAvRWRnL2kudGVzdCh1c2VyQWdlbnQpO1xufVxuLyoqXG4gKiBEZXRlY3QgaWYgY3VycmVudCBicm93c2VyIGlzIGNocm9tZS5cbiAqIEByZXR1cm5zIHRydWUgaWYgY3VycmVudCBicm93c2VyIGlzIENocm9tZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmZ1bmN0aW9uIGlzQ2hyb21lKCkge1xuICB2YXIgdXNlckFnZW50ID0gZ2V0VXNlckFnZW50KCk7XG4gIHJldHVybiAhaXNFZGdlKCkgJiYgKC9DaHJvbWUvaS50ZXN0KHVzZXJBZ2VudCkgfHwgL0NyaU9TL2kudGVzdCh1c2VyQWdlbnQpKTtcbn1cbi8qKlxuICogRGV0ZWN0IGlmIGN1cnJlbnQgYnJvd3NlciBpcyBTYWZhcmkuXG4gKiBAcmV0dXJucyB0cnVlIGlmIGN1cnJlbnQgYnJvd3NlciBpcyBTYWZhcmksIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5mdW5jdGlvbiBpc1NhZmFyaSgpIHtcbiAgLy8gVXNlciBhZ2VudHMgZm9yIG90aGVyIGJyb3dzZXJzIG1pZ2h0IGluY2x1ZGUgXCJTYWZhcmlcIiBzbyB3ZSBtdXN0IGV4Y2x1ZGUgdGhlbS5cbiAgLy8gRm9yIGV4YW1wbGUgLSB0aGlzIGlzIHRoZSBjaHJvbWUgdXNlciBhZ2VudCBvbiB3aW5kb3dzIDEwOlxuICAvLyBNb3ppbGxhLzUuMCAoV2luZG93cyBOVCAxMC4wOyBXaW42NDsgeDY0KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvOTYuMC40NjY0LjExMCBTYWZhcmkvNTM3LjM2XG4gIHZhciB1c2VyQWdlbnQgPSBnZXRVc2VyQWdlbnQoKTtcbiAgcmV0dXJuIC9TYWZhcmkvaS50ZXN0KHVzZXJBZ2VudCkgJiYgIWlzQ2hyb21lKCkgJiYgIWlzQW5kcm9pZCgpICYmICFpc0VkZ2UoKTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvbG9kYXNoLmpzXG52YXIgbm9kZUNvbnRhaW5zO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vKlxuICogSW5jbHVkZXMgdXRpbGl0eSBtZXRob2RzIGFuZCBsb2Rhc2ggLyBqUXVlcnkgc2hpbXNcbiAqL1xuXG4vKipcbiAqIEdldCBkYXRhIGZyb20gdGhlIERPTSBlbGVtZW50LlxuICpcbiAqIFRoaXMgbWV0aG9kIHdpbGwgdXNlIGpRdWVyeSdzIGBkYXRhKClgIG1ldGhvZCBpZiBpdCBpcyBhdmFpbGFibGUsIG90aGVyd2lzZSBpdCB3aWxsIGdldCB0aGUgYGRhdGEtYCBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIHRoZSBlbGVtZW50IHRvIGdldCB0aGUgZGF0YSBmcm9tXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBkYXRhIGl0ZW1cbiAqIEByZXR1cm5zIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGBuYW1lYFxuICogQGZ1bmN0aW9uIFV0aWwuZ2V0RGF0YVxuICovXG5cbnZhciBsb2Rhc2hfZ2V0RGF0YSA9IGZ1bmN0aW9uIGdldERhdGEoZWxlbWVudCwgbmFtZSkge1xuICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgY2FzZSAhKGVsZW1lbnQgPT0gbnVsbCk6XG4gICAgICByZXR1cm4gdm9pZCAwO1xuXG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuZ2V0QXR0cmlidXRlKTpcbiAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtXCIuY29uY2F0KG5hbWUpKTtcblxuICAgIGNhc2UgIWlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShlbGVtZW50LmdldEF0dHIpOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cihcImRhdGEtXCIuY29uY2F0KG5hbWUpKTtcblxuICAgIGNhc2UgIWlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShlbGVtZW50LmRhdGEpOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuZGF0YShuYW1lKTtcblxuICAgIGNhc2UgIShpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkodHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZm4gJiYgalF1ZXJ5LmZuLmRhdGEpICYmIGlzRWxlbWVudF9yb290X2lzRWxlbWVudF9kZWZhdWx0KCkoZWxlbWVudCkpOlxuICAgICAgcmV0dXJuIGpRdWVyeShlbGVtZW50KS5kYXRhKG5hbWUpO1xuICB9XG59O1xuLyoqXG4gKiBTZXQgZGF0YSBpbiB0aGUgRE9NIGVsZW1lbnQuXG4gKlxuICogVGhpcyBtZXRob2Qgd2lsbCB1c2UgalF1ZXJ5J3MgYGRhdGEoKWAgbWV0aG9kIGlmIGl0IGlzIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGl0IHdpbGwgc2V0IHRoZSBgZGF0YS1gIGF0dHJpYnV0ZVxuICogQGZ1bmN0aW9uIFV0aWwuc2V0RGF0YVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gdGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBkYXRhIGluXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBkYXRhIGl0ZW1cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gYmUgc2V0XG4gKlxuICovXG5cbnZhciBsb2Rhc2hfc2V0RGF0YSA9IGZ1bmN0aW9uIHNldERhdGEoZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcbiAgc3dpdGNoIChmYWxzZSkge1xuICAgIGNhc2UgIShlbGVtZW50ID09IG51bGwpOlxuICAgICAgcmV0dXJuIHZvaWQgMDtcblxuICAgIGNhc2UgIWlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShlbGVtZW50LnNldEF0dHJpYnV0ZSk6XG4gICAgICByZXR1cm4gZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLVwiLmNvbmNhdChuYW1lKSwgdmFsdWUpO1xuXG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuc2V0QXR0cik6XG4gICAgICByZXR1cm4gZWxlbWVudC5zZXRBdHRyKFwiZGF0YS1cIi5jb25jYXQobmFtZSksIHZhbHVlKTtcblxuICAgIGNhc2UgIWlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShlbGVtZW50LmRhdGEpOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuZGF0YShuYW1lLCB2YWx1ZSk7XG5cbiAgICBjYXNlICEoaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5LmZuICYmIGpRdWVyeS5mbi5kYXRhKSAmJiBpc0VsZW1lbnRfcm9vdF9pc0VsZW1lbnRfZGVmYXVsdCgpKGVsZW1lbnQpKTpcbiAgICAgIHJldHVybiBqUXVlcnkoZWxlbWVudCkuZGF0YShuYW1lLCB2YWx1ZSk7XG4gIH1cbn07XG4vKipcbiAqIEdldCBhdHRyaWJ1dGUgZnJvbSB0aGUgRE9NIGVsZW1lbnQuXG4gKlxuICogQGZ1bmN0aW9uIFV0aWwuZ2V0QXR0cmlidXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGF0dHJpYnV0ZSBmb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICogQHJldHVybnMgeyp9IHRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlXG4gKlxuICovXG5cbnZhciBsb2Rhc2hfZ2V0QXR0cmlidXRlID0gZnVuY3Rpb24gZ2V0QXR0cmlidXRlKGVsZW1lbnQsIG5hbWUpIHtcbiAgc3dpdGNoIChmYWxzZSkge1xuICAgIGNhc2UgIShlbGVtZW50ID09IG51bGwpOlxuICAgICAgcmV0dXJuIHZvaWQgMDtcblxuICAgIGNhc2UgIWlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShlbGVtZW50LmdldEF0dHJpYnV0ZSk6XG4gICAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUobmFtZSk7XG5cbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5hdHRyKTpcbiAgICAgIHJldHVybiBlbGVtZW50LmF0dHIobmFtZSk7XG5cbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5nZXRBdHRyKTpcbiAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHIobmFtZSk7XG4gIH1cbn07XG4vKipcbiAqIFNldCBhdHRyaWJ1dGUgaW4gdGhlIERPTSBlbGVtZW50LlxuICpcbiAqIEBmdW5jdGlvbiBVdGlsLnNldEF0dHJpYnV0ZVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gdGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBhdHRyaWJ1dGUgZm9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gYmUgc2V0XG4gKi9cblxudmFyIGxvZGFzaF9zZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBzZXRBdHRyaWJ1dGUoZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcbiAgc3dpdGNoIChmYWxzZSkge1xuICAgIGNhc2UgIShlbGVtZW50ID09IG51bGwpOlxuICAgICAgcmV0dXJuIHZvaWQgMDtcblxuICAgIGNhc2UgIWlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShlbGVtZW50LnNldEF0dHJpYnV0ZSk6XG4gICAgICByZXR1cm4gZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuXG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuYXR0cik6XG4gICAgICByZXR1cm4gZWxlbWVudC5hdHRyKG5hbWUsIHZhbHVlKTtcblxuICAgIGNhc2UgIWlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShlbGVtZW50LnNldEF0dHIpOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuc2V0QXR0cihuYW1lLCB2YWx1ZSk7XG4gIH1cbn07XG4vKipcbiAqIFJlbW92ZSBhbiBhdHRyaWJ1dGUgaW4gdGhlIERPTSBlbGVtZW50LlxuICpcbiAqIEBmdW5jdGlvbiBVdGlsLnJlbW92ZUF0dHJpYnV0ZVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gdGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBhdHRyaWJ1dGUgZm9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGVcbiAqL1xuXG52YXIgbG9kYXNoX3JlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCBuYW1lKSB7XG4gIHN3aXRjaCAoZmFsc2UpIHtcbiAgICBjYXNlICEoZWxlbWVudCA9PSBudWxsKTpcbiAgICAgIHJldHVybiB2b2lkIDA7XG5cbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUpOlxuICAgICAgcmV0dXJuIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBsb2Rhc2hfc2V0QXR0cmlidXRlKGVsZW1lbnQsIHZvaWQgMCk7XG4gIH1cbn07XG4vKipcbiAqIFNldCBhIGdyb3VwIG9mIGF0dHJpYnV0ZXMgdG8gdGhlIGVsZW1lbnRcbiAqIEBmdW5jdGlvbiBVdGlsLnNldEF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIHRoZSBlbGVtZW50IHRvIHNldCB0aGUgYXR0cmlidXRlcyBmb3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzIC0gYSBoYXNoIG9mIGF0dHJpYnV0ZSBuYW1lcyBhbmQgdmFsdWVzXG4gKi9cblxudmFyIHNldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIGF0dHJpYnV0ZXMpIHtcbiAgdmFyIG5hbWUsIHJlc3VsdHMsIHZhbHVlO1xuICByZXN1bHRzID0gW107XG5cbiAgZm9yIChuYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmVzdWx0cy5wdXNoKGxvZGFzaF9zZXRBdHRyaWJ1dGUoZWxlbWVudCwgbmFtZSwgdmFsdWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0cy5wdXNoKGxvZGFzaF9yZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgbmFtZSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRzO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIGVsZW1lbnQgaGFzIGEgY3NzIGNsYXNzXG4gKiBAZnVuY3Rpb24gVXRpbC5oYXNDbGFzc1xuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gdGhlIGVsZW1lbnQgdG8gY2hlY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIGNsYXNzIG5hbWVcbiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZWxlbWVudCBoYXMgdGhlIGNsYXNzXG4gKi9cblxudmFyIGxvZGFzaF9oYXNDbGFzcyA9IGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnQsIG5hbWUpIHtcbiAgaWYgKGlzRWxlbWVudF9yb290X2lzRWxlbWVudF9kZWZhdWx0KCkoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jbGFzc05hbWUubWF0Y2gobmV3IFJlZ0V4cChcIlxcXFxiXCIuY29uY2F0KG5hbWUsIFwiXFxcXGJcIikpKTtcbiAgfVxufTtcbi8qKlxuICogQWRkIGNsYXNzIHRvIHRoZSBlbGVtZW50XG4gKiBAZnVuY3Rpb24gVXRpbC5hZGRDbGFzc1xuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIGNsYXNzIG5hbWUgdG8gYWRkXG4gKi9cblxudmFyIGxvZGFzaF9hZGRDbGFzcyA9IGZ1bmN0aW9uIGFkZENsYXNzKGVsZW1lbnQsIG5hbWUpIHtcbiAgaWYgKCFlbGVtZW50LmNsYXNzTmFtZS5tYXRjaChuZXcgUmVnRXhwKFwiXFxcXGJcIi5jb25jYXQobmFtZSwgXCJcXFxcYlwiKSkpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NOYW1lID0gdHJpbV9yb290X3RyaW1fZGVmYXVsdCgpKFwiXCIuY29uY2F0KGVsZW1lbnQuY2xhc3NOYW1lLCBcIiBcIikuY29uY2F0KG5hbWUpKTtcbiAgfVxufTsgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGlzIHRha2VuIGZyb20galF1ZXJ5XG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiBnZXRTdHlsZXMoZWxlbSkge1xuICAvLyBTdXBwb3J0OiBJRTw9MTErLCBGaXJlZm94PD0zMCsgKCMxNTA5OCwgIzE0MTUwKVxuICAvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcbiAgLy8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG4gIGlmIChlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcub3BlbmVyKSB7XG4gICAgcmV0dXJuIGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsZW0sIG51bGwpO1xuICB9XG5cbiAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW0sIG51bGwpO1xufTtcbnZhciBjc3NFeHBhbmQgPSBbXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIl07XG5cbm5vZGVDb250YWlucyA9IGZ1bmN0aW9uIG5vZGVDb250YWlucyhhLCBiKSB7XG4gIHZhciBhZG93biwgYnVwO1xuICBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGE7XG4gIGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuICByZXR1cm4gYSA9PT0gYnVwIHx8ICEhKGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgYWRvd24uY29udGFpbnMoYnVwKSk7XG59OyAvLyBUcnVuY2F0ZWQgdmVyc2lvbiBvZiBqUXVlcnkuc3R5bGUoZWxlbSwgbmFtZSlcblxuXG52YXIgZG9tU3R5bGUgPSBmdW5jdGlvbiBkb21TdHlsZShlbGVtLCBuYW1lKSB7XG4gIGlmICghKCFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSkpIHtcbiAgICByZXR1cm4gZWxlbS5zdHlsZVtuYW1lXTtcbiAgfVxufTtcbnZhciBjdXJDU1MgPSBmdW5jdGlvbiBjdXJDU1MoZWxlbSwgbmFtZSwgY29tcHV0ZWQpIHtcbiAgdmFyIG1heFdpZHRoLCBtaW5XaWR0aCwgcmV0LCBybWFyZ2luLCBzdHlsZSwgd2lkdGg7XG4gIHJtYXJnaW4gPSAvXm1hcmdpbi87XG4gIHdpZHRoID0gdm9pZCAwO1xuICBtaW5XaWR0aCA9IHZvaWQgMDtcbiAgbWF4V2lkdGggPSB2b2lkIDA7XG4gIHJldCA9IHZvaWQgMDtcbiAgc3R5bGUgPSBlbGVtLnN0eWxlO1xuICBjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyhlbGVtKTtcblxuICBpZiAoY29tcHV0ZWQpIHtcbiAgICAvLyBTdXBwb3J0OiBJRTlcbiAgICAvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG9ubHkgbmVlZGVkIGZvciAuY3NzKCdmaWx0ZXInKSAoIzEyNTM3KVxuICAgIHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUobmFtZSkgfHwgY29tcHV0ZWRbbmFtZV07XG4gIH1cblxuICBpZiAoY29tcHV0ZWQpIHtcbiAgICBpZiAocmV0ID09PSBcIlwiICYmICFub2RlQ29udGFpbnMoZWxlbS5vd25lckRvY3VtZW50LCBlbGVtKSkge1xuICAgICAgcmV0ID0gZG9tU3R5bGUoZWxlbSwgbmFtZSk7XG4gICAgfSAvLyBTdXBwb3J0OiBpT1MgPCA2XG4gICAgLy8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuICAgIC8vIGlPUyA8IDYgKGF0IGxlYXN0KSByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIGEgbGFyZ2VyIHNldCBvZiB2YWx1ZXMsIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHNcbiAgICAvLyB0aGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6IGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblxuXG4gICAgaWYgKHJudW1ub25weC50ZXN0KHJldCkgJiYgcm1hcmdpbi50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG4gICAgICB3aWR0aCA9IHN0eWxlLndpZHRoO1xuICAgICAgbWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcbiAgICAgIG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7IC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblxuICAgICAgc3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuICAgICAgcmV0ID0gY29tcHV0ZWQud2lkdGg7IC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblxuICAgICAgc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgIHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG4gICAgICBzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgIH1cbiAgfSAvLyBTdXBwb3J0OiBJRVxuICAvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXG5cbiAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJldCArIFwiXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxufTtcbnZhciBjc3NWYWx1ZSA9IGZ1bmN0aW9uIGNzc1ZhbHVlKGVsZW0sIG5hbWUsIGNvbnZlcnQsIHN0eWxlcykge1xuICB2YXIgdmFsO1xuICB2YWwgPSBjdXJDU1MoZWxlbSwgbmFtZSwgc3R5bGVzKTtcblxuICBpZiAoY29udmVydCkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxufTtcbnZhciBhdWdtZW50V2lkdGhPckhlaWdodCA9IGZ1bmN0aW9uIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KGVsZW0sIG5hbWUsIGV4dHJhLCBpc0JvcmRlckJveCwgc3R5bGVzKSB7XG4gIHZhciBpLCBsZW4sIHNpZGUsIHNpZGVzLCB2YWw7IC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgbWVhc3VyZW1lbnQsIGF2b2lkIGF1Z21lbnRhdGlvblxuICAvLyBPdGhlcndpc2UgaW5pdGlhbGl6ZSBmb3IgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBwcm9wZXJ0aWVzXG5cbiAgaWYgKGV4dHJhID09PSAoaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSB7XG4gICAgc2lkZXMgPSBuYW1lID09PSBcIndpZHRoXCIgPyBbXCJSaWdodFwiLCBcIkxlZnRcIl0gOiBbXCJUb3BcIiwgXCJCb3R0b21cIl07XG4gICAgdmFsID0gMDtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHNpZGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzaWRlID0gc2lkZXNbaV07XG5cbiAgICAgIGlmIChleHRyYSA9PT0gXCJtYXJnaW5cIikge1xuICAgICAgICAvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW4sIHNvIGFkZCBpdCBpZiB3ZSB3YW50IGl0XG4gICAgICAgIHZhbCArPSBjc3NWYWx1ZShlbGVtLCBleHRyYSArIHNpZGUsIHRydWUsIHN0eWxlcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0JvcmRlckJveCkge1xuICAgICAgICBpZiAoZXh0cmEgPT09IFwiY29udGVudFwiKSB7XG4gICAgICAgICAgLy8gYm9yZGVyLWJveCBpbmNsdWRlcyBwYWRkaW5nLCBzbyByZW1vdmUgaXQgaWYgd2Ugd2FudCBjb250ZW50XG4gICAgICAgICAgdmFsIC09IGNzc1ZhbHVlKGVsZW0sIFwicGFkZGluZ1wiLmNvbmNhdChzaWRlKSwgdHJ1ZSwgc3R5bGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHRyYSAhPT0gXCJtYXJnaW5cIikge1xuICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGJvcmRlciBub3IgbWFyZ2luLCBzbyByZW1vdmUgYm9yZGVyXG4gICAgICAgICAgdmFsIC09IGNzc1ZhbHVlKGVsZW0sIFwiYm9yZGVyXCIuY29uY2F0KHNpZGUsIFwiV2lkdGhcIiksIHRydWUsIHN0eWxlcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQsIHNvIGFkZCBwYWRkaW5nXG4gICAgICAgIHZhbCArPSBjc3NWYWx1ZShlbGVtLCBcInBhZGRpbmdcIi5jb25jYXQoc2lkZSksIHRydWUsIHN0eWxlcyk7XG5cbiAgICAgICAgaWYgKGV4dHJhICE9PSBcInBhZGRpbmdcIikge1xuICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQgbm9yIHBhZGRpbmcsIHNvIGFkZCBib3JkZXJcbiAgICAgICAgICB2YWwgKz0gY3NzVmFsdWUoZWxlbSwgXCJib3JkZXJcIi5jb25jYXQoc2lkZSwgXCJXaWR0aFwiKSwgdHJ1ZSwgc3R5bGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG4gIH1cbn07XG52YXIgcG51bSA9IC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvLnNvdXJjZTtcbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIik7XG52YXIgZ2V0V2lkdGhPckhlaWdodCA9IGZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoZWxlbSwgbmFtZSwgZXh0cmEpIHtcbiAgdmFyIGlzQm9yZGVyQm94LCBzdHlsZXMsIHZhbCwgdmFsdWVJc0JvcmRlckJveDsgLy8gU3RhcnQgd2l0aCBvZmZzZXQgcHJvcGVydHksIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGJvcmRlci1ib3ggdmFsdWVcblxuICB2YWx1ZUlzQm9yZGVyQm94ID0gdHJ1ZTtcbiAgdmFsID0gbmFtZSA9PT0gXCJ3aWR0aFwiID8gZWxlbS5vZmZzZXRXaWR0aCA6IGVsZW0ub2Zmc2V0SGVpZ2h0O1xuICBzdHlsZXMgPSBnZXRTdHlsZXMoZWxlbSk7XG4gIGlzQm9yZGVyQm94ID0gY3NzVmFsdWUoZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcykgPT09IFwiYm9yZGVyLWJveFwiOyAvLyBTb21lIG5vbi1odG1sIGVsZW1lbnRzIHJldHVybiB1bmRlZmluZWQgZm9yIG9mZnNldFdpZHRoLCBzbyBjaGVjayBmb3IgbnVsbC91bmRlZmluZWRcbiAgLy8gc3ZnIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjQ5Mjg1XG4gIC8vIE1hdGhNTCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTQ5MTY2OFxuXG4gIGlmICh2YWwgPD0gMCB8fCB2YWwgPT0gbnVsbCkge1xuICAgIC8vIEZhbGwgYmFjayB0byBjb21wdXRlZCB0aGVuIHVuY29tcHV0ZWQgY3NzIGlmIG5lY2Vzc2FyeVxuICAgIHZhbCA9IGN1ckNTUyhlbGVtLCBuYW1lLCBzdHlsZXMpO1xuXG4gICAgaWYgKHZhbCA8IDAgfHwgdmFsID09IG51bGwpIHtcbiAgICAgIHZhbCA9IGVsZW0uc3R5bGVbbmFtZV07XG4gICAgfVxuXG4gICAgaWYgKHJudW1ub25weC50ZXN0KHZhbCkpIHtcbiAgICAgIC8vIENvbXB1dGVkIHVuaXQgaXMgbm90IHBpeGVscy4gU3RvcCBoZXJlIGFuZCByZXR1cm4uXG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0gLy8gQ2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcbiAgICAvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXG4gICAgLy8gICAgdmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94IGFuZCAoc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIG9yIHZhbCBpcyBlbGVtLnN0eWxlW25hbWVdKVxuXG5cbiAgICB2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3ggJiYgdmFsID09PSBlbGVtLnN0eWxlW25hbWVdOyAvLyBOb3JtYWxpemUgXCJcIiwgYXV0bywgYW5kIHByZXBhcmUgZm9yIGV4dHJhXG5cbiAgICB2YWwgPSBwYXJzZUZsb2F0KHZhbCkgfHwgMDtcbiAgfSAvLyBVc2UgdGhlIGFjdGl2ZSBib3gtc2l6aW5nIG1vZGVsIHRvIGFkZC9zdWJ0cmFjdCBpcnJlbGV2YW50IHN0eWxlc1xuXG5cbiAgcmV0dXJuIHZhbCArIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KGVsZW0sIG5hbWUsIGV4dHJhIHx8IChpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiksIHZhbHVlSXNCb3JkZXJCb3gsIHN0eWxlcyk7XG59O1xudmFyIGxvZGFzaF93aWR0aCA9IGZ1bmN0aW9uIHdpZHRoKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoZWxlbWVudCwgXCJ3aWR0aFwiLCBcImNvbnRlbnRcIik7XG59O1xuLyoqXG4gKiBAY2xhc3MgVXRpbFxuICovXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGl0ZW0gaXMgYSBzdHJpbmdcbiAqIEBmdW5jdGlvbiBVdGlsLmlzU3RyaW5nXG4gKiBAcGFyYW0gaXRlbVxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgaXRlbSBpcyBhIHN0cmluZ1xuICovXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGl0ZW0gaXMgZW1wdHk6XG4gKiA8dWw+XG4gKiAgIDxsaT5pdGVtIGlzIG51bGwgb3IgdW5kZWZpbmVkPC9saT5cbiAqICAgPGxpPml0ZW0gaXMgYW4gYXJyYXkgb3Igc3RyaW5nIG9mIGxlbmd0aCAwPC9saT5cbiAqICAgPGxpPml0ZW0gaXMgYW4gb2JqZWN0IHdpdGggbm8ga2V5czwvbGk+XG4gKiA8L3VsPlxuICogQGZ1bmN0aW9uIFV0aWwuaXNFbXB0eVxuICogQHBhcmFtIGl0ZW1cbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGl0ZW0gaXMgZW1wdHlcbiAqL1xuXG4vKipcbiAqIEFzc2lnbiBzb3VyY2UgcHJvcGVydGllcyB0byBkZXN0aW5hdGlvbi5cbiAqIElmIHRoZSBwcm9wZXJ0eSBpcyBhbiBvYmplY3QgaXQgaXMgYXNzaWduZWQgYXMgYSB3aG9sZSwgb3ZlcnJpZGluZyB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQGZ1bmN0aW9uIFV0aWwuYXNzaWduXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdGluYXRpb24gLSB0aGUgb2JqZWN0IHRvIGFzc2lnbiB0b1xuICovXG5cbi8qKlxuICogUmVjdXJzaXZlbHkgYXNzaWduIHNvdXJjZSBwcm9wZXJ0aWVzIHRvIGRlc3RpbmF0aW9uXG4gKiBAZnVuY3Rpb24gVXRpbC5tZXJnZVxuICogQHBhcmFtIHtPYmplY3R9IGRlc3RpbmF0aW9uIC0gdGhlIG9iamVjdCB0byBhc3NpZ24gdG9cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICovXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGNvcHkgb2YgdGhlIGdpdmVuIG9iamVjdCwgaW5jbHVkaW5nIGFsbCBpbnRlcm5hbCBvYmplY3RzLlxuICogQGZ1bmN0aW9uIFV0aWwuY2xvbmVEZWVwXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgLSB0aGUgb2JqZWN0IHRvIGNsb25lXG4gKiBAcmV0dXJuIHtPYmplY3R9IGEgbmV3IGRlZXAgY29weSBvZiB0aGUgb2JqZWN0XG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGFycmF5IGZyb20gdGhlIHBhcmFtZXRlciB3aXRoIFwiZmFsc2V5XCIgdmFsdWVzIHJlbW92ZWRcbiAqIEBmdW5jdGlvbiBVdGlsLmNvbXBhY3RcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gdGhlIGFycmF5IHRvIHJlbW92ZSB2YWx1ZXMgZnJvbVxuICogQHJldHVybiB7QXJyYXl9IGEgbmV3IGFycmF5IHdpdGhvdXQgZmFsc2V5IHZhbHVlc1xuICovXG5cbi8qKlxuICogQ2hlY2sgaWYgYSBnaXZlbiBpdGVtIGlzIGluY2x1ZGVkIGluIHRoZSBnaXZlbiBhcnJheVxuICogQGZ1bmN0aW9uIFV0aWwuY29udGFpbnNcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gdGhlIGFycmF5IHRvIHNlYXJjaCBpblxuICogQHBhcmFtIHsqfSBpdGVtIC0gdGhlIGl0ZW0gdG8gc2VhcmNoIGZvclxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgaXRlbSBpcyBpbmNsdWRlZCBpbiB0aGUgYXJyYXlcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgdmFsdWVzIGluIHRoZSBnaXZlbiBhcnJheSB0aGF0IGFyZSBub3QgaW5jbHVkZWQgaW4gdGhlIG90aGVyIGFycmF5XG4gKiBAZnVuY3Rpb24gVXRpbC5kaWZmZXJlbmNlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnIgLSB0aGUgYXJyYXkgdG8gc2VsZWN0IGZyb21cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyAtIHZhbHVlcyB0byBmaWx0ZXIgZnJvbSBhcnJcbiAqIEByZXR1cm4ge0FycmF5fSB0aGUgZmlsdGVyZWQgdmFsdWVzXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgdGhlIGZ1bmN0aW9uIG5hbWVzIGluIG9ialxuICogQGZ1bmN0aW9uIFV0aWwuZnVuY3Rpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gdGhlIG9iamVjdCB0byBpbnNwZWN0XG4gKiBAcmV0dXJuIHtBcnJheX0gYSBsaXN0IG9mIGZ1bmN0aW9ucyBvZiBvYmplY3RcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHByb3ZpZGVkIHZhbHVlLiBUaGlzIGZ1bmN0aW9ucyBpcyB1c2VkIGFzIGEgZGVmYXVsdCBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gKiBAZnVuY3Rpb24gVXRpbC5pZGVudGl0eVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Kn0gdGhlIHByb3ZpZGVkIHZhbHVlXG4gKi9cblxuLyoqXG4gKiBSZW1vdmUgbGVhZGluZyBvciB0cmFpbGluZyBzcGFjZXMgZnJvbSB0ZXh0XG4gKiBAZnVuY3Rpb24gVXRpbC50cmltXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgYHRleHRgIHdpdGhvdXQgbGVhZGluZyBvciB0cmFpbGluZyBzcGFjZXNcbiAqL1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZXhwcmVzc2lvbi5qc1xuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSB0cmFuc2Zvcm1hdGlvbiBleHByZXNzaW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb25TdHIgLSBBbiBleHByZXNzaW9uIGluIHN0cmluZyBmb3JtYXQuXG4gKiBAY2xhc3MgRXhwcmVzc2lvblxuICogTm9ybWFsbHkgdGhpcyBjbGFzcyBpcyBub3QgaW5zdGFudGlhdGVkIGRpcmVjdGx5XG4gKi9cbnZhciBFeHByZXNzaW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXhwcmVzc2lvbihleHByZXNzaW9uU3RyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV4cHJlc3Npb24pO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBpbm5lciBFeHByZXNzaW9uLWV4cHJlc3Npb25zXG4gICAgICovXG4gICAgdGhpcy5leHByZXNzaW9ucyA9IFtdO1xuXG4gICAgaWYgKGV4cHJlc3Npb25TdHIgIT0gbnVsbCkge1xuICAgICAgdGhpcy5leHByZXNzaW9ucy5wdXNoKEV4cHJlc3Npb24ubm9ybWFsaXplKGV4cHJlc3Npb25TdHIpKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIGNvbnN0cnVjdG9yIG1ldGhvZFxuICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5uZXdcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoRXhwcmVzc2lvbiwgW3tcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoZSBleHByZXNzaW9uXG4gICAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXhwcmVzc2lvbiBhcyBhIHN0cmluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIHJldHVybiBFeHByZXNzaW9uLm5vcm1hbGl6ZSh0aGlzLmV4cHJlc3Npb25zLmpvaW4oXCJfXCIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwYXJlbnQgdHJhbnNmb3JtYXRpb24gb2YgdGhpcyBleHByZXNzaW9uXG4gICAgICogQHJldHVybiBUcmFuc2Zvcm1hdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGFyZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBhcmVudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBwYXJlbnQgdHJhbnNmb3JtYXRpb24gb2YgdGhpcyBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtUcmFuc2Zvcm1hdGlvbn0gdGhlIHBhcmVudCB0cmFuc2Zvcm1hdGlvblxuICAgICAqIEByZXR1cm4ge0V4cHJlc3Npb259IHRoaXMgZXhwcmVzc2lvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UGFyZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIGV4cHJlc3Npb25cbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbiNwcmVkaWNhdGVcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInByZWRpY2F0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVkaWNhdGUobmFtZSwgb3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICBpZiAoRXhwcmVzc2lvbi5PUEVSQVRPUlNbb3BlcmF0b3JdICE9IG51bGwpIHtcbiAgICAgICAgb3BlcmF0b3IgPSBFeHByZXNzaW9uLk9QRVJBVE9SU1tvcGVyYXRvcl07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZXhwcmVzc2lvbnMucHVzaChcIlwiLmNvbmNhdChuYW1lLCBcIl9cIikuY29uY2F0KG9wZXJhdG9yLCBcIl9cIikuY29uY2F0KHZhbHVlKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24jYW5kXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW5kKCkge1xuICAgICAgdGhpcy5leHByZXNzaW9ucy5wdXNoKFwiYW5kXCIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uI29yXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcigpIHtcbiAgICAgIHRoaXMuZXhwcmVzc2lvbnMucHVzaChcIm9yXCIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmNsdWRlIGV4cHJlc3Npb25cbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbiN0aGVuXG4gICAgICogQHJldHVybiB7VHJhbnNmb3JtYXRpb259IHRoZSB0cmFuc2Zvcm1hdGlvbiB0aGlzIGV4cHJlc3Npb24gaXMgZGVmaW5lZCBmb3JcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRoZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGhlbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFBhcmVudCgpW1wiaWZcIl0odGhpcy50b1N0cmluZygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24jaGVpZ2h0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIHRoZSBjb21wYXJpc29uIG9wZXJhdG9yIChlLmcuIFwiPFwiLCBcImx0XCIpXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgcmlnaHQgaGFuZCBzaWRlIHZhbHVlXG4gICAgICogQHJldHVybiB7RXhwcmVzc2lvbn0gdGhpcyBleHByZXNzaW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJoZWlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGVpZ2h0KG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZGljYXRlKFwiaFwiLCBvcGVyYXRvciwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbiN3aWR0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciB0aGUgY29tcGFyaXNvbiBvcGVyYXRvciAoZS5nLiBcIjxcIiwgXCJsdFwiKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgdGhlIHJpZ2h0IGhhbmQgc2lkZSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0V4cHJlc3Npb259IHRoaXMgZXhwcmVzc2lvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2lkdGgob3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXCJ3XCIsIG9wZXJhdG9yLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uI2FzcGVjdFJhdGlvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIHRoZSBjb21wYXJpc29uIG9wZXJhdG9yIChlLmcuIFwiPFwiLCBcImx0XCIpXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgcmlnaHQgaGFuZCBzaWRlIHZhbHVlXG4gICAgICogQHJldHVybiB7RXhwcmVzc2lvbn0gdGhpcyBleHByZXNzaW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhc3BlY3RSYXRpb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhc3BlY3RSYXRpbyhvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcImFyXCIsIG9wZXJhdG9yLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uI3BhZ2VzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIHRoZSBjb21wYXJpc29uIG9wZXJhdG9yIChlLmcuIFwiPFwiLCBcImx0XCIpXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgcmlnaHQgaGFuZCBzaWRlIHZhbHVlXG4gICAgICogQHJldHVybiB7RXhwcmVzc2lvbn0gdGhpcyBleHByZXNzaW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwYWdlQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFnZUNvdW50KG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZGljYXRlKFwicGNcIiwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24jZmFjZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtFeHByZXNzaW9ufSB0aGlzIGV4cHJlc3Npb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZhY2VDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmYWNlQ291bnQob3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXCJmY1wiLCBvcGVyYXRvciwgdmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShfdmFsdWUpIHtcbiAgICAgIHRoaXMuZXhwcmVzc2lvbnMucHVzaChfdmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqL1xuXG4gIH1dLCBbe1xuICAgIGtleTogXCJuZXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX25ldyhleHByZXNzaW9uU3RyKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoZXhwcmVzc2lvblN0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSBhIHN0cmluZyBleHByZXNzaW9uXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjbm9ybWFsaXplXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gYSBleHByZXNzaW9uLCBlLmcuIFwidyBndCAxMDBcIiwgXCJ3aWR0aF9ndF8xMDBcIiwgXCJ3aWR0aCA+IDEwMFwiXG4gICAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgbm9ybWFsaXplZCBmb3JtIG9mIHRoZSB2YWx1ZSBleHByZXNzaW9uLCBlLmcuIFwid19ndF8xMDBcIlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibm9ybWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vcm1hbGl6ZShleHByZXNzaW9uKSB7XG4gICAgICBpZiAoZXhwcmVzc2lvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgICAgfVxuXG4gICAgICBleHByZXNzaW9uID0gU3RyaW5nKGV4cHJlc3Npb24pO1xuICAgICAgdmFyIG9wZXJhdG9ycyA9IFwiXFxcXHxcXFxcfHw+PXw8PXwmJnwhPXw+fD18PHwvfC18XFxcXCt8XFxcXCp8XFxcXF5cIjsgLy8gb3BlcmF0b3JzXG5cbiAgICAgIHZhciBvcGVyYXRvcnNQYXR0ZXJuID0gXCIoKFwiICsgb3BlcmF0b3JzICsgXCIpKD89WyBfXSkpXCI7XG4gICAgICB2YXIgb3BlcmF0b3JzUmVwbGFjZVJFID0gbmV3IFJlZ0V4cChvcGVyYXRvcnNQYXR0ZXJuLCBcImdcIik7XG4gICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbi5yZXBsYWNlKG9wZXJhdG9yc1JlcGxhY2VSRSwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBFeHByZXNzaW9uLk9QRVJBVE9SU1ttYXRjaF07XG4gICAgICB9KTsgLy8gcHJlZGVmaW5lZCB2YXJpYWJsZXNcbiAgICAgIC8vIFRoZSA6JHt2fSBwYXJ0IGlzIHRvIHByZXZlbnQgbm9ybWFsaXphdGlvbiBvZiB2YXJzIHdpdGggYSBwcmVjZWRpbmcgY29sb24gKHN1Y2ggYXMgOmR1cmF0aW9uKSxcbiAgICAgIC8vIEl0IHdvbid0IGJlIGZvdW5kIGluIFBSRURFRklORURfVkFSUyBhbmQgc28gd29uJ3QgYmUgbm9ybWFsaXplZC5cbiAgICAgIC8vIEl0IGlzIGRvbmUgbGlrZSB0aGlzIGJlY2F1c2UgaWUxMSBkb2VzIG5vdCBzdXBwb3J0IHJlZ2V4IGxvb2tiZWhpbmRcblxuICAgICAgdmFyIHByZWRlZmluZWRWYXJzUGF0dGVybiA9IFwiKFwiICsgT2JqZWN0LmtleXMoRXhwcmVzc2lvbi5QUkVERUZJTkVEX1ZBUlMpLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gXCI6XCIuY29uY2F0KHYsIFwifFwiKS5jb25jYXQodik7XG4gICAgICB9KS5qb2luKFwifFwiKSArIFwiKVwiO1xuICAgICAgdmFyIHVzZXJWYXJpYWJsZVBhdHRlcm4gPSAnKFxcXFwkXypbXl8gXSspJztcbiAgICAgIHZhciB2YXJpYWJsZXNSZXBsYWNlUkUgPSBuZXcgUmVnRXhwKFwiXCIuY29uY2F0KHVzZXJWYXJpYWJsZVBhdHRlcm4sIFwifFwiKS5jb25jYXQocHJlZGVmaW5lZFZhcnNQYXR0ZXJuKSwgXCJnXCIpO1xuICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24ucmVwbGFjZSh2YXJpYWJsZXNSZXBsYWNlUkUsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICByZXR1cm4gRXhwcmVzc2lvbi5QUkVERUZJTkVEX1ZBUlNbbWF0Y2hdIHx8IG1hdGNoO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZXhwcmVzc2lvbi5yZXBsYWNlKC9bIF9dKy9nLCAnXycpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YXJpYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YXJpYWJsZShuYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKG5hbWUpLnZhbHVlKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJ3aWR0aFwiXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24ud2lkdGhcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndpZHRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpZHRoKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKFwid2lkdGhcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEV4cHJlc3Npb24gYSBuZXcgZXhwcmVzc2lvbiB3aXRoIHRoZSBwcmVkZWZpbmVkIHZhcmlhYmxlIFwiaGVpZ2h0XCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5oZWlnaHRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImhlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoZWlnaHQoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJoZWlnaHRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEV4cHJlc3Npb24gYSBuZXcgZXhwcmVzc2lvbiB3aXRoIHRoZSBwcmVkZWZpbmVkIHZhcmlhYmxlIFwiaW5pdGlhbFdpZHRoXCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5pbml0aWFsV2lkdGhcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImluaXRpYWxXaWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsV2lkdGgoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJpbml0aWFsV2lkdGhcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEV4cHJlc3Npb24gYSBuZXcgZXhwcmVzc2lvbiB3aXRoIHRoZSBwcmVkZWZpbmVkIHZhcmlhYmxlIFwiaW5pdGlhbEhlaWdodFwiXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24uaW5pdGlhbEhlaWdodFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdGlhbEhlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsSGVpZ2h0KCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKFwiaW5pdGlhbEhlaWdodFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJhc3BlY3RSYXRpb1wiXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24uYXNwZWN0UmF0aW9cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFzcGVjdFJhdGlvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFzcGVjdFJhdGlvKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKFwiYXNwZWN0UmF0aW9cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEV4cHJlc3Npb24gYSBuZXcgZXhwcmVzc2lvbiB3aXRoIHRoZSBwcmVkZWZpbmVkIHZhcmlhYmxlIFwiaW5pdGlhbEFzcGVjdFJhdGlvXCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5pbml0aWFsQXNwZWN0UmF0aW9cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImluaXRpYWxBc3BlY3RSYXRpb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsQXNwZWN0UmF0aW8oKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJpbml0aWFsQXNwZWN0UmF0aW9cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEV4cHJlc3Npb24gYSBuZXcgZXhwcmVzc2lvbiB3aXRoIHRoZSBwcmVkZWZpbmVkIHZhcmlhYmxlIFwicGFnZUNvdW50XCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5wYWdlQ291bnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBhZ2VDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYWdlQ291bnQoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJwYWdlQ291bnRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEV4cHJlc3Npb24gbmV3IGV4cHJlc3Npb24gd2l0aCB0aGUgcHJlZGVmaW5lZCB2YXJpYWJsZSBcImZhY2VDb3VudFwiXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24uZmFjZUNvdW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmYWNlQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmFjZUNvdW50KCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKFwiZmFjZUNvdW50XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBFeHByZXNzaW9uIGEgbmV3IGV4cHJlc3Npb24gd2l0aCB0aGUgcHJlZGVmaW5lZCB2YXJpYWJsZSBcImN1cnJlbnRQYWdlXCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5jdXJyZW50UGFnZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY3VycmVudFBhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3VycmVudFBhZ2UoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJjdXJyZW50UGFnZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJ0YWdzXCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi50YWdzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0YWdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRhZ3MoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJ0YWdzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBFeHByZXNzaW9uIGEgbmV3IGV4cHJlc3Npb24gd2l0aCB0aGUgcHJlZGVmaW5lZCB2YXJpYWJsZSBcInBhZ2VYXCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5wYWdlWFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGFnZVhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFnZVgoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJwYWdlWFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJwYWdlWVwiXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24ucGFnZVlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBhZ2VZXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhZ2VZKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKFwicGFnZVlcIik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEV4cHJlc3Npb247XG59KCk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cblxuRXhwcmVzc2lvbi5PUEVSQVRPUlMgPSB7XG4gIFwiPVwiOiAnZXEnLFxuICBcIiE9XCI6ICduZScsXG4gIFwiPFwiOiAnbHQnLFxuICBcIj5cIjogJ2d0JyxcbiAgXCI8PVwiOiAnbHRlJyxcbiAgXCI+PVwiOiAnZ3RlJyxcbiAgXCImJlwiOiAnYW5kJyxcbiAgXCJ8fFwiOiAnb3InLFxuICBcIipcIjogXCJtdWxcIixcbiAgXCIvXCI6IFwiZGl2XCIsXG4gIFwiK1wiOiBcImFkZFwiLFxuICBcIi1cIjogXCJzdWJcIixcbiAgXCJeXCI6IFwicG93XCJcbn07XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbkV4cHJlc3Npb24uUFJFREVGSU5FRF9WQVJTID0ge1xuICBcImFzcGVjdF9yYXRpb1wiOiBcImFyXCIsXG4gIFwiYXNwZWN0UmF0aW9cIjogXCJhclwiLFxuICBcImN1cnJlbnRfcGFnZVwiOiBcImNwXCIsXG4gIFwiY3VycmVudFBhZ2VcIjogXCJjcFwiLFxuICBcImR1cmF0aW9uXCI6IFwiZHVcIixcbiAgXCJmYWNlX2NvdW50XCI6IFwiZmNcIixcbiAgXCJmYWNlQ291bnRcIjogXCJmY1wiLFxuICBcImhlaWdodFwiOiBcImhcIixcbiAgXCJpbml0aWFsX2FzcGVjdF9yYXRpb1wiOiBcImlhclwiLFxuICBcImluaXRpYWxfZHVyYXRpb25cIjogXCJpZHVcIixcbiAgXCJpbml0aWFsX2hlaWdodFwiOiBcImloXCIsXG4gIFwiaW5pdGlhbF93aWR0aFwiOiBcIml3XCIsXG4gIFwiaW5pdGlhbEFzcGVjdFJhdGlvXCI6IFwiaWFyXCIsXG4gIFwiaW5pdGlhbER1cmF0aW9uXCI6IFwiaWR1XCIsXG4gIFwiaW5pdGlhbEhlaWdodFwiOiBcImloXCIsXG4gIFwiaW5pdGlhbFdpZHRoXCI6IFwiaXdcIixcbiAgXCJwYWdlX2NvdW50XCI6IFwicGNcIixcbiAgXCJwYWdlX3hcIjogXCJweFwiLFxuICBcInBhZ2VfeVwiOiBcInB5XCIsXG4gIFwicGFnZUNvdW50XCI6IFwicGNcIixcbiAgXCJwYWdlWFwiOiBcInB4XCIsXG4gIFwicGFnZVlcIjogXCJweVwiLFxuICBcInRhZ3NcIjogXCJ0YWdzXCIsXG4gIFwid2lkdGhcIjogXCJ3XCJcbn07XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbkV4cHJlc3Npb24uQk9VTkRSWSA9IFwiWyBfXStcIjtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGV4cHJlc3Npb24gPSAoRXhwcmVzc2lvbik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb25kaXRpb24uanNcbmZ1bmN0aW9uIGNvbmRpdGlvbl90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIGNvbmRpdGlvbl90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBjb25kaXRpb25fdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gY29uZGl0aW9uX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gY29uZGl0aW9uX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBjb25kaXRpb25fY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBjb25kaXRpb25fZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGNvbmRpdGlvbl9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChjb25kaXRpb25fdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHRyYW5zZm9ybWF0aW9uIGNvbmRpdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb25kaXRpb25TdHIgLSBhIGNvbmRpdGlvbiBpbiBzdHJpbmcgZm9ybWF0XG4gKiBAY2xhc3MgQ29uZGl0aW9uXG4gKiBAZXhhbXBsZVxuICogLy8gbm9ybWFsbHkgdGhpcyBjbGFzcyBpcyBub3QgaW5zdGFudGlhdGVkIGRpcmVjdGx5XG4gKiB2YXIgdHIgPSBjbG91ZGluYXJ5LlRyYW5zZm9ybWF0aW9uLm5ldygpXG4gKiAgICAuaWYoKS53aWR0aCggXCI+XCIsIDEwMDApLmFuZCgpLmFzcGVjdFJhdGlvKFwiPFwiLCBcIjM6NFwiKS50aGVuKClcbiAqICAgICAgLndpZHRoKDEwMDApXG4gKiAgICAgIC5jcm9wKFwic2NhbGVcIilcbiAqICAgIC5lbHNlKClcbiAqICAgICAgLndpZHRoKDUwMClcbiAqICAgICAgLmNyb3AoXCJzY2FsZVwiKVxuICpcbiAqIHZhciB0ciA9IGNsb3VkaW5hcnkuVHJhbnNmb3JtYXRpb24ubmV3KClcbiAqICAgIC5pZihcIncgPiAxMDAwIGFuZCBhc3BlY3RSYXRpbyA8IDM6NFwiKVxuICogICAgICAud2lkdGgoMTAwMClcbiAqICAgICAgLmNyb3AoXCJzY2FsZVwiKVxuICogICAgLmVsc2UoKVxuICogICAgICAud2lkdGgoNTAwKVxuICogICAgICAuY3JvcChcInNjYWxlXCIpXG4gKlxuICovXG5cbnZhciBDb25kaXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FeHByZXNzaW9uKSB7XG4gIF9pbmhlcml0cyhDb25kaXRpb24sIF9FeHByZXNzaW9uKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKENvbmRpdGlvbik7XG5cbiAgZnVuY3Rpb24gQ29uZGl0aW9uKGNvbmRpdGlvblN0cikge1xuICAgIGNvbmRpdGlvbl9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb25kaXRpb24pO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGNvbmRpdGlvblN0cik7XG4gIH1cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBDb25kaXRpb24jaGVpZ2h0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciB0aGUgY29tcGFyaXNvbiBvcGVyYXRvciAoZS5nLiBcIjxcIiwgXCJsdFwiKVxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICogQHJldHVybiB7Q29uZGl0aW9ufSB0aGlzIGNvbmRpdGlvblxuICAgKi9cblxuXG4gIGNvbmRpdGlvbl9jcmVhdGVDbGFzcyhDb25kaXRpb24sIFt7XG4gICAga2V5OiBcImhlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoZWlnaHQob3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXCJoXCIsIG9wZXJhdG9yLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBDb25kaXRpb24jd2lkdGhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtDb25kaXRpb259IHRoaXMgY29uZGl0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ3aWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aWR0aChvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcIndcIiwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIENvbmRpdGlvbiNhc3BlY3RSYXRpb1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciB0aGUgY29tcGFyaXNvbiBvcGVyYXRvciAoZS5nLiBcIjxcIiwgXCJsdFwiKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgdGhlIHJpZ2h0IGhhbmQgc2lkZSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0NvbmRpdGlvbn0gdGhpcyBjb25kaXRpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFzcGVjdFJhdGlvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFzcGVjdFJhdGlvKG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZGljYXRlKFwiYXJcIiwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIENvbmRpdGlvbiNwYWdlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciB0aGUgY29tcGFyaXNvbiBvcGVyYXRvciAoZS5nLiBcIjxcIiwgXCJsdFwiKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgdGhlIHJpZ2h0IGhhbmQgc2lkZSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0NvbmRpdGlvbn0gdGhpcyBjb25kaXRpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBhZ2VDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYWdlQ291bnQob3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXCJwY1wiLCBvcGVyYXRvciwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gQ29uZGl0aW9uI2ZhY2VzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIHRoZSBjb21wYXJpc29uIG9wZXJhdG9yIChlLmcuIFwiPFwiLCBcImx0XCIpXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgcmlnaHQgaGFuZCBzaWRlIHZhbHVlXG4gICAgICogQHJldHVybiB7Q29uZGl0aW9ufSB0aGlzIGNvbmRpdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmFjZUNvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZhY2VDb3VudChvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcImZjXCIsIG9wZXJhdG9yLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBDb25kaXRpb24jZHVyYXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtDb25kaXRpb259IHRoaXMgY29uZGl0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkdXJhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkdXJhdGlvbihvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcImR1XCIsIG9wZXJhdG9yLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBDb25kaXRpb24jaW5pdGlhbER1cmF0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIHRoZSBjb21wYXJpc29uIG9wZXJhdG9yIChlLmcuIFwiPFwiLCBcImx0XCIpXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgcmlnaHQgaGFuZCBzaWRlIHZhbHVlXG4gICAgICogQHJldHVybiB7Q29uZGl0aW9ufSB0aGlzIGNvbmRpdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdGlhbER1cmF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxEdXJhdGlvbihvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcImlkdVwiLCBvcGVyYXRvciwgdmFsdWUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb25kaXRpb247XG59KGV4cHJlc3Npb24pO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb25kaXRpb24gPSAoQ29uZGl0aW9uKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbmZpZ3VyYXRpb24uanNcbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgY29uZmlndXJhdGlvbl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIGNvbmZpZ3VyYXRpb25fdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBjb25maWd1cmF0aW9uX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBjb25maWd1cmF0aW9uX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBjb25maWd1cmF0aW9uX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9zLCBfZTsgdHJ5IHsgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5mdW5jdGlvbiBjb25maWd1cmF0aW9uX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gY29uZmlndXJhdGlvbl9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gY29uZmlndXJhdGlvbl9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGNvbmZpZ3VyYXRpb25fZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGNvbmZpZ3VyYXRpb25fZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuLyoqXG4gKiBDbGFzcyBmb3IgZGVmaW5pbmcgYWNjb3VudCBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gKiBEZXBlbmRzIG9uICd1dGlscydcbiAqL1xuXG4vKipcbiAqIENsYXNzIGZvciBkZWZpbmluZyBhY2NvdW50IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqIEBjb25zdHJ1Y3RvciBDb25maWd1cmF0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBhY2NvdW50IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycyB0byBzZXQuXG4gKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vc29sdXRpb25fb3ZlcnZpZXcjY29uZmlndXJhdGlvbl9wYXJhbWV0ZXJzXCJcbiAqICB0YXJnZXQ9XCJfbmV3XCI+QXZhaWxhYmxlIGNvbmZpZ3VyYXRpb24gb3B0aW9uczwvYT5cbiAqL1xuXG52YXIgY29uZmlndXJhdGlvbl9Db25maWd1cmF0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29uZmlndXJhdGlvbihvcHRpb25zKSB7XG4gICAgY29uZmlndXJhdGlvbl9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb25maWd1cmF0aW9uKTtcblxuICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IG9wdGlvbnMgPT0gbnVsbCA/IHt9IDogY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwX2RlZmF1bHQoKShvcHRpb25zKTtcbiAgICBkZWZhdWx0cyh0aGlzLmNvbmZpZ3VyYXRpb24sIERFRkFVTFRfQ09ORklHVVJBVElPTl9QQVJBTVMpO1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgY29uZmlndXJhdGlvbi4gVGhpcyBtZXRob2QgaXMgYSBjb252ZW5pZW5jZSBtZXRob2QgdGhhdCBpbnZva2VzIGJvdGhcbiAgICogIHtAbGluayBDb25maWd1cmF0aW9uI2Zyb21FbnZpcm9ubWVudHxmcm9tRW52aXJvbm1lbnQoKX0gKE5vZGUuanMgZW52aXJvbm1lbnQgb25seSlcbiAgICogIGFuZCB7QGxpbmsgQ29uZmlndXJhdGlvbiNmcm9tRG9jdW1lbnR8ZnJvbURvY3VtZW50KCl9LlxuICAgKiAgSXQgZmlyc3QgdHJpZXMgdG8gcmV0cmlldmUgdGhlIGNvbmZpZ3VyYXRpb24gZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUuXG4gICAqICBJZiBub3QgYXZhaWxhYmxlLCBpdCB0cmllcyBmcm9tIHRoZSBkb2N1bWVudCBtZXRhIHRhZ3MuXG4gICAqIEBmdW5jdGlvbiBDb25maWd1cmF0aW9uI2luaXRcbiAgICogQHJldHVybiB7Q29uZmlndXJhdGlvbn0gcmV0dXJucyBgdGhpc2AgZm9yIGNoYWluaW5nXG4gICAqIEBzZWUgZnJvbURvY3VtZW50XG4gICAqIEBzZWUgZnJvbUVudmlyb25tZW50XG4gICAqL1xuXG5cbiAgY29uZmlndXJhdGlvbl9jcmVhdGVDbGFzcyhDb25maWd1cmF0aW9uLCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLmZyb21FbnZpcm9ubWVudCgpO1xuICAgICAgdGhpcy5mcm9tRG9jdW1lbnQoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYSBuZXcgY29uZmlndXJhdGlvbiBpdGVtXG4gICAgICogQGZ1bmN0aW9uIENvbmZpZ3VyYXRpb24jc2V0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgaXRlbSB0byBzZXRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIGJlIHNldFxuICAgICAqIEByZXR1cm4ge0NvbmZpZ3VyYXRpb259XG4gICAgICpcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQobmFtZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY29uZmlndXJhdGlvbltuYW1lXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgb2YgYSBjb25maWd1cmF0aW9uIGl0ZW1cbiAgICAgKiBAZnVuY3Rpb24gQ29uZmlndXJhdGlvbiNnZXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBpdGVtIHRvIHNldFxuICAgICAqIEByZXR1cm4geyp9IHRoZSBjb25maWd1cmF0aW9uIGl0ZW1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbltuYW1lXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWVyZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWVyZ2UoY29uZmlnKSB7XG4gICAgICBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHRoaXMuY29uZmlndXJhdGlvbiwgY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwX2RlZmF1bHQoKShjb25maWcpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIENsb3VkaW5hcnkgZnJvbSBIVE1MIG1ldGEgdGFncy5cbiAgICAgKiBAZnVuY3Rpb24gQ29uZmlndXJhdGlvbiNmcm9tRG9jdW1lbnRcbiAgICAgKiBAcmV0dXJuIHtDb25maWd1cmF0aW9ufVxuICAgICAqIEBleGFtcGxlIDxtZXRhIG5hbWU9XCJjbG91ZGluYXJ5X2Nsb3VkX25hbWVcIiBjb250ZW50PVwibXljbG91ZFwiPlxuICAgICAqXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmcm9tRG9jdW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbURvY3VtZW50KCkge1xuICAgICAgdmFyIGVsLCBpLCBsZW4sIG1ldGFfZWxlbWVudHM7XG4gICAgICBtZXRhX2VsZW1lbnRzID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50ICE9PSBudWxsID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnbWV0YVtuYW1lXj1cImNsb3VkaW5hcnlfXCJdJykgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChtZXRhX2VsZW1lbnRzKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG1ldGFfZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBlbCA9IG1ldGFfZWxlbWVudHNbaV07XG4gICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uW2VsLmdldEF0dHJpYnV0ZSgnbmFtZScpLnJlcGxhY2UoJ2Nsb3VkaW5hcnlfJywgJycpXSA9IGVsLmdldEF0dHJpYnV0ZSgnY29udGVudCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIENsb3VkaW5hcnkgZnJvbSB0aGUgYENMT1VESU5BUllfVVJMYCBlbnZpcm9ubWVudCB2YXJpYWJsZS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBvbmx5IHJ1biB1bmRlciBOb2RlLmpzIGVudmlyb25tZW50LlxuICAgICAqIEBmdW5jdGlvbiBDb25maWd1cmF0aW9uI2Zyb21FbnZpcm9ubWVudFxuICAgICAqIEByZXF1aXJlcyBOb2RlLmpzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmcm9tRW52aXJvbm1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUVudmlyb25tZW50KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGNsb3VkaW5hcnlfdXJsLCBxdWVyeSwgdXJpLCB1cmlSZWdleDtcblxuICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MgIT09IG51bGwgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuQ0xPVURJTkFSWV9VUkwpIHtcbiAgICAgICAgY2xvdWRpbmFyeV91cmwgPSBwcm9jZXNzLmVudi5DTE9VRElOQVJZX1VSTDtcbiAgICAgICAgdXJpUmVnZXggPSAvY2xvdWRpbmFyeTpcXC9cXC8oPzooXFx3KykoPzpcXDooW1xcdy1dKykpP0ApPyhbXFx3XFwuLV0rKSg/OlxcLyhbXj9dKikpPyg/OlxcPyguKykpPy87XG4gICAgICAgIHVyaSA9IHVyaVJlZ2V4LmV4ZWMoY2xvdWRpbmFyeV91cmwpO1xuXG4gICAgICAgIGlmICh1cmkpIHtcbiAgICAgICAgICBpZiAodXJpWzNdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvblsnY2xvdWRfbmFtZSddID0gdXJpWzNdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1cmlbMV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uWydhcGlfa2V5J10gPSB1cmlbMV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHVyaVsyXSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25bJ2FwaV9zZWNyZXQnXSA9IHVyaVsyXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXJpWzRdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvblsncHJpdmF0ZV9jZG4nXSA9IHVyaVs0XSAhPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1cmlbNF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uWydzZWN1cmVfZGlzdHJpYnV0aW9uJ10gPSB1cmlbNF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcXVlcnkgPSB1cmlbNV07XG5cbiAgICAgICAgICBpZiAocXVlcnkgIT0gbnVsbCkge1xuICAgICAgICAgICAgcXVlcnkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICB2YXIgX3ZhbHVlJHNwbGl0ID0gdmFsdWUuc3BsaXQoJz0nKSxcbiAgICAgICAgICAgICAgICAgIF92YWx1ZSRzcGxpdDIgPSBfc2xpY2VkVG9BcnJheShfdmFsdWUkc3BsaXQsIDIpLFxuICAgICAgICAgICAgICAgICAgayA9IF92YWx1ZSRzcGxpdDJbMF0sXG4gICAgICAgICAgICAgICAgICB2ID0gX3ZhbHVlJHNwbGl0MlsxXTtcblxuICAgICAgICAgICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdiA9IHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfdGhpcy5jb25maWd1cmF0aW9uW2tdID0gdjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIG9yIG1vZGlmeSB0aGUgQ2xvdWRpbmFyeSBjbGllbnQgY29uZmlndXJhdGlvblxuICAgICAqXG4gICAgICogV2FybmluZzogYGNvbmZpZygpYCByZXR1cm5zIHRoZSBhY3R1YWwgaW50ZXJuYWwgY29uZmlndXJhdGlvbiBvYmplY3QuIG1vZGlmeWluZyBpdCB3aWxsIGNoYW5nZSB0aGUgY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IG1ldGhvZC4gRm9yIG5ldyBjb2RlLCB1c2UgZ2V0KCksIG1lcmdlKCkgZXRjLlxuICAgICAqIEBmdW5jdGlvbiBDb25maWd1cmF0aW9uI2NvbmZpZ1xuICAgICAqIEBwYXJhbSB7aGFzaHxzdHJpbmd8Ym9vbGVhbn0gbmV3X2NvbmZpZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdfdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Kn0gY29uZmlndXJhdGlvbiwgb3IgdmFsdWVcbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGZyb21FbnZpcm9ubWVudH0gZm9yIGluaXRpYWxpemF0aW9uIHVzaW5nIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgICAqIEBzZWUge0BsaW5rIGZyb21Eb2N1bWVudH0gZm9yIGluaXRpYWxpemF0aW9uIHVzaW5nIEhUTUwgbWV0YSB0YWdzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjb25maWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uZmlnKG5ld19jb25maWcsIG5ld192YWx1ZSkge1xuICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICBjYXNlIG5ld192YWx1ZSA9PT0gdm9pZCAwOlxuICAgICAgICAgIHRoaXMuc2V0KG5ld19jb25maWcsIG5ld192YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbjtcblxuICAgICAgICBjYXNlICFpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQoKShuZXdfY29uZmlnKTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXQobmV3X2NvbmZpZyk7XG5cbiAgICAgICAgY2FzZSAhaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfZGVmYXVsdCgpKG5ld19jb25maWcpOlxuICAgICAgICAgIHRoaXMubWVyZ2UobmV3X2NvbmZpZyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbjtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHkgLSByZXR1cm4gdGhlIGludGVybmFsIG9iamVjdFxuICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb247XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnNcbiAgICAgKiBAZnVuY3Rpb24gQ29uZmlndXJhdGlvbiN0b09wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBhIGtleTp2YWx1ZSBjb2xsZWN0aW9uIG9mIHRoZSBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b09wdGlvbnMoKSB7XG4gICAgICByZXR1cm4gY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwX2RlZmF1bHQoKSh0aGlzLmNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb25maWd1cmF0aW9uO1xufSgpO1xuXG52YXIgREVGQVVMVF9DT05GSUdVUkFUSU9OX1BBUkFNUyA9IHtcbiAgcmVzcG9uc2l2ZV9jbGFzczogJ2NsZC1yZXNwb25zaXZlJyxcbiAgcmVzcG9uc2l2ZV91c2VfYnJlYWtwb2ludHM6IHRydWUsXG4gIHJvdW5kX2RwcjogdHJ1ZSxcbiAgc2VjdXJlOiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgIT09IG51bGwgPyB3aW5kb3cubG9jYXRpb24gPyB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgOiB2b2lkIDAgOiB2b2lkIDApID09PSAnaHR0cHM6J1xufTtcbmNvbmZpZ3VyYXRpb25fQ29uZmlndXJhdGlvbi5DT05GSUdfUEFSQU1TID0gW1wiYXBpX2tleVwiLCBcImFwaV9zZWNyZXRcIiwgXCJjYWxsYmFja1wiLCBcImNkbl9zdWJkb21haW5cIiwgXCJjbG91ZF9uYW1lXCIsIFwiY25hbWVcIiwgXCJwcml2YXRlX2NkblwiLCBcInByb3RvY29sXCIsIFwicmVzb3VyY2VfdHlwZVwiLCBcInJlc3BvbnNpdmVcIiwgXCJyZXNwb25zaXZlX2NsYXNzXCIsIFwicmVzcG9uc2l2ZV91c2VfYnJlYWtwb2ludHNcIiwgXCJyZXNwb25zaXZlX3dpZHRoXCIsIFwicm91bmRfZHByXCIsIFwic2VjdXJlXCIsIFwic2VjdXJlX2Nkbl9zdWJkb21haW5cIiwgXCJzZWN1cmVfZGlzdHJpYnV0aW9uXCIsIFwic2hvcnRlblwiLCBcInR5cGVcIiwgXCJ1cGxvYWRfcHJlc2V0XCIsIFwidXJsX3N1ZmZpeFwiLCBcInVzZV9yb290X3BhdGhcIiwgXCJ2ZXJzaW9uXCIsIFwiZXh0ZXJuYWxMaWJyYXJpZXNcIiwgXCJtYXhfdGltZW91dF9tc1wiXTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNyY19jb25maWd1cmF0aW9uID0gKGNvbmZpZ3VyYXRpb25fQ29uZmlndXJhdGlvbik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9sYXllci9sYXllci5qc1xuZnVuY3Rpb24gbGF5ZXJfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBsYXllcl9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gbGF5ZXJfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBsYXllcl9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgbGF5ZXJfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuXG5cbnZhciBsYXllcl9MYXllciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBMYXllclxuICAgKiBAY29uc3RydWN0b3IgTGF5ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBsYXllciBwYXJhbWV0ZXJzXG4gICAqL1xuICBmdW5jdGlvbiBMYXllcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGxheWVyX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExheWVyKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuXG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuICAgICAgW1wicmVzb3VyY2VUeXBlXCIsIFwidHlwZVwiLCBcInB1YmxpY0lkXCIsIFwiZm9ybWF0XCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgcmVmO1xuICAgICAgICByZXR1cm4gX3RoaXMub3B0aW9uc1trZXldID0gKHJlZiA9IG9wdGlvbnNba2V5XSkgIT0gbnVsbCA/IHJlZiA6IG9wdGlvbnNbc25ha2VDYXNlKGtleSldO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgbGF5ZXJfY3JlYXRlQ2xhc3MoTGF5ZXIsIFt7XG4gICAga2V5OiBcInJlc291cmNlVHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvdXJjZVR5cGUodmFsdWUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5yZXNvdXJjZVR5cGUgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0eXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHR5cGUodmFsdWUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy50eXBlID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHVibGljSWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVibGljSWQodmFsdWUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5wdWJsaWNJZCA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcHVibGljIElELCBmb3JtYXR0ZWQgZm9yIGxheWVyIHBhcmFtZXRlclxuICAgICAqIEBmdW5jdGlvbiBMYXllciNnZXRQdWJsaWNJZFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gcHVibGljIElEXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQdWJsaWNJZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQdWJsaWNJZCgpIHtcbiAgICAgIHZhciByZWY7XG4gICAgICByZXR1cm4gKHJlZiA9IHRoaXMub3B0aW9ucy5wdWJsaWNJZCkgIT0gbnVsbCA/IHJlZi5yZXBsYWNlKC9cXC8vZywgXCI6XCIpIDogdm9pZCAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHB1YmxpYyBJRCwgd2l0aCBmb3JtYXQgaWYgcHJlc2VudFxuICAgICAqIEBmdW5jdGlvbiBMYXllciNnZXRGdWxsUHVibGljSWRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHB1YmxpYyBJRFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RnVsbFB1YmxpY0lkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZ1bGxQdWJsaWNJZCgpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHVibGljSWQoKSArIFwiLlwiICsgdGhpcy5vcHRpb25zLmZvcm1hdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFB1YmxpY0lkKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQodmFsdWUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5mb3JtYXQgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZW5lcmF0ZSB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsYXllclxuICAgICAqIEBmdW5jdGlvbiBMYXllciN0b1N0cmluZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgY29tcG9uZW50cztcbiAgICAgIGNvbXBvbmVudHMgPSBbXTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wdWJsaWNJZCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IFwiTXVzdCBzdXBwbHkgcHVibGljSWRcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKCEodGhpcy5vcHRpb25zLnJlc291cmNlVHlwZSA9PT0gXCJpbWFnZVwiKSkge1xuICAgICAgICBjb21wb25lbnRzLnB1c2godGhpcy5vcHRpb25zLnJlc291cmNlVHlwZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghKHRoaXMub3B0aW9ucy50eXBlID09PSBcInVwbG9hZFwiKSkge1xuICAgICAgICBjb21wb25lbnRzLnB1c2godGhpcy5vcHRpb25zLnR5cGUpO1xuICAgICAgfVxuXG4gICAgICBjb21wb25lbnRzLnB1c2godGhpcy5nZXRGdWxsUHVibGljSWQoKSk7XG4gICAgICByZXR1cm4gY29tcGFjdF9yb290X2NvbXBhY3RfZGVmYXVsdCgpKGNvbXBvbmVudHMpLmpvaW4oXCI6XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMYXllcjtcbn0oKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgbGF5ZXJfbGF5ZXIgPSAobGF5ZXJfTGF5ZXIpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbGF5ZXIvdGV4dGxheWVyLmpzXG5mdW5jdGlvbiB0ZXh0bGF5ZXJfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiB0ZXh0bGF5ZXJfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgdGV4dGxheWVyX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIHRleHRsYXllcl9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIHRleHRsYXllcl9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gdGV4dGxheWVyX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgdGV4dGxheWVyX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSB0ZXh0bGF5ZXJfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gdGV4dGxheWVyX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIHRleHRsYXllcl9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gdGV4dGxheWVyX3NldFByb3RvdHlwZU9mKG8sIHApIHsgdGV4dGxheWVyX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiB0ZXh0bGF5ZXJfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gdGV4dGxheWVyX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSB0ZXh0bGF5ZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gdGV4dGxheWVyX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSB0ZXh0bGF5ZXJfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIHRleHRsYXllcl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gdGV4dGxheWVyX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAodGV4dGxheWVyX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiB0ZXh0bGF5ZXJfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIHRleHRsYXllcl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiB0ZXh0bGF5ZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gdGV4dGxheWVyX2dldFByb3RvdHlwZU9mKG8pIHsgdGV4dGxheWVyX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiB0ZXh0bGF5ZXJfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuXG5cblxudmFyIHRleHRsYXllcl9UZXh0TGF5ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9MYXllcikge1xuICB0ZXh0bGF5ZXJfaW5oZXJpdHMoVGV4dExheWVyLCBfTGF5ZXIpO1xuXG4gIHZhciBfc3VwZXIgPSB0ZXh0bGF5ZXJfY3JlYXRlU3VwZXIoVGV4dExheWVyKTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yIFRleHRMYXllclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGxheWVyIHBhcmFtZXRlcnNcbiAgICovXG4gIGZ1bmN0aW9uIFRleHRMYXllcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdGV4dGxheWVyX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRMYXllcik7XG5cbiAgICB2YXIga2V5cztcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIGtleXMgPSBbXCJyZXNvdXJjZVR5cGVcIiwgXCJyZXNvdXJjZVR5cGVcIiwgXCJmb250RmFtaWx5XCIsIFwiZm9udFNpemVcIiwgXCJmb250V2VpZ2h0XCIsIFwiZm9udFN0eWxlXCIsIFwidGV4dERlY29yYXRpb25cIiwgXCJ0ZXh0QWxpZ25cIiwgXCJzdHJva2VcIiwgXCJsZXR0ZXJTcGFjaW5nXCIsIFwibGluZVNwYWNpbmdcIiwgXCJmb250SGludGluZ1wiLCBcImZvbnRBbnRpYWxpYXNpbmdcIiwgXCJ0ZXh0XCIsIFwidGV4dFN0eWxlXCJdO1xuXG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgcmV0dXJuIF90aGlzLm9wdGlvbnNba2V5XSA9IChyZWYgPSBvcHRpb25zW2tleV0pICE9IG51bGwgPyByZWYgOiBvcHRpb25zW3NuYWtlQ2FzZShrZXkpXTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF90aGlzLm9wdGlvbnMucmVzb3VyY2VUeXBlID0gXCJ0ZXh0XCI7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdGV4dGxheWVyX2NyZWF0ZUNsYXNzKFRleHRMYXllciwgW3tcbiAgICBrZXk6IFwicmVzb3VyY2VUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc291cmNlVHlwZShfcmVzb3VyY2VUeXBlKSB7XG4gICAgICB0aHJvdyBcIkNhbm5vdCBtb2RpZnkgcmVzb3VyY2VUeXBlIGZvciB0ZXh0IGxheWVyc1wiO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0eXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHR5cGUoX3R5cGUpIHtcbiAgICAgIHRocm93IFwiQ2Fubm90IG1vZGlmeSB0eXBlIGZvciB0ZXh0IGxheWVyc1wiO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JtYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KF9mb3JtYXQpIHtcbiAgICAgIHRocm93IFwiQ2Fubm90IG1vZGlmeSBmb3JtYXQgZm9yIHRleHQgbGF5ZXJzXCI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvbnRGYW1pbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9udEZhbWlseShfZm9udEZhbWlseSkge1xuICAgICAgdGhpcy5vcHRpb25zLmZvbnRGYW1pbHkgPSBfZm9udEZhbWlseTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb250U2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb250U2l6ZShfZm9udFNpemUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5mb250U2l6ZSA9IF9mb250U2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb250V2VpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvbnRXZWlnaHQoX2ZvbnRXZWlnaHQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5mb250V2VpZ2h0ID0gX2ZvbnRXZWlnaHQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9udFN0eWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvbnRTdHlsZShfZm9udFN0eWxlKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZm9udFN0eWxlID0gX2ZvbnRTdHlsZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0ZXh0RGVjb3JhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXh0RGVjb3JhdGlvbihfdGV4dERlY29yYXRpb24pIHtcbiAgICAgIHRoaXMub3B0aW9ucy50ZXh0RGVjb3JhdGlvbiA9IF90ZXh0RGVjb3JhdGlvbjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0ZXh0QWxpZ25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGV4dEFsaWduKF90ZXh0QWxpZ24pIHtcbiAgICAgIHRoaXMub3B0aW9ucy50ZXh0QWxpZ24gPSBfdGV4dEFsaWduO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0cm9rZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdHJva2UoX3N0cm9rZSkge1xuICAgICAgdGhpcy5vcHRpb25zLnN0cm9rZSA9IF9zdHJva2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGV0dGVyU3BhY2luZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZXR0ZXJTcGFjaW5nKF9sZXR0ZXJTcGFjaW5nKSB7XG4gICAgICB0aGlzLm9wdGlvbnMubGV0dGVyU3BhY2luZyA9IF9sZXR0ZXJTcGFjaW5nO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxpbmVTcGFjaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpbmVTcGFjaW5nKF9saW5lU3BhY2luZykge1xuICAgICAgdGhpcy5vcHRpb25zLmxpbmVTcGFjaW5nID0gX2xpbmVTcGFjaW5nO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvbnRIaW50aW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvbnRIaW50aW5nKF9mb250SGludGluZykge1xuICAgICAgdGhpcy5vcHRpb25zLmZvbnRIaW50aW5nID0gX2ZvbnRIaW50aW5nO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvbnRBbnRpYWxpYXNpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9udEFudGlhbGlhc2luZyhfZm9udEFudGlhbGlhc2luZykge1xuICAgICAgdGhpcy5vcHRpb25zLmZvbnRBbnRpYWxpYXNpbmcgPSBfZm9udEFudGlhbGlhc2luZztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRleHQoX3RleHQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy50ZXh0ID0gX3RleHQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGV4dFN0eWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRleHRTdHlsZShfdGV4dFN0eWxlKSB7XG4gICAgICB0aGlzLm9wdGlvbnMudGV4dFN0eWxlID0gX3RleHRTdHlsZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZW5lcmF0ZSB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsYXllclxuICAgICAqIEBmdW5jdGlvbiBUZXh0TGF5ZXIjdG9TdHJpbmdcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBjb21wb25lbnRzLCBoYXNQdWJsaWNJZCwgaGFzU3R5bGUsIHB1YmxpY0lkLCByZSwgcmVzLCBzdGFydCwgc3R5bGUsIHRleHQsIHRleHRTb3VyY2U7XG4gICAgICBzdHlsZSA9IHRoaXMudGV4dFN0eWxlSWRlbnRpZmllcigpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnB1YmxpY0lkICE9IG51bGwpIHtcbiAgICAgICAgcHVibGljSWQgPSB0aGlzLmdldEZ1bGxQdWJsaWNJZCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRleHQgIT0gbnVsbCkge1xuICAgICAgICBoYXNQdWJsaWNJZCA9ICFpc0VtcHR5KHB1YmxpY0lkKTtcbiAgICAgICAgaGFzU3R5bGUgPSAhaXNFbXB0eShzdHlsZSk7XG5cbiAgICAgICAgaWYgKGhhc1B1YmxpY0lkICYmIGhhc1N0eWxlIHx8ICFoYXNQdWJsaWNJZCAmJiAhaGFzU3R5bGUpIHtcbiAgICAgICAgICB0aHJvdyBcIk11c3Qgc3VwcGx5IGVpdGhlciBzdHlsZSBwYXJhbWV0ZXJzIG9yIGEgcHVibGljX2lkIHdoZW4gcHJvdmlkaW5nIHRleHQgcGFyYW1ldGVyIGluIGEgdGV4dCBvdmVybGF5L3VuZGVybGF5LCBidXQgbm90IGJvdGghXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZSA9IC9cXCRcXChbYS16QS1aXVxcdypcXCkvZztcbiAgICAgICAgc3RhcnQgPSAwOyAvLyAgICAgICAgdGV4dFNvdXJjZSA9IHRleHQucmVwbGFjZShuZXcgUmVnRXhwKFwiWywvXVwiLCAnZycpLCAoYyktPiBcIiUje2MuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKX1cIilcblxuICAgICAgICB0ZXh0U291cmNlID0gc21hcnRFc2NhcGUodGhpcy5vcHRpb25zLnRleHQsIC9bLFxcL10vZyk7XG4gICAgICAgIHRleHQgPSBcIlwiO1xuXG4gICAgICAgIHdoaWxlIChyZXMgPSByZS5leGVjKHRleHRTb3VyY2UpKSB7XG4gICAgICAgICAgdGV4dCArPSBzbWFydEVzY2FwZSh0ZXh0U291cmNlLnNsaWNlKHN0YXJ0LCByZXMuaW5kZXgpKTtcbiAgICAgICAgICB0ZXh0ICs9IHJlc1swXTtcbiAgICAgICAgICBzdGFydCA9IHJlcy5pbmRleCArIHJlc1swXS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0ICs9IHNtYXJ0RXNjYXBlKHRleHRTb3VyY2Uuc2xpY2Uoc3RhcnQpKTtcbiAgICAgIH1cblxuICAgICAgY29tcG9uZW50cyA9IFt0aGlzLm9wdGlvbnMucmVzb3VyY2VUeXBlLCBzdHlsZSwgcHVibGljSWQsIHRleHRdO1xuICAgICAgcmV0dXJuIGNvbXBhY3Rfcm9vdF9jb21wYWN0X2RlZmF1bHQoKShjb21wb25lbnRzKS5qb2luKFwiOlwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGV4dFN0eWxlSWRlbnRpZmllclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXh0U3R5bGVJZGVudGlmaWVyKCkge1xuICAgICAgLy8gTm90ZTogaWYgYSB0ZXh0LXN0eWxlIGFyZ3VtZW50IGlzIHByb3ZpZGVkIGFzIGEgd2hvbGUsIGl0IG92ZXJyaWRlcyBldmVyeXRoaW5nIGVsc2UsIG5vIG1peCBhbmQgbWF0Y2guXG4gICAgICBpZiAoIWlzRW1wdHkodGhpcy5vcHRpb25zLnRleHRTdHlsZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy50ZXh0U3R5bGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21wb25lbnRzO1xuICAgICAgY29tcG9uZW50cyA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmZvbnRXZWlnaHQgIT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKHRoaXMub3B0aW9ucy5mb250V2VpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5mb250U3R5bGUgIT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKHRoaXMub3B0aW9ucy5mb250U3R5bGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRleHREZWNvcmF0aW9uICE9PSBcIm5vbmVcIikge1xuICAgICAgICBjb21wb25lbnRzLnB1c2godGhpcy5vcHRpb25zLnRleHREZWNvcmF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgY29tcG9uZW50cy5wdXNoKHRoaXMub3B0aW9ucy50ZXh0QWxpZ24pO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN0cm9rZSAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKHRoaXMub3B0aW9ucy5zdHJva2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIShpc0VtcHR5KHRoaXMub3B0aW9ucy5sZXR0ZXJTcGFjaW5nKSAmJiAhaXNOdW1iZXJMaWtlKHRoaXMub3B0aW9ucy5sZXR0ZXJTcGFjaW5nKSkpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKFwibGV0dGVyX3NwYWNpbmdfXCIgKyB0aGlzLm9wdGlvbnMubGV0dGVyU3BhY2luZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghKGlzRW1wdHkodGhpcy5vcHRpb25zLmxpbmVTcGFjaW5nKSAmJiAhaXNOdW1iZXJMaWtlKHRoaXMub3B0aW9ucy5saW5lU3BhY2luZykpKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaChcImxpbmVfc3BhY2luZ19cIiArIHRoaXMub3B0aW9ucy5saW5lU3BhY2luZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNFbXB0eSh0aGlzLm9wdGlvbnMuZm9udEFudGlhbGlhc2luZykpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKFwiYW50aWFsaWFzX1wiICsgdGhpcy5vcHRpb25zLmZvbnRBbnRpYWxpYXNpbmcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzRW1wdHkodGhpcy5vcHRpb25zLmZvbnRIaW50aW5nKSkge1xuICAgICAgICBjb21wb25lbnRzLnB1c2goXCJoaW50aW5nX1wiICsgdGhpcy5vcHRpb25zLmZvbnRIaW50aW5nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0VtcHR5KGNvbXBhY3Rfcm9vdF9jb21wYWN0X2RlZmF1bHQoKShjb21wb25lbnRzKSkpIHtcbiAgICAgICAgaWYgKGlzRW1wdHkodGhpcy5vcHRpb25zLmZvbnRGYW1pbHkpKSB7XG4gICAgICAgICAgdGhyb3cgXCJNdXN0IHN1cHBseSBmb250RmFtaWx5LiBcIi5jb25jYXQoY29tcG9uZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNFbXB0eSh0aGlzLm9wdGlvbnMuZm9udFNpemUpICYmICFpc051bWJlckxpa2UodGhpcy5vcHRpb25zLmZvbnRTaXplKSkge1xuICAgICAgICAgIHRocm93IFwiTXVzdCBzdXBwbHkgZm9udFNpemUuXCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29tcG9uZW50cy51bnNoaWZ0KHRoaXMub3B0aW9ucy5mb250RmFtaWx5LCB0aGlzLm9wdGlvbnMuZm9udFNpemUpO1xuICAgICAgY29tcG9uZW50cyA9IGNvbXBhY3Rfcm9vdF9jb21wYWN0X2RlZmF1bHQoKShjb21wb25lbnRzKS5qb2luKFwiX1wiKTtcbiAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUZXh0TGF5ZXI7XG59KGxheWVyX2xheWVyKTtcblxuO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdGV4dGxheWVyID0gKHRleHRsYXllcl9UZXh0TGF5ZXIpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbGF5ZXIvc3VidGl0bGVzbGF5ZXIuanNcbmZ1bmN0aW9uIHN1YnRpdGxlc2xheWVyX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gc3VidGl0bGVzbGF5ZXJfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgc3VidGl0bGVzbGF5ZXJfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIHN1YnRpdGxlc2xheWVyX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgc3VidGl0bGVzbGF5ZXJfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIHN1YnRpdGxlc2xheWVyX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIHN1YnRpdGxlc2xheWVyX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgc3VidGl0bGVzbGF5ZXJfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIHN1YnRpdGxlc2xheWVyX3NldFByb3RvdHlwZU9mKG8sIHApIHsgc3VidGl0bGVzbGF5ZXJfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIHN1YnRpdGxlc2xheWVyX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIHN1YnRpdGxlc2xheWVyX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBzdWJ0aXRsZXNsYXllcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBzdWJ0aXRsZXNsYXllcl9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gc3VidGl0bGVzbGF5ZXJfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIHN1YnRpdGxlc2xheWVyX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKHN1YnRpdGxlc2xheWVyX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBzdWJ0aXRsZXNsYXllcl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfZ2V0UHJvdG90eXBlT2YobykgeyBzdWJ0aXRsZXNsYXllcl9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gc3VidGl0bGVzbGF5ZXJfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuXG5cbnZhciBTdWJ0aXRsZXNMYXllciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1RleHRMYXllcikge1xuICBzdWJ0aXRsZXNsYXllcl9pbmhlcml0cyhTdWJ0aXRsZXNMYXllciwgX1RleHRMYXllcik7XG5cbiAgdmFyIF9zdXBlciA9IHN1YnRpdGxlc2xheWVyX2NyZWF0ZVN1cGVyKFN1YnRpdGxlc0xheWVyKTtcblxuICAvKipcbiAgICogUmVwcmVzZW50IGEgc3VidGl0bGVzIGxheWVyXG4gICAqIEBjb25zdHJ1Y3RvciBTdWJ0aXRsZXNMYXllclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGxheWVyIHBhcmFtZXRlcnNcbiAgICovXG4gIGZ1bmN0aW9uIFN1YnRpdGxlc0xheWVyKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBzdWJ0aXRsZXNsYXllcl9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdWJ0aXRsZXNMYXllcik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIF90aGlzLm9wdGlvbnMucmVzb3VyY2VUeXBlID0gXCJzdWJ0aXRsZXNcIjtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gc3VidGl0bGVzbGF5ZXJfY3JlYXRlQ2xhc3MoU3VidGl0bGVzTGF5ZXIpO1xufSh0ZXh0bGF5ZXIpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzdWJ0aXRsZXNsYXllciA9IChTdWJ0aXRsZXNMYXllcik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9sYXllci9mZXRjaGxheWVyLmpzXG5mdW5jdGlvbiBmZXRjaGxheWVyX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gZmV0Y2hsYXllcl90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBmZXRjaGxheWVyX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIGZldGNobGF5ZXJfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBmZXRjaGxheWVyX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBmZXRjaGxheWVyX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZmV0Y2hsYXllcl9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZmV0Y2hsYXllcl9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBmZXRjaGxheWVyX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIGZldGNobGF5ZXJfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIGZldGNobGF5ZXJfc2V0UHJvdG90eXBlT2YobywgcCkgeyBmZXRjaGxheWVyX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBmZXRjaGxheWVyX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIGZldGNobGF5ZXJfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZldGNobGF5ZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gZmV0Y2hsYXllcl9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gZmV0Y2hsYXllcl9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gZmV0Y2hsYXllcl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gZmV0Y2hsYXllcl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKGZldGNobGF5ZXJfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIGZldGNobGF5ZXJfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIGZldGNobGF5ZXJfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gZmV0Y2hsYXllcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBmZXRjaGxheWVyX2dldFByb3RvdHlwZU9mKG8pIHsgZmV0Y2hsYXllcl9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gZmV0Y2hsYXllcl9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5cblxuXG52YXIgZmV0Y2hsYXllcl9GZXRjaExheWVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTGF5ZXIpIHtcbiAgZmV0Y2hsYXllcl9pbmhlcml0cyhGZXRjaExheWVyLCBfTGF5ZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBmZXRjaGxheWVyX2NyZWF0ZVN1cGVyKEZldGNoTGF5ZXIpO1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgRmV0Y2hMYXllclxuICAgKiBAY2xhc3NkZXNjIENyZWF0ZXMgYW4gaW1hZ2UgbGF5ZXIgdXNpbmcgYSByZW1vdGUgVVJMLlxuICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IG9wdGlvbnMgLSBsYXllciBwYXJhbWV0ZXJzIG9yIGEgdXJsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnVybCB0aGUgdXJsIG9mIHRoZSBpbWFnZSB0byBmZXRjaFxuICAgKi9cbiAgZnVuY3Rpb24gRmV0Y2hMYXllcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgZmV0Y2hsYXllcl9jbGFzc0NhbGxDaGVjayh0aGlzLCBGZXRjaExheWVyKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgICBpZiAoaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkob3B0aW9ucykpIHtcbiAgICAgIF90aGlzLm9wdGlvbnMudXJsID0gb3B0aW9ucztcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMudXJsIDogdm9pZCAwKSB7XG4gICAgICBfdGhpcy5vcHRpb25zLnVybCA9IG9wdGlvbnMudXJsO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIGZldGNobGF5ZXJfY3JlYXRlQ2xhc3MoRmV0Y2hMYXllciwgW3tcbiAgICBrZXk6IFwidXJsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVybChfdXJsKSB7XG4gICAgICB0aGlzLm9wdGlvbnMudXJsID0gX3VybDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZW5lcmF0ZSB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsYXllclxuICAgICAqIEBmdW5jdGlvbiBGZXRjaExheWVyI3RvU3RyaW5nXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJmZXRjaDpcIi5jb25jYXQoYmFzZTY0RW5jb2RlVVJMKHRoaXMub3B0aW9ucy51cmwpKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRmV0Y2hMYXllcjtcbn0obGF5ZXJfbGF5ZXIpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBmZXRjaGxheWVyID0gKGZldGNobGF5ZXJfRmV0Y2hMYXllcik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9wYXJhbWV0ZXJzLmpzXG5mdW5jdGlvbiBwYXJhbWV0ZXJzX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gcGFyYW1ldGVyc190eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBwYXJhbWV0ZXJzX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9nZXQoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQuYmluZCgpOyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogcmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBwYXJhbWV0ZXJzX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gcGFyYW1ldGVyc19pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBwYXJhbWV0ZXJzX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBwYXJhbWV0ZXJzX3NldFByb3RvdHlwZU9mKG8sIHApIHsgcGFyYW1ldGVyc19zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gcGFyYW1ldGVyc19zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBwYXJhbWV0ZXJzX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBwYXJhbWV0ZXJzX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IHBhcmFtZXRlcnNfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IHBhcmFtZXRlcnNfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIHBhcmFtZXRlcnNfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIHBhcmFtZXRlcnNfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChwYXJhbWV0ZXJzX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBwYXJhbWV0ZXJzX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBwYXJhbWV0ZXJzX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIHBhcmFtZXRlcnNfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gcGFyYW1ldGVyc19nZXRQcm90b3R5cGVPZihvKSB7IHBhcmFtZXRlcnNfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIHBhcmFtZXRlcnNfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gcGFyYW1ldGVyc19jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIHBhcmFtZXRlcnNfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIHBhcmFtZXRlcnNfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBwYXJhbWV0ZXJzX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBwYXJhbWV0ZXJzX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cblxuXG5cblxuXG5cblxuLyoqXG4gKiBUcmFuc2Zvcm1hdGlvbiBwYXJhbWV0ZXJzXG4gKiBEZXBlbmRzIG9uICd1dGlsJywgJ3RyYW5zZm9ybWF0aW9uJ1xuICovXG5cbnZhciBwYXJhbWV0ZXJzX1BhcmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBzaW5nbGUgcGFyYW1ldGVyLlxuICAgKiBAY2xhc3MgUGFyYW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyIGluIHNuYWtlX2Nhc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNob3J0TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzZXJpYWxpemVkIGZvcm0gb2YgdGhlIHBhcmFtZXRlci5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgSWYgYSB2YWx1ZSBpcyBub3QgcHJvdmlkZWQsIHRoZSBwYXJhbWV0ZXIgd2lsbCBub3QgYmUgc2VyaWFsaXplZC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW3Byb2Nlc3M9VXRpbC5pZGVudGl0eSBdIC0gTWFuaXB1bGF0ZSBvcmlnVmFsdWUgd2hlbiB2YWx1ZSBpcyBjYWxsZWRcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZnVuY3Rpb24gUGFyYW0obmFtZSwgc2hvcnROYW1lKSB7XG4gICAgdmFyIHByb2Nlc3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGlkZW50aXR5X3Jvb3RfaWRlbnRpdHlfZGVmYXVsdC5hO1xuXG4gICAgcGFyYW1ldGVyc19jbGFzc0NhbGxDaGVjayh0aGlzLCBQYXJhbSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyIGluIHNuYWtlX2Nhc2VcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IFBhcmFtI25hbWVcbiAgICAgKi9cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBzZXJpYWxpemVkIGZvcm0gb2YgdGhlIHBhcmFtZXRlclxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gUGFyYW0jc2hvcnROYW1lXG4gICAgICovXG5cbiAgICB0aGlzLnNob3J0TmFtZSA9IHNob3J0TmFtZTtcbiAgICAvKipcbiAgICAgKiBNYW5pcHVsYXRlIG9yaWdWYWx1ZSB3aGVuIHZhbHVlIGlzIGNhbGxlZFxuICAgICAqIEBtZW1iZXIge2Z1bmN0aW9ufSBQYXJhbSNwcm9jZXNzXG4gICAgICovXG5cbiAgICB0aGlzLnByb2Nlc3MgPSBwcm9jZXNzO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgYSAodW5wcm9jZXNzZWQpIHZhbHVlIGZvciB0aGlzIHBhcmFtZXRlclxuICAgKiBAZnVuY3Rpb24gUGFyYW0jc2V0XG4gICAqIEBwYXJhbSB7Kn0gb3JpZ1ZhbHVlIC0gdGhlIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXJcbiAgICogQHJldHVybiB7UGFyYW19IHNlbGYgZm9yIGNoYWluaW5nXG4gICAqL1xuXG5cbiAgcGFyYW1ldGVyc19jcmVhdGVDbGFzcyhQYXJhbSwgW3tcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChvcmlnVmFsdWUpIHtcbiAgICAgIHRoaXMub3JpZ1ZhbHVlID0gb3JpZ1ZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHRoZSBzZXJpYWxpemVkIGZvcm0gb2YgdGhlIHBhcmFtZXRlclxuICAgICAqIEBmdW5jdGlvbiBQYXJhbSNzZXJpYWxpemVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBzZXJpYWxpemVkIGZvcm0gb2YgdGhlIHBhcmFtZXRlclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIHZhciB2YWwsIHZhbGlkO1xuICAgICAgdmFsID0gdGhpcy52YWx1ZSgpO1xuICAgICAgdmFsaWQgPSBpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkodmFsKSB8fCBpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0KCkodmFsKSB8fCBpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQoKSh2YWwpID8gIWlzRW1wdHkodmFsKSA6IHZhbCAhPSBudWxsO1xuXG4gICAgICBpZiAodGhpcy5zaG9ydE5hbWUgIT0gbnVsbCAmJiB2YWxpZCkge1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5zaG9ydE5hbWUsIFwiX1wiKS5jb25jYXQodmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBwcm9jZXNzZWQgdmFsdWUgb2YgdGhlIHBhcmFtZXRlclxuICAgICAqIEBmdW5jdGlvbiBQYXJhbSN2YWx1ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzKHRoaXMub3JpZ1ZhbHVlKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJub3JtX2NvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vcm1fY29sb3IodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsID8gdmFsdWUucmVwbGFjZSgvXiMvLCAncmdiOicpIDogdm9pZCAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJidWlsZF9hcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZF9hcnJheShhcmcpIHtcbiAgICAgIGlmIChhcmcgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKShhcmcpKSB7XG4gICAgICAgIHJldHVybiBhcmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW2FyZ107XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogQ292ZXJ0IHZhbHVlIHRvIHZpZGVvIGNvZGVjIHN0cmluZy5cbiAgICAqXG4gICAgKiBJZiB0aGUgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCxcbiAgICAqIEBwYXJhbSB7KHN0cmluZ3xPYmplY3QpfSBwYXJhbSAtIHRoZSB2aWRlbyBjb2RlYyBhcyBlaXRoZXIgYSBTdHJpbmcgb3IgYSBIYXNoXG4gICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSB2aWRlbyBjb2RlYyBzdHJpbmcgaW4gdGhlIGZvcm1hdCBjb2RlYzpwcm9maWxlOmxldmVsOmJfZnJhbWVzXG4gICAgKiBAZXhhbXBsZVxuICAgICogdmNfWyA6cHJvZmlsZSA6IFtsZXZlbCA6IFtiX2ZyYW1lc11dXVxuICAgICogb3JcbiAgICAgIHsgY29kZWM6ICdoMjY0JywgcHJvZmlsZTogJ2Jhc2ljJywgbGV2ZWw6ICczLjEnLCBiX2ZyYW1lczogZmFsc2UgfVxuICAgICogQGlnbm9yZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHJvY2Vzc192aWRlb19wYXJhbXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc192aWRlb19wYXJhbXMocGFyYW0pIHtcbiAgICAgIHZhciB2aWRlbztcblxuICAgICAgc3dpdGNoIChwYXJhbS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICBjYXNlIE9iamVjdDpcbiAgICAgICAgICB2aWRlbyA9IFwiXCI7XG5cbiAgICAgICAgICBpZiAoJ2NvZGVjJyBpbiBwYXJhbSkge1xuICAgICAgICAgICAgdmlkZW8gPSBwYXJhbS5jb2RlYztcblxuICAgICAgICAgICAgaWYgKCdwcm9maWxlJyBpbiBwYXJhbSkge1xuICAgICAgICAgICAgICB2aWRlbyArPSBcIjpcIiArIHBhcmFtLnByb2ZpbGU7XG5cbiAgICAgICAgICAgICAgaWYgKCdsZXZlbCcgaW4gcGFyYW0pIHtcbiAgICAgICAgICAgICAgICB2aWRlbyArPSBcIjpcIiArIHBhcmFtLmxldmVsO1xuXG4gICAgICAgICAgICAgICAgaWYgKCdiX2ZyYW1lcycgaW4gcGFyYW0gJiYgcGFyYW0uYl9mcmFtZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICB2aWRlbyArPSBcIjpiZnJhbWVzX25vXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHZpZGVvO1xuXG4gICAgICAgIGNhc2UgU3RyaW5nOlxuICAgICAgICAgIHJldHVybiBwYXJhbTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQYXJhbTtcbn0oKTtcblxudmFyIHBhcmFtZXRlcnNfQXJyYXlQYXJhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1BhcmFtKSB7XG4gIHBhcmFtZXRlcnNfaW5oZXJpdHMoQXJyYXlQYXJhbSwgX1BhcmFtKTtcblxuICB2YXIgX3N1cGVyID0gcGFyYW1ldGVyc19jcmVhdGVTdXBlcihBcnJheVBhcmFtKTtcblxuICAvKipcbiAgICogQSBwYXJhbWV0ZXIgdGhhdCByZXByZXNlbnRzIGFuIGFycmF5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIgaW4gc25ha2VfY2FzZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNob3J0TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzZXJpYWxpemVkIGZvcm0gb2YgdGhlIHBhcmFtZXRlclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBJZiBhIHZhbHVlIGlzIG5vdCBwcm92aWRlZCwgdGhlIHBhcmFtZXRlciB3aWxsIG5vdCBiZSBzZXJpYWxpemVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3NlcD0nLiddIC0gVGhlIHNlcGFyYXRvciB0byB1c2Ugd2hlbiBqb2luaW5nIHRoZSBhcnJheSBlbGVtZW50cyB0b2dldGhlclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcHJvY2Vzcz1VdGlsLmlkZW50aXR5IF0gLSBNYW5pcHVsYXRlIG9yaWdWYWx1ZSB3aGVuIHZhbHVlIGlzIGNhbGxlZFxuICAgKiBAY2xhc3MgQXJyYXlQYXJhbVxuICAgKiBAZXh0ZW5kcyBQYXJhbVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBBcnJheVBhcmFtKG5hbWUsIHNob3J0TmFtZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIHZhciBzZXAgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICcuJztcbiAgICB2YXIgcHJvY2VzcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuXG4gICAgcGFyYW1ldGVyc19jbGFzc0NhbGxDaGVjayh0aGlzLCBBcnJheVBhcmFtKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgc2hvcnROYW1lLCBwcm9jZXNzKTtcbiAgICBfdGhpcy5zZXAgPSBzZXA7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcGFyYW1ldGVyc19jcmVhdGVDbGFzcyhBcnJheVBhcmFtLCBbe1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgaWYgKHRoaXMuc2hvcnROYW1lICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGFycmF5VmFsdWUgPSB0aGlzLnZhbHVlKCk7XG5cbiAgICAgICAgaWYgKGlzRW1wdHkoYXJyYXlWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkoYXJyYXlWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5zaG9ydE5hbWUsIFwiX1wiKS5jb25jYXQoYXJyYXlWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGZsYXQgPSBhcnJheVZhbHVlLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKSh0LnNlcmlhbGl6ZSkgPyB0LnNlcmlhbGl6ZSgpIDogdDtcbiAgICAgICAgICB9KS5qb2luKHRoaXMuc2VwKTtcbiAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5zaG9ydE5hbWUsIFwiX1wiKS5jb25jYXQoZmxhdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKSh0aGlzLm9yaWdWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ1ZhbHVlLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgIHJldHVybiBfdGhpczIucHJvY2Vzcyh2KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzKHRoaXMub3JpZ1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChvcmlnVmFsdWUpIHtcbiAgICAgIGlmIChvcmlnVmFsdWUgPT0gbnVsbCB8fCBpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkob3JpZ1ZhbHVlKSkge1xuICAgICAgICByZXR1cm4gX2dldChwYXJhbWV0ZXJzX2dldFByb3RvdHlwZU9mKEFycmF5UGFyYW0ucHJvdG90eXBlKSwgXCJzZXRcIiwgdGhpcykuY2FsbCh0aGlzLCBvcmlnVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF9nZXQocGFyYW1ldGVyc19nZXRQcm90b3R5cGVPZihBcnJheVBhcmFtLnByb3RvdHlwZSksIFwic2V0XCIsIHRoaXMpLmNhbGwodGhpcywgW29yaWdWYWx1ZV0pO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBcnJheVBhcmFtO1xufShwYXJhbWV0ZXJzX1BhcmFtKTtcblxudmFyIHBhcmFtZXRlcnNfVHJhbnNmb3JtYXRpb25QYXJhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1BhcmFtMikge1xuICBwYXJhbWV0ZXJzX2luaGVyaXRzKFRyYW5zZm9ybWF0aW9uUGFyYW0sIF9QYXJhbTIpO1xuXG4gIHZhciBfc3VwZXIyID0gcGFyYW1ldGVyc19jcmVhdGVTdXBlcihUcmFuc2Zvcm1hdGlvblBhcmFtKTtcblxuICAvKipcbiAgICogQSBwYXJhbWV0ZXIgdGhhdCByZXByZXNlbnRzIGEgdHJhbnNmb3JtYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyIGluIHNuYWtlX2Nhc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzaG9ydE5hbWU9J3QnXSAtIFRoZSBuYW1lIG9mIHRoZSBzZXJpYWxpemVkIGZvcm0gb2YgdGhlIHBhcmFtZXRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3NlcD0nLiddIC0gVGhlIHNlcGFyYXRvciB0byB1c2Ugd2hlbiBqb2luaW5nIHRoZSBhcnJheSBlbGVtZW50cyB0b2dldGhlclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcHJvY2Vzcz1VdGlsLmlkZW50aXR5IF0gLSBNYW5pcHVsYXRlIG9yaWdWYWx1ZSB3aGVuIHZhbHVlIGlzIGNhbGxlZFxuICAgKiBAY2xhc3MgVHJhbnNmb3JtYXRpb25QYXJhbVxuICAgKiBAZXh0ZW5kcyBQYXJhbVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvblBhcmFtKG5hbWUpIHtcbiAgICB2YXIgX3RoaXMzO1xuXG4gICAgdmFyIHNob3J0TmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJ0XCI7XG4gICAgdmFyIHNlcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJy4nO1xuICAgIHZhciBwcm9jZXNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG5cbiAgICBwYXJhbWV0ZXJzX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYW5zZm9ybWF0aW9uUGFyYW0pO1xuXG4gICAgX3RoaXMzID0gX3N1cGVyMi5jYWxsKHRoaXMsIG5hbWUsIHNob3J0TmFtZSwgcHJvY2Vzcyk7XG4gICAgX3RoaXMzLnNlcCA9IHNlcDtcbiAgICByZXR1cm4gX3RoaXMzO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBzdHJpbmcgcmVwcmVzZW50YXRpb25zIG9mIHRoZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgZWl0aGVyIHRoZSB0cmFuc2Zvcm1hdGlvbiBhcyBhIHN0cmluZywgb3IgYW4gYXJyYXkgb2Ygc3RyaW5nIHJlcHJlc2VudGF0aW9ucy5cbiAgICovXG5cblxuICBwYXJhbWV0ZXJzX2NyZWF0ZUNsYXNzKFRyYW5zZm9ybWF0aW9uUGFyYW0sIFt7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgdmFyIHZhbCA9IHRoaXMudmFsdWUoKTtcblxuICAgICAgaWYgKGlzRW1wdHkodmFsKSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSAvLyB2YWwgaXMgYW4gYXJyYXkgb2Ygc3RyaW5ncyBzbyBqb2luIHRoZW1cblxuXG4gICAgICBpZiAoYmFzZXV0aWxfYWxsU3RyaW5ncyh2YWwpKSB7XG4gICAgICAgIHZhciBqb2luZWQgPSB2YWwuam9pbih0aGlzLnNlcCk7IC8vIGNyZWF0ZXMgdDEudDIudDMgaW4gY2FzZSBtdWx0aXBsZSBuYW1lZCB0cmFuc2Zvcm1hdGlvbnMgd2VyZSBjb25maWd1cmVkXG5cbiAgICAgICAgaWYgKCFpc0VtcHR5KGpvaW5lZCkpIHtcbiAgICAgICAgICAvLyBpbiBjYXNlIG9wdGlvbnMudHJhbnNmb3JtYXRpb24gd2FzIG5vdCBzZXQgd2l0aCBhbiBlbXB0eSBzdHJpbmcgKHZhbCAhPSBbJyddKTtcbiAgICAgICAgICByZXN1bHQgPSBcIlwiLmNvbmNhdCh0aGlzLnNob3J0TmFtZSwgXCJfXCIpLmNvbmNhdChqb2luZWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb252ZXJ0IHZhbCB0byBhbiBhcnJheSBvZiBzdHJpbmdzXG4gICAgICAgIHJlc3VsdCA9IHZhbC5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBpZiAoaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkodCkgJiYgIWlzRW1wdHkodCkpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChfdGhpczQuc2hvcnROYW1lLCBcIl9cIikuY29uY2F0KHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkodC5zZXJpYWxpemUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdC5zZXJpYWxpemUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfZGVmYXVsdCgpKHQpICYmICFpc0VtcHR5KHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHNyY190cmFuc2Zvcm1hdGlvbih0KS5zZXJpYWxpemUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQob3JpZ1ZhbHVlMSkge1xuICAgICAgdGhpcy5vcmlnVmFsdWUgPSBvcmlnVmFsdWUxO1xuXG4gICAgICBpZiAoaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHRoaXMub3JpZ1ZhbHVlKSkge1xuICAgICAgICByZXR1cm4gX2dldChwYXJhbWV0ZXJzX2dldFByb3RvdHlwZU9mKFRyYW5zZm9ybWF0aW9uUGFyYW0ucHJvdG90eXBlKSwgXCJzZXRcIiwgdGhpcykuY2FsbCh0aGlzLCB0aGlzLm9yaWdWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gX2dldChwYXJhbWV0ZXJzX2dldFByb3RvdHlwZU9mKFRyYW5zZm9ybWF0aW9uUGFyYW0ucHJvdG90eXBlKSwgXCJzZXRcIiwgdGhpcykuY2FsbCh0aGlzLCBbdGhpcy5vcmlnVmFsdWVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVHJhbnNmb3JtYXRpb25QYXJhbTtcbn0ocGFyYW1ldGVyc19QYXJhbSk7XG5cbnZhciBudW1iZXJfcGF0dGVybiA9IFwiKFswLTldKilcXFxcLihbMC05XSspfChbMC05XSspXCI7XG52YXIgb2Zmc2V0X2FueV9wYXR0ZXJuID0gXCIoXCIgKyBudW1iZXJfcGF0dGVybiArIFwiKShbJXBQXSk/XCI7XG5cbnZhciBwYXJhbWV0ZXJzX1JhbmdlUGFyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QYXJhbTMpIHtcbiAgcGFyYW1ldGVyc19pbmhlcml0cyhSYW5nZVBhcmFtLCBfUGFyYW0zKTtcblxuICB2YXIgX3N1cGVyMyA9IHBhcmFtZXRlcnNfY3JlYXRlU3VwZXIoUmFuZ2VQYXJhbSk7XG5cbiAgLyoqXG4gICAqIEEgcGFyYW1ldGVyIHRoYXQgcmVwcmVzZW50cyBhIHJhbmdlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciBpbiBzbmFrZV9jYXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzaG9ydE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgc2VyaWFsaXplZCBmb3JtIG9mIHRoZSBwYXJhbWV0ZXJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgSWYgYSB2YWx1ZSBpcyBub3QgcHJvdmlkZWQsIHRoZSBwYXJhbWV0ZXIgd2lsbCBub3QgYmUgc2VyaWFsaXplZC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW3Byb2Nlc3M9bm9ybV9yYW5nZV92YWx1ZSBdIC0gTWFuaXB1bGF0ZSBvcmlnVmFsdWUgd2hlbiB2YWx1ZSBpcyBjYWxsZWRcbiAgICogQGNsYXNzIFJhbmdlUGFyYW1cbiAgICogQGV4dGVuZHMgUGFyYW1cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZnVuY3Rpb24gUmFuZ2VQYXJhbShuYW1lLCBzaG9ydE5hbWUpIHtcbiAgICB2YXIgcHJvY2VzcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogUmFuZ2VQYXJhbS5ub3JtX3JhbmdlX3ZhbHVlO1xuXG4gICAgcGFyYW1ldGVyc19jbGFzc0NhbGxDaGVjayh0aGlzLCBSYW5nZVBhcmFtKTtcblxuICAgIHJldHVybiBfc3VwZXIzLmNhbGwodGhpcywgbmFtZSwgc2hvcnROYW1lLCBwcm9jZXNzKTtcbiAgfVxuXG4gIHBhcmFtZXRlcnNfY3JlYXRlQ2xhc3MoUmFuZ2VQYXJhbSwgbnVsbCwgW3tcbiAgICBrZXk6IFwibm9ybV9yYW5nZV92YWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3JtX3JhbmdlX3ZhbHVlKHZhbHVlKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gU3RyaW5nKHZhbHVlKS5tYXRjaChuZXcgUmVnRXhwKCdeJyArIG9mZnNldF9hbnlfcGF0dGVybiArICckJykpO1xuXG4gICAgICBpZiAob2Zmc2V0KSB7XG4gICAgICAgIHZhciBtb2RpZmllciA9IG9mZnNldFs1XSAhPSBudWxsID8gJ3AnIDogJyc7XG4gICAgICAgIHZhbHVlID0gKG9mZnNldFsxXSB8fCBvZmZzZXRbNF0pICsgbW9kaWZpZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHByZXNzaW9uLm5vcm1hbGl6ZSh2YWx1ZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJhbmdlUGFyYW07XG59KHBhcmFtZXRlcnNfUGFyYW0pO1xuXG52YXIgcGFyYW1ldGVyc19SYXdQYXJhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1BhcmFtNCkge1xuICBwYXJhbWV0ZXJzX2luaGVyaXRzKFJhd1BhcmFtLCBfUGFyYW00KTtcblxuICB2YXIgX3N1cGVyNCA9IHBhcmFtZXRlcnNfY3JlYXRlU3VwZXIoUmF3UGFyYW0pO1xuXG4gIGZ1bmN0aW9uIFJhd1BhcmFtKG5hbWUsIHNob3J0TmFtZSkge1xuICAgIHZhciBwcm9jZXNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBpZGVudGl0eV9yb290X2lkZW50aXR5X2RlZmF1bHQuYTtcblxuICAgIHBhcmFtZXRlcnNfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmF3UGFyYW0pO1xuXG4gICAgcmV0dXJuIF9zdXBlcjQuY2FsbCh0aGlzLCBuYW1lLCBzaG9ydE5hbWUsIHByb2Nlc3MpO1xuICB9XG5cbiAgcGFyYW1ldGVyc19jcmVhdGVDbGFzcyhSYXdQYXJhbSwgW3tcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJhd1BhcmFtO1xufShwYXJhbWV0ZXJzX1BhcmFtKTtcblxudmFyIHBhcmFtZXRlcnNfTGF5ZXJQYXJhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1BhcmFtNSkge1xuICBwYXJhbWV0ZXJzX2luaGVyaXRzKExheWVyUGFyYW0sIF9QYXJhbTUpO1xuXG4gIHZhciBfc3VwZXI1ID0gcGFyYW1ldGVyc19jcmVhdGVTdXBlcihMYXllclBhcmFtKTtcblxuICBmdW5jdGlvbiBMYXllclBhcmFtKCkge1xuICAgIHBhcmFtZXRlcnNfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGF5ZXJQYXJhbSk7XG5cbiAgICByZXR1cm4gX3N1cGVyNS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcGFyYW1ldGVyc19jcmVhdGVDbGFzcyhMYXllclBhcmFtLCBbe1xuICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgIHZhbHVlOiAvLyBQYXJzZSBsYXllciBvcHRpb25zXG4gICAgLy8gQHJldHVybiBbc3RyaW5nXSBsYXllciB0cmFuc2Zvcm1hdGlvbiBzdHJpbmdcbiAgICAvLyBAcHJpdmF0ZVxuICAgIGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgaWYgKHRoaXMub3JpZ1ZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBpZiAodGhpcy5vcmlnVmFsdWUgaW5zdGFuY2VvZiBsYXllcl9sYXllcikge1xuICAgICAgICByZXN1bHQgPSB0aGlzLm9yaWdWYWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfZGVmYXVsdCgpKHRoaXMub3JpZ1ZhbHVlKSkge1xuICAgICAgICB2YXIgbGF5ZXJPcHRpb25zID0gd2l0aENhbWVsQ2FzZUtleXModGhpcy5vcmlnVmFsdWUpO1xuXG4gICAgICAgIGlmIChsYXllck9wdGlvbnMucmVzb3VyY2VUeXBlID09PSBcInRleHRcIiB8fCBsYXllck9wdGlvbnMudGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0ID0gbmV3IHRleHRsYXllcihsYXllck9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKGxheWVyT3B0aW9ucy5yZXNvdXJjZVR5cGUgPT09IFwic3VidGl0bGVzXCIpIHtcbiAgICAgICAgICByZXN1bHQgPSBuZXcgc3VidGl0bGVzbGF5ZXIobGF5ZXJPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXllck9wdGlvbnMucmVzb3VyY2VUeXBlID09PSBcImZldGNoXCIgfHwgbGF5ZXJPcHRpb25zLnVybCAhPSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0ID0gbmV3IGZldGNobGF5ZXIobGF5ZXJPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSBuZXcgbGF5ZXJfbGF5ZXIobGF5ZXJPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQoKSh0aGlzLm9yaWdWYWx1ZSkpIHtcbiAgICAgICAgaWYgKC9eZmV0Y2g6LisvLnRlc3QodGhpcy5vcmlnVmFsdWUpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gbmV3IGZldGNobGF5ZXIodGhpcy5vcmlnVmFsdWUuc3Vic3RyKDYpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSB0aGlzLm9yaWdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQudG9TdHJpbmcoKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJ0ZXh0U3R5bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGV4dFN0eWxlKGxheWVyKSB7XG4gICAgICByZXR1cm4gbmV3IHRleHRsYXllcihsYXllcikudGV4dFN0eWxlSWRlbnRpZmllcigpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMYXllclBhcmFtO1xufShwYXJhbWV0ZXJzX1BhcmFtKTtcblxudmFyIHBhcmFtZXRlcnNfRXhwcmVzc2lvblBhcmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUGFyYW02KSB7XG4gIHBhcmFtZXRlcnNfaW5oZXJpdHMoRXhwcmVzc2lvblBhcmFtLCBfUGFyYW02KTtcblxuICB2YXIgX3N1cGVyNiA9IHBhcmFtZXRlcnNfY3JlYXRlU3VwZXIoRXhwcmVzc2lvblBhcmFtKTtcblxuICBmdW5jdGlvbiBFeHByZXNzaW9uUGFyYW0oKSB7XG4gICAgcGFyYW1ldGVyc19jbGFzc0NhbGxDaGVjayh0aGlzLCBFeHByZXNzaW9uUGFyYW0pO1xuXG4gICAgcmV0dXJuIF9zdXBlcjYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHBhcmFtZXRlcnNfY3JlYXRlQ2xhc3MoRXhwcmVzc2lvblBhcmFtLCBbe1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgcmV0dXJuIGV4cHJlc3Npb24ubm9ybWFsaXplKF9nZXQocGFyYW1ldGVyc19nZXRQcm90b3R5cGVPZihFeHByZXNzaW9uUGFyYW0ucHJvdG90eXBlKSwgXCJzZXJpYWxpemVcIiwgdGhpcykuY2FsbCh0aGlzKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEV4cHJlc3Npb25QYXJhbTtcbn0ocGFyYW1ldGVyc19QYXJhbSk7XG5cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdHJhbnNmb3JtYXRpb24uanNcbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gdHJhbnNmb3JtYXRpb25fdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgdHJhbnNmb3JtYXRpb25fdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25faW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgdHJhbnNmb3JtYXRpb25fc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX3NldFByb3RvdHlwZU9mKG8sIHApIHsgdHJhbnNmb3JtYXRpb25fc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIHRyYW5zZm9ybWF0aW9uX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSB0cmFuc2Zvcm1hdGlvbl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSB0cmFuc2Zvcm1hdGlvbl9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gdHJhbnNmb3JtYXRpb25fZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIHRyYW5zZm9ybWF0aW9uX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKHRyYW5zZm9ybWF0aW9uX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiB0cmFuc2Zvcm1hdGlvbl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25faXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fZ2V0UHJvdG90eXBlT2YobykgeyB0cmFuc2Zvcm1hdGlvbl9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gdHJhbnNmb3JtYXRpb25fZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIHRyYW5zZm9ybWF0aW9uX2FycmF5V2l0aEhvbGVzKGFycikgfHwgdHJhbnNmb3JtYXRpb25faXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCB0cmFuc2Zvcm1hdGlvbl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IHRyYW5zZm9ybWF0aW9uX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHRyYW5zZm9ybWF0aW9uX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiB0cmFuc2Zvcm1hdGlvbl9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25faXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTsgaWYgKF9pID09IG51bGwpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfcywgX2U7IHRyeSB7IGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIHRyYW5zZm9ybWF0aW9uX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSB0cmFuc2Zvcm1hdGlvbl9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5cblxuXG5cblxuXG4vKipcbiAqIEFzc2lnbiBrZXksIHZhbHVlIHRvIHRhcmdldCwgd2hlbiB2YWx1ZSBpcyBub3QgbnVsbC48YnI+XG4gKiAgIFRoaXMgZnVuY3Rpb24gbXV0YXRlcyB0aGUgdGFyZ2V0IVxuICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCB0aGUgb2JqZWN0IHRvIGFzc2lnbiB0aGUgdmFsdWVzIHRvXG4gKiBAcGFyYW0ge29iamVjdH0gc291cmNlcyBvbmUgb3IgbW9yZSBvYmplY3RzIHRvIGdldCB2YWx1ZXMgZnJvbVxuICogQHJldHVybnMge29iamVjdH0gdGhlIHRhcmdldCBhZnRlciB0aGUgYXNzaWdubWVudFxuICovXG5cbmZ1bmN0aW9uIGFzc2lnbk5vdE51bGwodGFyZ2V0KSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzb3VyY2VzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmIChzb3VyY2Vba2V5XSAhPSBudWxsKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1hdGlvbkJhc2VcbiAqIERlcGVuZHMgb24gJ2NvbmZpZ3VyYXRpb24nLCAncGFyYW1ldGVycycsJ3V0aWwnXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbnZhciB0cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbkJhc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogVGhlIGJhc2UgY2xhc3MgZm9yIHRyYW5zZm9ybWF0aW9ucy5cbiAgICogTWVtYmVycyBvZiB0aGlzIGNsYXNzIGFyZSBkb2N1bWVudGVkIGFzIGJlbG9uZ2luZyB0byB0aGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBjbGFzcyBmb3IgY29udmVuaWVuY2UuXG4gICAqIEBjbGFzcyBUcmFuc2Zvcm1hdGlvbkJhc2VcbiAgICovXG4gIGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uQmFzZShvcHRpb25zKSB7XG4gICAgdHJhbnNmb3JtYXRpb25fY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhbnNmb3JtYXRpb25CYXNlKTtcblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdmFyIHBhcmVudCwgdHJhbnM7XG4gICAgcGFyZW50ID0gdm9pZCAwO1xuICAgIHRyYW5zID0ge307XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIG9wdGlvbnMgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGFuIGlkZW50aWNhbCBUcmFuc2Zvcm1hdGlvblxuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiN0b09wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYSBwbGFpbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoaXMgdHJhbnNmb3JtYXRpb25cbiAgICAgKi9cblxuICAgIHRoaXMudG9PcHRpb25zID0gZnVuY3Rpb24gKHdpdGhDaGFpbikge1xuICAgICAgdmFyIG9wdCA9IHt9O1xuXG4gICAgICBpZiAod2l0aENoYWluID09IG51bGwpIHtcbiAgICAgICAgd2l0aENoYWluID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmtleXModHJhbnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gb3B0W2tleV0gPSB0cmFuc1trZXldLm9yaWdWYWx1ZTtcbiAgICAgIH0pO1xuICAgICAgYXNzaWduTm90TnVsbChvcHQsIHRoaXMub3RoZXJPcHRpb25zKTtcblxuICAgICAgaWYgKHdpdGhDaGFpbiAmJiAhaXNFbXB0eSh0aGlzLmNoYWluZWQpKSB7XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5jaGFpbmVkLm1hcChmdW5jdGlvbiAodHIpIHtcbiAgICAgICAgICByZXR1cm4gdHIudG9PcHRpb25zKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBsaXN0LnB1c2gob3B0KTtcbiAgICAgICAgb3B0ID0ge307XG4gICAgICAgIGFzc2lnbk5vdE51bGwob3B0LCB0aGlzLm90aGVyT3B0aW9ucyk7XG4gICAgICAgIG9wdC50cmFuc2Zvcm1hdGlvbiA9IGxpc3Q7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgYSBwYXJlbnQgZm9yIHRoaXMgb2JqZWN0IGZvciBjaGFpbmluZyBwdXJwb3Nlcy5cbiAgICAgKlxuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiNzZXRQYXJlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gdGhlIHBhcmVudCB0byBiZSBhc3NpZ25lZCB0b1xuICAgICAqIEByZXR1cm5zIHtUcmFuc2Zvcm1hdGlvbn0gUmV0dXJucyB0aGlzIGluc3RhbmNlIGZvciBjaGFpbmluZyBwdXJwb3Nlcy5cbiAgICAgKi9cblxuXG4gICAgdGhpcy5zZXRQYXJlbnQgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICBwYXJlbnQgPSBvYmplY3Q7XG5cbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmZyb21PcHRpb25zKHR5cGVvZiBvYmplY3QudG9PcHRpb25zID09PSBcImZ1bmN0aW9uXCIgPyBvYmplY3QudG9PcHRpb25zKCkgOiB2b2lkIDApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBhcmVudCBvZiB0aGlzIG9iamVjdCBpbiB0aGUgY2hhaW5cbiAgICAgKiBAZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24jZ2V0UGFyZW50XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgcGFyZW50IG9mIHRoaXMgb2JqZWN0IGlmIHRoZXJlIGlzIGFueVxuICAgICAqL1xuXG5cbiAgICB0aGlzLmdldFBhcmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfTsgLy8gSGVscGVyIG1ldGhvZHMgdG8gY3JlYXRlIHBhcmFtZXRlciBtZXRob2RzXG4gICAgLy8gVGhlc2UgbWV0aG9kcyBhcmUgZGVmaW5lZCBoZXJlIGJlY2F1c2UgdGhleSBhY2Nlc3MgYHRyYW5zYCB3aGljaCBpc1xuICAgIC8vIGEgcHJpdmF0ZSBtZW1iZXIgb2YgYFRyYW5zZm9ybWF0aW9uQmFzZWBcblxuICAgIC8qKiBAcHJvdGVjdGVkICovXG5cblxuICAgIHRoaXMucGFyYW0gPSBmdW5jdGlvbiAodmFsdWUsIG5hbWUsIGFiYnIsIGRlZmF1bHRWYWx1ZSwgcHJvY2Vzcykge1xuICAgICAgaWYgKHByb2Nlc3MgPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgICAgICBwcm9jZXNzID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb2Nlc3MgPSBpZGVudGl0eV9yb290X2lkZW50aXR5X2RlZmF1bHQuYTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0cmFuc1tuYW1lXSA9IG5ldyBwYXJhbWV0ZXJzX1BhcmFtKG5hbWUsIGFiYnIsIHByb2Nlc3MpLnNldCh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBAcHJvdGVjdGVkICovXG5cblxuICAgIHRoaXMucmF3UGFyYW0gPSBmdW5jdGlvbiAodmFsdWUsIG5hbWUsIGFiYnIsIGRlZmF1bHRWYWx1ZSwgcHJvY2Vzcykge1xuICAgICAgcHJvY2VzcyA9IGxhc3RBcmdDYWxsYmFjayhhcmd1bWVudHMpO1xuICAgICAgdHJhbnNbbmFtZV0gPSBuZXcgcGFyYW1ldGVyc19SYXdQYXJhbShuYW1lLCBhYmJyLCBwcm9jZXNzKS5zZXQodmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogQHByb3RlY3RlZCAqL1xuXG5cbiAgICB0aGlzLnJhbmdlUGFyYW0gPSBmdW5jdGlvbiAodmFsdWUsIG5hbWUsIGFiYnIsIGRlZmF1bHRWYWx1ZSwgcHJvY2Vzcykge1xuICAgICAgcHJvY2VzcyA9IGxhc3RBcmdDYWxsYmFjayhhcmd1bWVudHMpO1xuICAgICAgdHJhbnNbbmFtZV0gPSBuZXcgcGFyYW1ldGVyc19SYW5nZVBhcmFtKG5hbWUsIGFiYnIsIHByb2Nlc3MpLnNldCh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBAcHJvdGVjdGVkICovXG5cblxuICAgIHRoaXMuYXJyYXlQYXJhbSA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgYWJicikge1xuICAgICAgdmFyIHNlcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogXCI6XCI7XG4gICAgICB2YXIgZGVmYXVsdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBbXTtcbiAgICAgIHZhciBwcm9jZXNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB1bmRlZmluZWQ7XG4gICAgICBwcm9jZXNzID0gbGFzdEFyZ0NhbGxiYWNrKGFyZ3VtZW50cyk7XG4gICAgICB0cmFuc1tuYW1lXSA9IG5ldyBwYXJhbWV0ZXJzX0FycmF5UGFyYW0obmFtZSwgYWJiciwgc2VwLCBwcm9jZXNzKS5zZXQodmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogQHByb3RlY3RlZCAqL1xuXG5cbiAgICB0aGlzLnRyYW5zZm9ybWF0aW9uUGFyYW0gPSBmdW5jdGlvbiAodmFsdWUsIG5hbWUsIGFiYnIpIHtcbiAgICAgIHZhciBzZXAgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IFwiLlwiO1xuICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIHByb2Nlc3MgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHVuZGVmaW5lZDtcbiAgICAgIHByb2Nlc3MgPSBsYXN0QXJnQ2FsbGJhY2soYXJndW1lbnRzKTtcbiAgICAgIHRyYW5zW25hbWVdID0gbmV3IHBhcmFtZXRlcnNfVHJhbnNmb3JtYXRpb25QYXJhbShuYW1lLCBhYmJyLCBzZXAsIHByb2Nlc3MpLnNldCh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5sYXllclBhcmFtID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lLCBhYmJyKSB7XG4gICAgICB0cmFuc1tuYW1lXSA9IG5ldyBwYXJhbWV0ZXJzX0xheWVyUGFyYW0obmFtZSwgYWJicikuc2V0KHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07IC8vIEVuZCBIZWxwZXIgbWV0aG9kc1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gICAgICogQGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uI2dldFZhbHVlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyXG4gICAgICogQHJldHVybiB7Kn0gdGhlIHByb2Nlc3NlZCB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICAgKiBAZGVzY3JpcHRpb24gVXNlIHtAbGluayBnZXR9Lm9yaWdWYWx1ZSBmb3IgdGhlIHZhbHVlIG9yaWdpbmFsbHkgcHJvdmlkZWQgZm9yIHRoZSBwYXJhbWV0ZXJcbiAgICAgKi9cblxuXG4gICAgdGhpcy5nZXRWYWx1ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0cmFuc1tuYW1lXSAmJiB0cmFuc1tuYW1lXS52YWx1ZSgpO1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHRoaXMub3RoZXJPcHRpb25zW25hbWVdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwYXJhbWV0ZXIgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gcGFyYW1ldGVyIG5hbWVcbiAgICAgKiBAZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24jZ2V0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIHRyYW5zZm9ybWF0aW9uIHBhcmFtZXRlclxuICAgICAqIEByZXR1cm5zIHtQYXJhbX0gdGhlIHBhcmFtIG9iamVjdCBmb3IgdGhlIGdpdmVuIG5hbWUsIG9yIHVuZGVmaW5lZFxuICAgICAqL1xuXG5cbiAgICB0aGlzLmdldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gdHJhbnNbbmFtZV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSB0cmFuc2Zvcm1hdGlvbiBvcHRpb24gZnJvbSB0aGUgdHJhbnNmb3JtYXRpb24uXG4gICAgICogQGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uI3JlbW92ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIG9wdGlvbiB0byByZW1vdmVcbiAgICAgKiBAcmV0dXJuIHsqfSBSZXR1cm5zIHRoZSBvcHRpb24gdGhhdCB3YXMgcmVtb3ZlZCBvciBudWxsIGlmIG5vIG9wdGlvbiBieSB0aGF0IG5hbWUgd2FzIGZvdW5kLiBUaGUgdHlwZSBvZiB0aGVcbiAgICAgKiAgICAgICAgICAgICAgcmV0dXJuZWQgdmFsdWUgZGVwZW5kcyBvbiB0aGUgdmFsdWUuXG4gICAgICovXG5cblxuICAgIHRoaXMucmVtb3ZlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciB0ZW1wO1xuXG4gICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgIGNhc2UgdHJhbnNbbmFtZV0gPT0gbnVsbDpcbiAgICAgICAgICB0ZW1wID0gdHJhbnNbbmFtZV07XG4gICAgICAgICAgZGVsZXRlIHRyYW5zW25hbWVdO1xuICAgICAgICAgIHJldHVybiB0ZW1wLm9yaWdWYWx1ZTtcblxuICAgICAgICBjYXNlIHRoaXMub3RoZXJPcHRpb25zW25hbWVdID09IG51bGw6XG4gICAgICAgICAgdGVtcCA9IHRoaXMub3RoZXJPcHRpb25zW25hbWVdO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLm90aGVyT3B0aW9uc1tuYW1lXTtcbiAgICAgICAgICByZXR1cm4gdGVtcDtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIGFycmF5IG9mIGFsbCB0aGUga2V5cyAob3B0aW9uIG5hbWVzKSBpbiB0aGUgdHJhbnNmb3JtYXRpb24uXG4gICAgICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn0gdGhlIGtleXMgaW4gc25ha2VDYXNlIGZvcm1hdFxuICAgICAqL1xuXG5cbiAgICB0aGlzLmtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIga2V5O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdHM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcblxuICAgICAgICBmb3IgKGtleSBpbiB0cmFucykge1xuICAgICAgICAgIGlmIChrZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGtleS5tYXRjaChWQVJfTkFNRV9SRSkgPyBrZXkgOiBzbmFrZUNhc2Uoa2V5KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9KCkuc29ydCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHBsYWluIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdHJhbnNmb3JtYXRpb24uIFZhbHVlcyBhcmUgcHJvY2Vzc2VkLlxuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiN0b1BsYWluT2JqZWN0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgdHJhbnNmb3JtYXRpb24gb3B0aW9ucyBhcyBwbGFpbiBvYmplY3RcbiAgICAgKi9cblxuXG4gICAgdGhpcy50b1BsYWluT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGhhc2gsIGtleSwgbGlzdDtcbiAgICAgIGhhc2ggPSB7fTtcblxuICAgICAgZm9yIChrZXkgaW4gdHJhbnMpIHtcbiAgICAgICAgaGFzaFtrZXldID0gdHJhbnNba2V5XS52YWx1ZSgpO1xuXG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0KCkoaGFzaFtrZXldKSkge1xuICAgICAgICAgIGhhc2hba2V5XSA9IGNsb25lRGVlcF9yb290X2Nsb25lRGVlcF9kZWZhdWx0KCkoaGFzaFtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWlzRW1wdHkodGhpcy5jaGFpbmVkKSkge1xuICAgICAgICBsaXN0ID0gdGhpcy5jaGFpbmVkLm1hcChmdW5jdGlvbiAodHIpIHtcbiAgICAgICAgICByZXR1cm4gdHIudG9QbGFpbk9iamVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgbGlzdC5wdXNoKGhhc2gpO1xuICAgICAgICBoYXNoID0ge1xuICAgICAgICAgIHRyYW5zZm9ybWF0aW9uOiBsaXN0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcGxldGUgdGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gYW5kIGNoYWluIHRvIGEgbmV3IG9uZS5cbiAgICAgKiBJbiB0aGUgVVJMLCB0cmFuc2Zvcm1hdGlvbnMgYXJlIGNoYWluZWQgdG9nZXRoZXIgYnkgc2xhc2hlcy5cbiAgICAgKiBAZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24jY2hhaW5cbiAgICAgKiBAcmV0dXJuIHtUcmFuc2Zvcm1hdGlvbn0gUmV0dXJucyB0aGlzIHRyYW5zZm9ybWF0aW9uIGZvciBjaGFpbmluZ1xuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHRyID0gY2xvdWRpbmFyeS5UcmFuc2Zvcm1hdGlvbi5uZXcoKTtcbiAgICAgKiB0ci53aWR0aCgxMCkuY3JvcCgnZml0JykuY2hhaW4oKS5hbmdsZSgxNSkuc2VyaWFsaXplKClcbiAgICAgKiAvLyBwcm9kdWNlcyBcImNfZml0LHdfMTAvYV8xNVwiXG4gICAgICovXG5cblxuICAgIHRoaXMuY2hhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmFtZXMsIHRyO1xuICAgICAgbmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0cmFucyk7XG5cbiAgICAgIGlmIChuYW1lcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgdHIgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnRvT3B0aW9ucyhmYWxzZSkpO1xuICAgICAgICB0aGlzLnJlc2V0VHJhbnNmb3JtYXRpb25zKCk7XG4gICAgICAgIHRoaXMuY2hhaW5lZC5wdXNoKHRyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHRoaXMucmVzZXRUcmFuc2Zvcm1hdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0cmFucyA9IHt9O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHRoaXMub3RoZXJPcHRpb25zID0ge307XG4gICAgdGhpcy5jaGFpbmVkID0gW107XG4gICAgdGhpcy5mcm9tT3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogTWVyZ2UgdGhlIHByb3ZpZGVkIG9wdGlvbnMgd2l0aCBvd24ncyBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0ga2V5LXZhbHVlIGxpc3Qgb2Ygb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7VHJhbnNmb3JtYXRpb259IFJldHVybnMgdGhpcyBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICovXG5cblxuICB0cmFuc2Zvcm1hdGlvbl9jcmVhdGVDbGFzcyhUcmFuc2Zvcm1hdGlvbkJhc2UsIFt7XG4gICAga2V5OiBcImZyb21PcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21PcHRpb25zKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIFRyYW5zZm9ybWF0aW9uQmFzZSkge1xuICAgICAgICB0aGlzLmZyb21UcmFuc2Zvcm1hdGlvbihvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQoKShvcHRpb25zKSB8fCBpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkob3B0aW9ucykpIHtcbiAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgdHJhbnNmb3JtYXRpb246IG9wdGlvbnNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucyA9IGNsb25lRGVlcF9yb290X2Nsb25lRGVlcF9kZWZhdWx0KCkob3B0aW9ucywgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVHJhbnNmb3JtYXRpb25CYXNlIHx8IHZhbHVlIGluc3RhbmNlb2YgTGF5ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdmFsdWUuY2xvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pOyAvLyBIYW5kbGluZyBvZiBcImlmXCIgc3RhdGVtZW50cyBwcmVjZWRlcyBvdGhlciBvcHRpb25zIGFzIGl0IGNyZWF0ZXMgYSBjaGFpbmVkIHRyYW5zZm9ybWF0aW9uXG5cbiAgICAgICAgaWYgKG9wdGlvbnNbXCJpZlwiXSkge1xuICAgICAgICAgIHRoaXMuc2V0KFwiaWZcIiwgb3B0aW9uc1tcImlmXCJdKTtcbiAgICAgICAgICBkZWxldGUgb3B0aW9uc1tcImlmXCJdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgb3B0ID0gb3B0aW9uc1trZXldO1xuXG4gICAgICAgICAgaWYgKG9wdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoa2V5Lm1hdGNoKFZBUl9OQU1FX1JFKSkge1xuICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnJGF0dHInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoJ3ZhcmlhYmxlJywga2V5LCBvcHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnNldChrZXksIG9wdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmcm9tVHJhbnNmb3JtYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVRyYW5zZm9ybWF0aW9uKG90aGVyKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBUcmFuc2Zvcm1hdGlvbkJhc2UpIHtcbiAgICAgICAgb3RoZXIua2V5cygpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5zZXQoa2V5LCBvdGhlci5nZXQoa2V5KS5vcmlnVmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBhIHBhcmFtZXRlci5cbiAgICAgKiBUaGUgcGFyYW1ldGVyIG5hbWUgYGtleWAgaXMgY29udmVydGVkIHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIHRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlcyAtIHRoZSB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyXG4gICAgICogQHJldHVybnMge1RyYW5zZm9ybWF0aW9ufSBSZXR1cm5zIHRoaXMgaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGtleSkge1xuICAgICAgdmFyIGNhbWVsS2V5O1xuICAgICAgY2FtZWxLZXkgPSBjYW1lbENhc2Uoa2V5KTtcblxuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCB2YWx1ZXMgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICB2YWx1ZXNbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmNsdWRlc19yb290X2luY2x1ZGVzX2RlZmF1bHQoKSh0cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbi5tZXRob2RzLCBjYW1lbEtleSkpIHtcbiAgICAgICAgdGhpc1tjYW1lbEtleV0uYXBwbHkodGhpcywgdmFsdWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3RoZXJPcHRpb25zW2tleV0gPSB2YWx1ZXNbMF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNMYXllclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNMYXllcigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlKFwib3ZlcmxheVwiKSB8fCB0aGlzLmdldFZhbHVlKFwidW5kZXJsYXlcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgKiBAZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24jc2VyaWFsaXplXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmFuc2Zvcm1hdGlvbiBhcyBhIHN0cmluZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIHZhciBpZlBhcmFtLCBqLCBsZW4sIHBhcmFtTGlzdCwgcmVmLCByZWYxLCByZWYyLCByZWYzLCByZWY0LCByZXN1bHRBcnJheSwgdCwgdHJhbnNmb3JtYXRpb25MaXN0LCB0cmFuc2Zvcm1hdGlvblN0cmluZywgdHJhbnNmb3JtYXRpb25zLCB2YWx1ZSwgdmFyaWFibGVzLCB2YXJzO1xuICAgICAgcmVzdWx0QXJyYXkgPSB0aGlzLmNoYWluZWQubWFwKGZ1bmN0aW9uICh0cikge1xuICAgICAgICByZXR1cm4gdHIuc2VyaWFsaXplKCk7XG4gICAgICB9KTtcbiAgICAgIHBhcmFtTGlzdCA9IHRoaXMua2V5cygpO1xuICAgICAgdHJhbnNmb3JtYXRpb25zID0gKHJlZiA9IHRoaXMuZ2V0KFwidHJhbnNmb3JtYXRpb25cIikpICE9IG51bGwgPyByZWYuc2VyaWFsaXplKCkgOiB2b2lkIDA7XG4gICAgICBpZlBhcmFtID0gKHJlZjEgPSB0aGlzLmdldChcImlmXCIpKSAhPSBudWxsID8gcmVmMS5zZXJpYWxpemUoKSA6IHZvaWQgMDtcbiAgICAgIHZhcmlhYmxlcyA9IHByb2Nlc3NWYXIoKHJlZjIgPSB0aGlzLmdldChcInZhcmlhYmxlc1wiKSkgIT0gbnVsbCA/IHJlZjIudmFsdWUoKSA6IHZvaWQgMCk7XG4gICAgICBwYXJhbUxpc3QgPSBkaWZmZXJlbmNlX3Jvb3RfZGlmZmVyZW5jZV9kZWZhdWx0KCkocGFyYW1MaXN0LCBbXCJ0cmFuc2Zvcm1hdGlvblwiLCBcImlmXCIsIFwidmFyaWFibGVzXCJdKTtcbiAgICAgIHZhcnMgPSBbXTtcbiAgICAgIHRyYW5zZm9ybWF0aW9uTGlzdCA9IFtdO1xuXG4gICAgICBmb3IgKGogPSAwLCBsZW4gPSBwYXJhbUxpc3QubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgdCA9IHBhcmFtTGlzdFtqXTtcblxuICAgICAgICBpZiAodC5tYXRjaChWQVJfTkFNRV9SRSkpIHtcbiAgICAgICAgICB2YXJzLnB1c2godCArIFwiX1wiICsgZXhwcmVzc2lvbi5ub3JtYWxpemUoKHJlZjMgPSB0aGlzLmdldCh0KSkgIT0gbnVsbCA/IHJlZjMudmFsdWUoKSA6IHZvaWQgMCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyYW5zZm9ybWF0aW9uTGlzdC5wdXNoKChyZWY0ID0gdGhpcy5nZXQodCkpICE9IG51bGwgPyByZWY0LnNlcmlhbGl6ZSgpIDogdm9pZCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgIGNhc2UgIWlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKHRyYW5zZm9ybWF0aW9ucyk6XG4gICAgICAgICAgdHJhbnNmb3JtYXRpb25MaXN0LnB1c2godHJhbnNmb3JtYXRpb25zKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICFpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkodHJhbnNmb3JtYXRpb25zKTpcbiAgICAgICAgICByZXN1bHRBcnJheSA9IHJlc3VsdEFycmF5LmNvbmNhdCh0cmFuc2Zvcm1hdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICB0cmFuc2Zvcm1hdGlvbkxpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBrLCBsZW4xLCByZXN1bHRzO1xuICAgICAgICByZXN1bHRzID0gW107XG5cbiAgICAgICAgZm9yIChrID0gMCwgbGVuMSA9IHRyYW5zZm9ybWF0aW9uTGlzdC5sZW5ndGg7IGsgPCBsZW4xOyBrKyspIHtcbiAgICAgICAgICB2YWx1ZSA9IHRyYW5zZm9ybWF0aW9uTGlzdFtrXTtcblxuICAgICAgICAgIGlmIChpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkodmFsdWUpICYmICFpc0VtcHR5KHZhbHVlKSB8fCAhaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHZhbHVlKSAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH0oKTtcblxuICAgICAgdHJhbnNmb3JtYXRpb25MaXN0ID0gdmFycy5zb3J0KCkuY29uY2F0KHZhcmlhYmxlcykuY29uY2F0KHRyYW5zZm9ybWF0aW9uTGlzdC5zb3J0KCkpO1xuXG4gICAgICBpZiAoaWZQYXJhbSA9PT0gXCJpZl9lbmRcIikge1xuICAgICAgICB0cmFuc2Zvcm1hdGlvbkxpc3QucHVzaChpZlBhcmFtKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW1wdHkoaWZQYXJhbSkpIHtcbiAgICAgICAgdHJhbnNmb3JtYXRpb25MaXN0LnVuc2hpZnQoaWZQYXJhbSk7XG4gICAgICB9XG5cbiAgICAgIHRyYW5zZm9ybWF0aW9uU3RyaW5nID0gY29tcGFjdF9yb290X2NvbXBhY3RfZGVmYXVsdCgpKHRyYW5zZm9ybWF0aW9uTGlzdCkuam9pbih0aGlzLnBhcmFtX3NlcGFyYXRvcik7XG5cbiAgICAgIGlmICghaXNFbXB0eSh0cmFuc2Zvcm1hdGlvblN0cmluZykpIHtcbiAgICAgICAgcmVzdWx0QXJyYXkucHVzaCh0cmFuc2Zvcm1hdGlvblN0cmluZyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb21wYWN0X3Jvb3RfY29tcGFjdF9kZWZhdWx0KCkocmVzdWx0QXJyYXkpLmpvaW4odGhpcy50cmFuc19zZXBhcmF0b3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm92aWRlIGEgbGlzdCBvZiBhbGwgdGhlIHZhbGlkIHRyYW5zZm9ybWF0aW9uIG9wdGlvbiBuYW1lc1xuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiNsaXN0TmFtZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge0FycmF5PHN0cmluZz59IGEgYXJyYXkgb2YgYWxsIHRoZSB2YWxpZCBvcHRpb24gbmFtZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvSHRtbEF0dHJpYnV0ZXNcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhdHRyaWJ1dGVzIGZvciBhbiBIVE1MIHRhZy5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeS50b0h0bWxBdHRyaWJ1dGVzXG4gICAgICogQHJldHVybiBQbGFpbk9iamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvSHRtbEF0dHJpYnV0ZXMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGF0dHJOYW1lLCBoZWlnaHQsIG9wdGlvbnMsIHJlZjIsIHJlZjMsIHZhbHVlLCB3aWR0aDtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIHZhciBzbmFrZUNhc2VLZXk7XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLm90aGVyT3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhbHVlID0gX3RoaXMyLm90aGVyT3B0aW9uc1trZXldO1xuICAgICAgICBzbmFrZUNhc2VLZXkgPSBzbmFrZUNhc2Uoa2V5KTtcblxuICAgICAgICBpZiAoIWluY2x1ZGVzX3Jvb3RfaW5jbHVkZXNfZGVmYXVsdCgpKHRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uLlBBUkFNX05BTUVTLCBzbmFrZUNhc2VLZXkpICYmICFpbmNsdWRlc19yb290X2luY2x1ZGVzX2RlZmF1bHQoKShVUkxfS0VZUywgc25ha2VDYXNlS2V5KSkge1xuICAgICAgICAgIGF0dHJOYW1lID0gL15odG1sXy8udGVzdChrZXkpID8ga2V5LnNsaWNlKDUpIDoga2V5O1xuICAgICAgICAgIG9wdGlvbnNbYXR0ck5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBjb252ZXJ0IGFsbCBcImh0bWxfa2V5XCIgdG8gXCJrZXlcIiB3aXRoIHRoZSBzYW1lIHZhbHVlXG5cbiAgICAgIHRoaXMua2V5cygpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoL15odG1sXy8udGVzdChrZXkpKSB7XG4gICAgICAgICAgb3B0aW9uc1tjYW1lbENhc2Uoa2V5LnNsaWNlKDUpKV0gPSBfdGhpczIuZ2V0VmFsdWUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghKHRoaXMuaGFzTGF5ZXIoKSB8fCB0aGlzLmdldFZhbHVlKFwiYW5nbGVcIikgfHwgaW5jbHVkZXNfcm9vdF9pbmNsdWRlc19kZWZhdWx0KCkoW1wiZml0XCIsIFwibGltaXRcIiwgXCJsZmlsbFwiXSwgdGhpcy5nZXRWYWx1ZShcImNyb3BcIikpKSkge1xuICAgICAgICB3aWR0aCA9IChyZWYyID0gdGhpcy5nZXQoXCJ3aWR0aFwiKSkgIT0gbnVsbCA/IHJlZjIub3JpZ1ZhbHVlIDogdm9pZCAwO1xuICAgICAgICBoZWlnaHQgPSAocmVmMyA9IHRoaXMuZ2V0KFwiaGVpZ2h0XCIpKSAhPSBudWxsID8gcmVmMy5vcmlnVmFsdWUgOiB2b2lkIDA7XG5cbiAgICAgICAgaWYgKHBhcnNlRmxvYXQod2lkdGgpID49IDEuMCkge1xuICAgICAgICAgIGlmIChvcHRpb25zLndpZHRoID09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VGbG9hdChoZWlnaHQpID49IDEuMCkge1xuICAgICAgICAgIGlmIChvcHRpb25zLmhlaWdodCA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSHRtbFwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIERlbGVnYXRlIHRvIHRoZSBwYXJlbnQgKHVwIHRoZSBjYWxsIGNoYWluKSB0byBwcm9kdWNlIEhUTUxcbiAgICAgKiBAZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24jdG9IdG1sXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBIVE1MIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwYXJlbnQgaWYgcG9zc2libGUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB0YWcgPSBjbG91ZGluYXJ5LkltYWdlVGFnLm5ldyhcInNhbXBsZVwiLCB7Y2xvdWRfbmFtZTogXCJkZW1vXCJ9KVxuICAgICAqIC8vIEltYWdlVGFnIHtuYW1lOiBcImltZ1wiLCBwdWJsaWNJZDogXCJzYW1wbGVcIn1cbiAgICAgKiB0YWcudG9IdG1sKClcbiAgICAgKiAvLyA8aW1nIHNyYz1cImh0dHA6Ly9yZXMuY2xvdWRpbmFyeS5jb20vZGVtby9pbWFnZS91cGxvYWQvc2FtcGxlXCI+XG4gICAgICogdGFnLnRyYW5zZm9ybWF0aW9uKCkuY3JvcChcImZpdFwiKS53aWR0aCgzMDApLnRvSHRtbCgpXG4gICAgICogLy8gPGltZyBzcmM9XCJodHRwOi8vcmVzLmNsb3VkaW5hcnkuY29tL2RlbW8vaW1hZ2UvdXBsb2FkL2NfZml0LHdfMzAwL3NhbXBsZVwiPlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvSHRtbCgpIHtcbiAgICAgIHZhciByZWY7XG4gICAgICByZXR1cm4gKHJlZiA9IHRoaXMuZ2V0UGFyZW50KCkpICE9IG51bGwgPyB0eXBlb2YgcmVmLnRvSHRtbCA9PT0gXCJmdW5jdGlvblwiID8gcmVmLnRvSHRtbCgpIDogdm9pZCAwIDogdm9pZCAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnRvT3B0aW9ucyh0cnVlKSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwibGlzdE5hbWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3ROYW1lcygpIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbi5tZXRob2RzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1ZhbGlkUGFyYW1OYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzVmFsaWRQYXJhbU5hbWUobmFtZSkge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uLm1ldGhvZHMuaW5kZXhPZihjYW1lbENhc2UobmFtZSkpID49IDA7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRyYW5zZm9ybWF0aW9uQmFzZTtcbn0oKTtcblxudmFyIFZBUl9OQU1FX1JFID0gL15cXCRbYS16QS1aMC05XSskLztcbnRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uQmFzZS5wcm90b3R5cGUudHJhbnNfc2VwYXJhdG9yID0gJy8nO1xudHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb25CYXNlLnByb3RvdHlwZS5wYXJhbV9zZXBhcmF0b3IgPSAnLCc7XG5cbmZ1bmN0aW9uIGxhc3RBcmdDYWxsYmFjayhhcmdzKSB7XG4gIHZhciBjYWxsYmFjaztcbiAgY2FsbGJhY2sgPSBhcmdzICE9IG51bGwgPyBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gOiB2b2lkIDA7XG5cbiAgaWYgKGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShjYWxsYmFjaykpIHtcbiAgICByZXR1cm4gY2FsbGJhY2s7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzVmFyKHZhckFycmF5KSB7XG4gIHZhciBqLCBsZW4sIG5hbWUsIHJlc3VsdHMsIHY7XG5cbiAgaWYgKGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKSh2YXJBcnJheSkpIHtcbiAgICByZXN1bHRzID0gW107XG5cbiAgICBmb3IgKGogPSAwLCBsZW4gPSB2YXJBcnJheS5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgdmFyIF92YXJBcnJheSRqID0gdHJhbnNmb3JtYXRpb25fc2xpY2VkVG9BcnJheSh2YXJBcnJheVtqXSwgMik7XG5cbiAgICAgIG5hbWUgPSBfdmFyQXJyYXkkalswXTtcbiAgICAgIHYgPSBfdmFyQXJyYXkkalsxXTtcbiAgICAgIHJlc3VsdHMucHVzaChcIlwiLmNvbmNhdChuYW1lLCBcIl9cIikuY29uY2F0KGV4cHJlc3Npb24ubm9ybWFsaXplKHYpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhckFycmF5O1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDdXN0b21GdW5jdGlvbihfcmVmKSB7XG4gIHZhciBmdW5jdGlvbl90eXBlID0gX3JlZi5mdW5jdGlvbl90eXBlLFxuICAgICAgc291cmNlID0gX3JlZi5zb3VyY2U7XG5cbiAgaWYgKGZ1bmN0aW9uX3R5cGUgPT09ICdyZW1vdGUnKSB7XG4gICAgcmV0dXJuIFtmdW5jdGlvbl90eXBlLCBidG9hKHNvdXJjZSldLmpvaW4oXCI6XCIpO1xuICB9IGVsc2UgaWYgKGZ1bmN0aW9uX3R5cGUgPT09ICd3YXNtJykge1xuICAgIHJldHVybiBbZnVuY3Rpb25fdHlwZSwgc291cmNlXS5qb2luKFwiOlwiKTtcbiAgfVxufVxuLyoqXG4gKiBUcmFuc2Zvcm1hdGlvbiBDbGFzcyBtZXRob2RzLlxuICogVGhpcyBpcyBhIGxpc3Qgb2YgdGhlIHBhcmFtZXRlcnMgZGVmaW5lZCBpbiBUcmFuc2Zvcm1hdGlvbi5cbiAqIFZhbHVlcyBhcmUgY2FtZWxDYXNlZC5cbiAqIEBjb25zdCBUcmFuc2Zvcm1hdGlvbi5tZXRob2RzXG4gKiBAcHJpdmF0ZVxuICogQGlnbm9yZVxuICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gKi9cblxuLyoqXG4gKiBQYXJhbWV0ZXJzIHRoYXQgYXJlIGZpbHRlcmVkIG91dCBiZWZvcmUgcGFzc2luZyB0aGUgb3B0aW9ucyB0byBhbiBIVE1MIHRhZy5cbiAqXG4gKiBUaGUgbGlzdCBvZiBwYXJhbWV0ZXJzIGlzIGEgY29tYmluYXRpb24gb2YgYFRyYW5zZm9ybWF0aW9uOjptZXRob2RzYCBhbmQgYENvbmZpZ3VyYXRpb246OkNPTkZJR19QQVJBTVNgXG4gKiBAY29uc3Qge0FycmF5PHN0cmluZz59IFRyYW5zZm9ybWF0aW9uLlBBUkFNX05BTUVTXG4gKiBAcHJpdmF0ZVxuICogQGlnbm9yZVxuICogQHNlZSB0b0h0bWxBdHRyaWJ1dGVzXG4gKi9cblxuXG52YXIgdHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9UcmFuc2Zvcm1hdGlvbkJhc2UpIHtcbiAgdHJhbnNmb3JtYXRpb25faW5oZXJpdHMoVHJhbnNmb3JtYXRpb24sIF9UcmFuc2Zvcm1hdGlvbkJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSB0cmFuc2Zvcm1hdGlvbl9jcmVhdGVTdXBlcihUcmFuc2Zvcm1hdGlvbik7XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBzaW5nbGUgdHJhbnNmb3JtYXRpb24uXG4gICAqIEBjbGFzcyBUcmFuc2Zvcm1hdGlvblxuICAgKiBAZXhhbXBsZVxuICAgKiB0ID0gbmV3IGNsb3VkaW5hcnkuVHJhbnNmb3JtYXRpb24oKTtcbiAgICogdC5hbmdsZSgyMCkuY3JvcChcInNjYWxlXCIpLndpZHRoKFwiYXV0b1wiKTtcbiAgICpcbiAgICogLy8gb3JcbiAgICpcbiAgICogdCA9IG5ldyBjbG91ZGluYXJ5LlRyYW5zZm9ybWF0aW9uKCB7YW5nbGU6IDIwLCBjcm9wOiBcInNjYWxlXCIsIHdpZHRoOiBcImF1dG9cIn0pO1xuICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCJcbiAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi92aWRlb190cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIlxuICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXZhaWxhYmxlIHZpZGVvIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICovXG4gIGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uKG9wdGlvbnMpIHtcbiAgICB0cmFuc2Zvcm1hdGlvbl9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFuc2Zvcm1hdGlvbik7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1RyYW5zZm9ybWF0aW9ufVxuICAgKiBAZXhhbXBsZSBjbCA9IGNsb3VkaW5hcnkuVHJhbnNmb3JtYXRpb24ubmV3KCB7YW5nbGU6IDIwLCBjcm9wOiBcInNjYWxlXCIsIHdpZHRoOiBcImF1dG9cIn0pXG4gICAqL1xuXG5cbiAgdHJhbnNmb3JtYXRpb25fY3JlYXRlQ2xhc3MoVHJhbnNmb3JtYXRpb24sIFt7XG4gICAga2V5OiBcImFuZ2xlXCIsXG4gICAgdmFsdWU6XG4gICAgLypcbiAgICAgIFRyYW5zZm9ybWF0aW9uIFBhcmFtZXRlcnNcbiAgICAqL1xuICAgIGZ1bmN0aW9uIGFuZ2xlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcnJheVBhcmFtKHZhbHVlLCBcImFuZ2xlXCIsIFwiYVwiLCBcIi5cIiwgZXhwcmVzc2lvbi5ub3JtYWxpemUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhdWRpb0NvZGVjXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF1ZGlvQ29kZWModmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImF1ZGlvX2NvZGVjXCIsIFwiYWNcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImF1ZGlvRnJlcXVlbmN5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF1ZGlvRnJlcXVlbmN5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJhdWRpb19mcmVxdWVuY3lcIiwgXCJhZlwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXNwZWN0UmF0aW9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXNwZWN0UmF0aW8odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImFzcGVjdF9yYXRpb1wiLCBcImFyXCIsIGV4cHJlc3Npb24ubm9ybWFsaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmFja2dyb3VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiYWNrZ3JvdW5kKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJiYWNrZ3JvdW5kXCIsIFwiYlwiLCBwYXJhbWV0ZXJzX1BhcmFtLm5vcm1fY29sb3IpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJiaXRSYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpdFJhdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImJpdF9yYXRlXCIsIFwiYnJcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBib3JkZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImJvcmRlclwiLCBcImJvXCIsIGZ1bmN0aW9uIChib3JkZXIpIHtcbiAgICAgICAgaWYgKGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQoKShib3JkZXIpKSB7XG4gICAgICAgICAgYm9yZGVyID0gYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKSh7fSwge1xuICAgICAgICAgICAgY29sb3I6IFwiYmxhY2tcIixcbiAgICAgICAgICAgIHdpZHRoOiAyXG4gICAgICAgICAgfSwgYm9yZGVyKTtcbiAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoYm9yZGVyLndpZHRoLCBcInB4X3NvbGlkX1wiKS5jb25jYXQocGFyYW1ldGVyc19QYXJhbS5ub3JtX2NvbG9yKGJvcmRlci5jb2xvcikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBib3JkZXI7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb2xvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiY29sb3JcIiwgXCJjb1wiLCBwYXJhbWV0ZXJzX1BhcmFtLm5vcm1fY29sb3IpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb2xvclNwYWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbG9yU3BhY2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImNvbG9yX3NwYWNlXCIsIFwiY3NcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyb3BcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JvcCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiY3JvcFwiLCBcImNcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImN1c3RvbUZ1bmN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGN1c3RvbUZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJjdXN0b21fZnVuY3Rpb25cIiwgXCJmblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwcm9jZXNzQ3VzdG9tRnVuY3Rpb24odmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImN1c3RvbVByZUZ1bmN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGN1c3RvbVByZUZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5nZXQoJ2N1c3RvbV9mdW5jdGlvbicpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmF3UGFyYW0odmFsdWUsIFwiY3VzdG9tX2Z1bmN0aW9uXCIsIFwiXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFsdWUgPSBwcm9jZXNzQ3VzdG9tRnVuY3Rpb24odmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWUgPyBcImZuX3ByZTpcIi5jb25jYXQodmFsdWUpIDogdmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVmYXVsdEltYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlZmF1bHRJbWFnZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiZGVmYXVsdF9pbWFnZVwiLCBcImRcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGF5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJkZWxheVwiLCBcImRsXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZW5zaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbnNpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImRlbnNpdHlcIiwgXCJkblwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHVyYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHVyYXRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJhbmdlUGFyYW0odmFsdWUsIFwiZHVyYXRpb25cIiwgXCJkdVwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHByXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRwcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiZHByXCIsIFwiZHByXCIsIGZ1bmN0aW9uIChkcHIpIHtcbiAgICAgICAgZHByID0gZHByLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKGRwciAhPSBudWxsID8gZHByLm1hdGNoKC9eXFxkKyQvKSA6IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiBkcHIgKyBcIi4wXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24ubm9ybWFsaXplKGRwcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlZmZlY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWZmZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcnJheVBhcmFtKHZhbHVlLCBcImVmZmVjdFwiLCBcImVcIiwgXCI6XCIsIGV4cHJlc3Npb24ubm9ybWFsaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWxzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZWxzZSgpIHtcbiAgICAgIHJldHVybiB0aGlzW1wiaWZcIl0oJ2Vsc2UnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kSWZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kSWYoKSB7XG4gICAgICByZXR1cm4gdGhpc1tcImlmXCJdKCdlbmQnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kT2Zmc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZE9mZnNldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmFuZ2VQYXJhbSh2YWx1ZSwgXCJlbmRfb2Zmc2V0XCIsIFwiZW9cIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZhbGxiYWNrQ29udGVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmYWxsYmFja0NvbnRlbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImZhbGxiYWNrX2NvbnRlbnRcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZldGNoRm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZldGNoRm9ybWF0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJmZXRjaF9mb3JtYXRcIiwgXCJmXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JtYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJmb3JtYXRcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZsYWdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZsYWdzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcnJheVBhcmFtKHZhbHVlLCBcImZsYWdzXCIsIFwiZmxcIiwgXCIuXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJncmF2aXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdyYXZpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImdyYXZpdHlcIiwgXCJnXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnBzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJmcHNcIiwgXCJmcHNcIiwgZnVuY3Rpb24gKGZwcykge1xuICAgICAgICBpZiAoaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkoZnBzKSkge1xuICAgICAgICAgIHJldHVybiBmcHM7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKGZwcykpIHtcbiAgICAgICAgICByZXR1cm4gZnBzLmpvaW4oXCItXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmcHM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoZWlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGVpZ2h0KHZhbHVlKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiaGVpZ2h0XCIsIFwiaFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpczMuZ2V0VmFsdWUoXCJjcm9wXCIpIHx8IF90aGlzMy5nZXRWYWx1ZShcIm92ZXJsYXlcIikgfHwgX3RoaXMzLmdldFZhbHVlKFwidW5kZXJsYXlcIikpIHtcbiAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbi5ub3JtYWxpemUodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaHRtbEhlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBodG1sSGVpZ2h0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJodG1sX2hlaWdodFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaHRtbFdpZHRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGh0bWxXaWR0aCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiaHRtbF93aWR0aFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaWZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lmKCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBcIlwiO1xuICAgICAgdmFyIGksIGlmVmFsLCBqLCByZWYsIHRySWYsIHRyUmVzdDtcblxuICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICBjYXNlIFwiZWxzZVwiOlxuICAgICAgICAgIHRoaXMuY2hhaW4oKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJpZlwiLCBcImlmXCIpO1xuXG4gICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICB0aGlzLmNoYWluKCk7XG5cbiAgICAgICAgICBmb3IgKGkgPSBqID0gcmVmID0gdGhpcy5jaGFpbmVkLmxlbmd0aCAtIDE7IGogPj0gMDsgaSA9IGogKz0gLTEpIHtcbiAgICAgICAgICAgIGlmVmFsID0gdGhpcy5jaGFpbmVkW2ldLmdldFZhbHVlKFwiaWZcIik7XG5cbiAgICAgICAgICAgIGlmIChpZlZhbCA9PT0gXCJlbmRcIikge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaWZWYWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICB0cklmID0gVHJhbnNmb3JtYXRpb25bXCJuZXdcIl0oKVtcImlmXCJdKGlmVmFsKTtcbiAgICAgICAgICAgICAgdGhpcy5jaGFpbmVkW2ldLnJlbW92ZShcImlmXCIpO1xuICAgICAgICAgICAgICB0clJlc3QgPSB0aGlzLmNoYWluZWRbaV07XG4gICAgICAgICAgICAgIHRoaXMuY2hhaW5lZFtpXSA9IFRyYW5zZm9ybWF0aW9uW1wibmV3XCJdKCkudHJhbnNmb3JtYXRpb24oW3RySWYsIHRyUmVzdF0pO1xuXG4gICAgICAgICAgICAgIGlmIChpZlZhbCAhPT0gXCJlbHNlXCIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImlmXCIsIFwiaWZcIik7XG5cbiAgICAgICAgY2FzZSBcIlwiOlxuICAgICAgICAgIHJldHVybiBjb25kaXRpb25bXCJuZXdcIl0oKS5zZXRQYXJlbnQodGhpcyk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJpZlwiLCBcImlmXCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmRpdGlvbltcIm5ld1wiXSh2YWx1ZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwia2V5ZnJhbWVJbnRlcnZhbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBrZXlmcmFtZUludGVydmFsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJrZXlmcmFtZV9pbnRlcnZhbFwiLCBcImtpXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvY3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2NyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJvY3JcIiwgXCJvY3JcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9mZnNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvZmZzZXQodmFsdWUpIHtcbiAgICAgIHZhciBlbmRfbywgc3RhcnRfbztcblxuICAgICAgdmFyIF9yZWYyID0gaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKHZhbHVlICE9IG51bGwgPyB2YWx1ZS5zcGxpdCA6IHZvaWQgMCkgPyB2YWx1ZS5zcGxpdCgnLi4nKSA6IGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKSh2YWx1ZSkgPyB2YWx1ZSA6IFtudWxsLCBudWxsXTtcblxuICAgICAgdmFyIF9yZWYzID0gdHJhbnNmb3JtYXRpb25fc2xpY2VkVG9BcnJheShfcmVmMiwgMik7XG5cbiAgICAgIHN0YXJ0X28gPSBfcmVmM1swXTtcbiAgICAgIGVuZF9vID0gX3JlZjNbMV07XG5cbiAgICAgIGlmIChzdGFydF9vICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5zdGFydE9mZnNldChzdGFydF9vKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuZF9vICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kT2Zmc2V0KGVuZF9vKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3BhY2l0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcGFjaXR5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJvcGFjaXR5XCIsIFwib1wiLCBleHByZXNzaW9uLm5vcm1hbGl6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm92ZXJsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3ZlcmxheSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMubGF5ZXJQYXJhbSh2YWx1ZSwgXCJvdmVybGF5XCIsIFwibFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYWdlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJwYWdlXCIsIFwicGdcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvc3RlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3N0ZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInBvc3RlclwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJlZml4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZWZpeCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwicHJlZml4XCIsIFwicFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicXVhbGl0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBxdWFsaXR5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJxdWFsaXR5XCIsIFwicVwiLCBleHByZXNzaW9uLm5vcm1hbGl6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJhZGl1c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByYWRpdXModmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmFycmF5UGFyYW0odmFsdWUsIFwicmFkaXVzXCIsIFwiclwiLCBcIjpcIiwgZXhwcmVzc2lvbi5ub3JtYWxpemUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyYXdUcmFuc2Zvcm1hdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByYXdUcmFuc2Zvcm1hdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmF3UGFyYW0odmFsdWUsIFwicmF3X3RyYW5zZm9ybWF0aW9uXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpemUodmFsdWUpIHtcbiAgICAgIHZhciBoZWlnaHQsIHdpZHRoO1xuXG4gICAgICBpZiAoaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKHZhbHVlICE9IG51bGwgPyB2YWx1ZS5zcGxpdCA6IHZvaWQgMCkpIHtcbiAgICAgICAgdmFyIF92YWx1ZSRzcGxpdCA9IHZhbHVlLnNwbGl0KCd4Jyk7XG5cbiAgICAgICAgdmFyIF92YWx1ZSRzcGxpdDIgPSB0cmFuc2Zvcm1hdGlvbl9zbGljZWRUb0FycmF5KF92YWx1ZSRzcGxpdCwgMik7XG5cbiAgICAgICAgd2lkdGggPSBfdmFsdWUkc3BsaXQyWzBdO1xuICAgICAgICBoZWlnaHQgPSBfdmFsdWUkc3BsaXQyWzFdO1xuICAgICAgICB0aGlzLndpZHRoKHdpZHRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0KGhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNvdXJjZVR5cGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvdXJjZVR5cGVzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJzb3VyY2VfdHlwZXNcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNvdXJjZVRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvdXJjZVRyYW5zZm9ybWF0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJzb3VyY2VfdHJhbnNmb3JtYXRpb25cIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0T2Zmc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0T2Zmc2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yYW5nZVBhcmFtKHZhbHVlLCBcInN0YXJ0X29mZnNldFwiLCBcInNvXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdHJlYW1pbmdQcm9maWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0cmVhbWluZ1Byb2ZpbGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInN0cmVhbWluZ19wcm9maWxlXCIsIFwic3BcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1hdGlvblBhcmFtKHZhbHVlLCBcInRyYW5zZm9ybWF0aW9uXCIsIFwidFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5kZXJsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5kZXJsYXkodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmxheWVyUGFyYW0odmFsdWUsIFwidW5kZXJsYXlcIiwgXCJ1XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YXJpYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YXJpYWJsZShuYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIG5hbWUsIG5hbWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YXJpYWJsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFyaWFibGVzKHZhbHVlcykge1xuICAgICAgcmV0dXJuIHRoaXMuYXJyYXlQYXJhbSh2YWx1ZXMsIFwidmFyaWFibGVzXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2aWRlb0NvZGVjXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZpZGVvQ29kZWModmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInZpZGVvX2NvZGVjXCIsIFwidmNcIiwgcGFyYW1ldGVyc19QYXJhbS5wcm9jZXNzX3ZpZGVvX3BhcmFtcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZpZGVvU2FtcGxpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmlkZW9TYW1wbGluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwidmlkZW9fc2FtcGxpbmdcIiwgXCJ2c1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2lkdGgodmFsdWUpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJ3aWR0aFwiLCBcIndcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXM0LmdldFZhbHVlKFwiY3JvcFwiKSB8fCBfdGhpczQuZ2V0VmFsdWUoXCJvdmVybGF5XCIpIHx8IF90aGlzNC5nZXRWYWx1ZShcInVuZGVybGF5XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24ubm9ybWFsaXplKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24geCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwieFwiLCBcInhcIiwgZXhwcmVzc2lvbi5ub3JtYWxpemUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInlcIiwgXCJ5XCIsIGV4cHJlc3Npb24ubm9ybWFsaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiem9vbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB6b29tKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJ6b29tXCIsIFwielwiLCBleHByZXNzaW9uLm5vcm1hbGl6ZSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwibmV3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9uZXcob3B0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1hdGlvbihvcHRpb25zKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVHJhbnNmb3JtYXRpb247XG59KHRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uQmFzZSk7XG4vKipcbiAqIFRyYW5zZm9ybWF0aW9uIENsYXNzIG1ldGhvZHMuXG4gKiBUaGlzIGlzIGEgbGlzdCBvZiB0aGUgcGFyYW1ldGVycyBkZWZpbmVkIGluIFRyYW5zZm9ybWF0aW9uLlxuICogVmFsdWVzIGFyZSBjYW1lbENhc2VkLlxuICovXG5cblxudHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb24ubWV0aG9kcyA9IFtcImFuZ2xlXCIsIFwiYXVkaW9Db2RlY1wiLCBcImF1ZGlvRnJlcXVlbmN5XCIsIFwiYXNwZWN0UmF0aW9cIiwgXCJiYWNrZ3JvdW5kXCIsIFwiYml0UmF0ZVwiLCBcImJvcmRlclwiLCBcImNvbG9yXCIsIFwiY29sb3JTcGFjZVwiLCBcImNyb3BcIiwgXCJjdXN0b21GdW5jdGlvblwiLCBcImN1c3RvbVByZUZ1bmN0aW9uXCIsIFwiZGVmYXVsdEltYWdlXCIsIFwiZGVsYXlcIiwgXCJkZW5zaXR5XCIsIFwiZHVyYXRpb25cIiwgXCJkcHJcIiwgXCJlZmZlY3RcIiwgXCJlbHNlXCIsIFwiZW5kSWZcIiwgXCJlbmRPZmZzZXRcIiwgXCJmYWxsYmFja0NvbnRlbnRcIiwgXCJmZXRjaEZvcm1hdFwiLCBcImZvcm1hdFwiLCBcImZsYWdzXCIsIFwiZ3Jhdml0eVwiLCBcImZwc1wiLCBcImhlaWdodFwiLCBcImh0bWxIZWlnaHRcIiwgXCJodG1sV2lkdGhcIiwgXCJpZlwiLCBcImtleWZyYW1lSW50ZXJ2YWxcIiwgXCJvY3JcIiwgXCJvZmZzZXRcIiwgXCJvcGFjaXR5XCIsIFwib3ZlcmxheVwiLCBcInBhZ2VcIiwgXCJwb3N0ZXJcIiwgXCJwcmVmaXhcIiwgXCJxdWFsaXR5XCIsIFwicmFkaXVzXCIsIFwicmF3VHJhbnNmb3JtYXRpb25cIiwgXCJzaXplXCIsIFwic291cmNlVHlwZXNcIiwgXCJzb3VyY2VUcmFuc2Zvcm1hdGlvblwiLCBcInN0YXJ0T2Zmc2V0XCIsIFwic3RyZWFtaW5nUHJvZmlsZVwiLCBcInRyYW5zZm9ybWF0aW9uXCIsIFwidW5kZXJsYXlcIiwgXCJ2YXJpYWJsZVwiLCBcInZhcmlhYmxlc1wiLCBcInZpZGVvQ29kZWNcIiwgXCJ2aWRlb1NhbXBsaW5nXCIsIFwid2lkdGhcIiwgXCJ4XCIsIFwieVwiLCBcInpvb21cIl07XG4vKipcbiAqIFBhcmFtZXRlcnMgdGhhdCBhcmUgZmlsdGVyZWQgb3V0IGJlZm9yZSBwYXNzaW5nIHRoZSBvcHRpb25zIHRvIGFuIEhUTUwgdGFnLlxuICpcbiAqIFRoZSBsaXN0IG9mIHBhcmFtZXRlcnMgaXMgYSBjb21iaW5hdGlvbiBvZiBgVHJhbnNmb3JtYXRpb246Om1ldGhvZHNgIGFuZCBgQ29uZmlndXJhdGlvbjo6Q09ORklHX1BBUkFNU2BcbiAqL1xuXG50cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbi5QQVJBTV9OQU1FUyA9IHRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uLm1ldGhvZHMubWFwKHNuYWtlQ2FzZSkuY29uY2F0KHNyY19jb25maWd1cmF0aW9uLkNPTkZJR19QQVJBTVMpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX3RyYW5zZm9ybWF0aW9uID0gKHRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3RhZ3MvaHRtbHRhZy5qc1xuZnVuY3Rpb24gaHRtbHRhZ19jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIGh0bWx0YWdfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIGh0bWx0YWdfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBodG1sdGFnX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBodG1sdGFnX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8qKlxuICogR2VuZXJpYyBIVE1MIHRhZ1xuICogRGVwZW5kcyBvbiAndHJhbnNmb3JtYXRpb24nLCAndXRpbCdcbiAqL1xuXG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBIVE1MIChET00pIHRhZ1xuICogQGNvbnN0cnVjdG9yIEh0bWxUYWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIHRhZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtwdWJsaWNJZF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAZXhhbXBsZSB0YWcgPSBuZXcgSHRtbFRhZyggJ2RpdicsIHsgJ3dpZHRoJzogMTB9KVxuICovXG5cbnZhciBodG1sdGFnX0h0bWxUYWcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBIdG1sVGFnKG5hbWUsIHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgaHRtbHRhZ19jbGFzc0NhbGxDaGVjayh0aGlzLCBIdG1sVGFnKTtcblxuICAgIHZhciB0cmFuc2Zvcm1hdGlvbjtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucHVibGljSWQgPSBwdWJsaWNJZDtcblxuICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgIGlmIChpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0KCkocHVibGljSWQpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBwdWJsaWNJZDtcbiAgICAgICAgdGhpcy5wdWJsaWNJZCA9IHZvaWQgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cmFuc2Zvcm1hdGlvbiA9IG5ldyBzcmNfdHJhbnNmb3JtYXRpb24ob3B0aW9ucyk7XG4gICAgdHJhbnNmb3JtYXRpb24uc2V0UGFyZW50KHRoaXMpO1xuXG4gICAgdGhpcy50cmFuc2Zvcm1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1hdGlvbjtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBjb25zdHJ1Y3RvclxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGFuIEhUTUwgKERPTSkgdGFnXG4gICAqIEBmdW5jdGlvbiBIdG1sVGFnLm5ld1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSB0YWdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtwdWJsaWNJZF1cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7SHRtbFRhZ31cbiAgICogQGV4YW1wbGUgdGFnID0gSHRtbFRhZy5uZXcoICdkaXYnLCB7ICd3aWR0aCc6IDEwfSlcbiAgICovXG5cblxuICBodG1sdGFnX2NyZWF0ZUNsYXNzKEh0bWxUYWcsIFt7XG4gICAga2V5OiBcImh0bWxBdHRyc1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIGNvbWJpbmUga2V5IGFuZCB2YWx1ZSBmcm9tIHRoZSBgYXR0cmAgdG8gZ2VuZXJhdGUgYW4gSFRNTCB0YWcgYXR0cmlidXRlcyBzdHJpbmcuXG4gICAgICogYFRyYW5zZm9ybWF0aW9uOjp0b0h0bWxUYWdPcHRpb25zYCBpcyB1c2VkIHRvIGZpbHRlciBvdXQgdHJhbnNmb3JtYXRpb24gYW5kIGNvbmZpZ3VyYXRpb24ga2V5cy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJzXG4gICAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgYXR0cmlidXRlcyBpbiB0aGUgZm9ybWF0IGAna2V5MT1cInZhbHVlMVwiIGtleTI9XCJ2YWx1ZTJcIidgXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGh0bWxBdHRycyhhdHRycykge1xuICAgICAgdmFyIGtleSwgcGFpcnMsIHZhbHVlO1xuICAgICAgcmV0dXJuIHBhaXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0cztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgdmFsdWUgPSBlc2NhcGVRdW90ZXMoYXR0cnNba2V5XSk7XG5cbiAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChodG1sdGFnX3RvQXR0cmlidXRlKGtleSwgdmFsdWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH0oKS5zb3J0KCkuam9pbignICcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIG9wdGlvbnMgcmVsYXRlZCB0byB0aGlzIHRhZy5cbiAgICAgKiBAZnVuY3Rpb24gSHRtbFRhZyNnZXRPcHRpb25zXG4gICAgICogQHJldHVybnMge09iamVjdH0gdGhlIG9wdGlvbnNcbiAgICAgKlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPcHRpb25zKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtYXRpb24oKS50b09wdGlvbnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB2YWx1ZSBvZiBvcHRpb24gYG5hbWVgXG4gICAgICogQGZ1bmN0aW9uIEh0bWxUYWcjZ2V0T3B0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgb3B0aW9uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBvcHRpb25cbiAgICAgKlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T3B0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9wdGlvbihuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1hdGlvbigpLmdldFZhbHVlKG5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIHRhZy5cbiAgICAgKiBAZnVuY3Rpb24gSHRtbFRhZyNhdHRyaWJ1dGVzXG4gICAgICogQHJldHVybnMge09iamVjdH0gYXR0cmlidXRlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYXR0cmlidXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVzKCkge1xuICAgICAgLy8gVGhlIGF0dHJpYnV0ZXMgYXJlIGJlIGNvbXB1dGVkIGZyb20gdGhlIG9wdGlvbnMgZXZlcnkgdGltZSB0aGlzIG1ldGhvZCBpcyBpbnZva2VkLlxuICAgICAgdmFyIGh0bWxBdHRyaWJ1dGVzID0gdGhpcy50cmFuc2Zvcm1hdGlvbigpLnRvSHRtbEF0dHJpYnV0ZXMoKTtcbiAgICAgIE9iamVjdC5rZXlzKGh0bWxBdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQoKShodG1sQXR0cmlidXRlc1trZXldKSkge1xuICAgICAgICAgIGRlbGV0ZSBodG1sQXR0cmlidXRlc1trZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGh0bWxBdHRyaWJ1dGVzLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgLy8gQ3VycmVudGx5IEhUTUwgYXR0cmlidXRlcyBhcmUgZGVmaW5lZCBib3RoIGF0IHRoZSB0b3AgbGV2ZWwgYW5kIHVuZGVyICdhdHRyaWJ1dGVzJ1xuICAgICAgICBtZXJnZV9yb290X21lcmdlX2RlZmF1bHQoKShodG1sQXR0cmlidXRlcywgaHRtbEF0dHJpYnV0ZXMuYXR0cmlidXRlcyk7XG4gICAgICAgIGRlbGV0ZSBodG1sQXR0cmlidXRlcy5hdHRyaWJ1dGVzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaHRtbEF0dHJpYnV0ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBhIHRhZyBhdHRyaWJ1dGUgbmFtZWQgYG5hbWVgIHRvIGB2YWx1ZWBcbiAgICAgKiBAZnVuY3Rpb24gSHRtbFRhZyNzZXRBdHRyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gdGhlIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldEF0dHJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QXR0cihuYW1lLCB2YWx1ZSkge1xuICAgICAgdGhpcy50cmFuc2Zvcm1hdGlvbigpLnNldChcImh0bWxfXCIuY29uY2F0KG5hbWUpLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgdGFnIGF0dHJpYnV0ZSBgbmFtZWBcbiAgICAgKiBAZnVuY3Rpb24gSHRtbFRhZyNnZXRBdHRyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRBdHRyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF0dHIobmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcygpW1wiaHRtbF9cIi5jb25jYXQobmFtZSldIHx8IHRoaXMuYXR0cmlidXRlcygpW25hbWVdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIHRhZyBhdHRyaWJ1dGVkIG5hbWVkIGBuYW1lYFxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI3JlbW92ZUF0dHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUF0dHJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQXR0cihuYW1lKSB7XG4gICAgICB2YXIgcmVmO1xuICAgICAgcmV0dXJuIChyZWYgPSB0aGlzLnRyYW5zZm9ybWF0aW9uKCkucmVtb3ZlKFwiaHRtbF9cIi5jb25jYXQobmFtZSkpKSAhPSBudWxsID8gcmVmIDogdGhpcy50cmFuc2Zvcm1hdGlvbigpLnJlbW92ZShuYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEh0bWxUYWcjY29udGVudFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjb250ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnRlbnQoKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEh0bWxUYWcjb3BlblRhZ1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvcGVuVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW5UYWcoKSB7XG4gICAgICB2YXIgdGFnID0gXCI8XCIgKyB0aGlzLm5hbWU7XG4gICAgICB2YXIgaHRtbEF0dHJzID0gdGhpcy5odG1sQXR0cnModGhpcy5hdHRyaWJ1dGVzKCkpO1xuXG4gICAgICBpZiAoaHRtbEF0dHJzICYmIGh0bWxBdHRycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRhZyArPSBcIiBcIiArIGh0bWxBdHRycztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRhZyArIFwiPlwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gSHRtbFRhZyNjbG9zZVRhZ1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZVRhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZVRhZygpIHtcbiAgICAgIHJldHVybiBcIjwvXCIuY29uY2F0KHRoaXMubmFtZSwgXCI+XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYW4gSFRNTCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGFnLlxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI3RvSHRtbFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgSFRNTCBpbiBzdHJpbmcgZm9ybWF0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b0h0bWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9IdG1sKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3BlblRhZygpICsgdGhpcy5jb250ZW50KCkgKyB0aGlzLmNsb3NlVGFnKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBET00gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgdGFnLlxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI3RvRE9NXG4gICAgICogQHJldHVybnMge0VsZW1lbnR9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b0RPTVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0RPTSgpIHtcbiAgICAgIHZhciBlbGVtZW50LCBuYW1lLCByZWYsIHZhbHVlO1xuXG4gICAgICBpZiAoIWlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKSh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQgIT09IG51bGwgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50IDogdm9pZCAwKSkge1xuICAgICAgICB0aHJvdyBcIkNhbid0IGNyZWF0ZSBET00gaWYgZG9jdW1lbnQgaXMgbm90IHByZXNlbnQhXCI7XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMubmFtZSk7XG4gICAgICByZWYgPSB0aGlzLmF0dHJpYnV0ZXMoKTtcblxuICAgICAgZm9yIChuYW1lIGluIHJlZikge1xuICAgICAgICB2YWx1ZSA9IHJlZltuYW1lXTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJuZXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX25ldyhuYW1lLCBwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKG5hbWUsIHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNSZXNwb25zaXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzUmVzcG9uc2l2ZSh0YWcsIHJlc3BvbnNpdmVDbGFzcykge1xuICAgICAgdmFyIGRhdGFTcmM7XG4gICAgICBkYXRhU3JjID0gbG9kYXNoX2dldERhdGEodGFnLCAnc3JjLWNhY2hlJykgfHwgbG9kYXNoX2dldERhdGEodGFnLCAnc3JjJyk7XG4gICAgICByZXR1cm4gbG9kYXNoX2hhc0NsYXNzKHRhZywgcmVzcG9uc2l2ZUNsYXNzKSAmJiAvXFxid19hdXRvXFxiLy5leGVjKGRhdGFTcmMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIdG1sVGFnO1xufSgpO1xuXG47XG4vKipcbiAqIFJlcHJlc2VudCB0aGUgZ2l2ZW4ga2V5IGFuZCB2YWx1ZSBhcyBhbiBIVE1MIGF0dHJpYnV0ZS5cbiAqIEBmdW5jdGlvbiB0b0F0dHJpYnV0ZVxuICogQHByb3RlY3RlZFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIGF0dHJpYnV0ZSBuYW1lXG4gKiBAcGFyYW0geyp8Ym9vbGVhbn0gdmFsdWUgLSB0aGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZS4gSWYgdGhlIHZhbHVlIGlzIGJvb2xlYW4gYHRydWVgLCByZXR1cm4gdGhlIGtleSBvbmx5LlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGF0dHJpYnV0ZVxuICpcbiAqL1xuXG5mdW5jdGlvbiBodG1sdGFnX3RvQXR0cmlidXRlKGtleSwgdmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICByZXR1cm4ga2V5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdChrZXksIFwiPVxcXCJcIikuY29uY2F0KHZhbHVlLCBcIlxcXCJcIik7XG4gIH1cbn1cbi8qKlxuICogSWYgZ2l2ZW4gdmFsdWUgaXMgYSBzdHJpbmcsIHJlcGxhY2VzIHF1b3RlcyB3aXRoIGNoYXJhY3RlciBlbnRpdGllcyAoJiMzNDssICYjMzk7KVxuICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gY2hhbmdlXG4gKiBAcmV0dXJucyB7Kn0gY2hhbmdlZCB2YWx1ZVxuICovXG5cblxuZnVuY3Rpb24gZXNjYXBlUXVvdGVzKHZhbHVlKSB7XG4gIHJldHVybiBpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQoKSh2YWx1ZSkgPyB2YWx1ZS5yZXBsYWNlKCdcIicsICcmIzM0OycpLnJlcGxhY2UoXCInXCIsICcmIzM5OycpIDogdmFsdWU7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGh0bWx0YWcgPSAoaHRtbHRhZ19IdG1sVGFnKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3VybC5qc1xudmFyIF9leGNsdWRlZCA9IFtcInBsYWNlaG9sZGVyXCIsIFwiYWNjZXNzaWJpbGl0eVwiXTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuXG5cblxuXG5cblxuLyoqXG4gKiBBZGRzIHByb3RvY29sLCBob3N0LCBwYXRobmFtZSBwcmVmaXhlcyB0byBnaXZlbiBzdHJpbmdcbiAqIEBwYXJhbSBzdHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gbWFrZVVybChzdHIpIHtcbiAgdmFyIHByZWZpeCA9IGRvY3VtZW50LmxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIGRvY3VtZW50LmxvY2F0aW9uLmhvc3Q7XG5cbiAgaWYgKHN0clswXSA9PT0gJz8nKSB7XG4gICAgcHJlZml4ICs9IGRvY3VtZW50LmxvY2F0aW9uLnBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKHN0clswXSAhPT0gJy8nKSB7XG4gICAgcHJlZml4ICs9IGRvY3VtZW50LmxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgJy8nKTtcbiAgfVxuXG4gIHJldHVybiBwcmVmaXggKyBzdHI7XG59XG4vKipcbiAqIENoZWNrIGlzIGdpdmVuIHN0cmluZyBpcyBhIHVybFxuICogQHBhcmFtIHN0clxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc1VybChzdHIpIHtcbiAgcmV0dXJuIHN0ciA/ICEhc3RyLm1hdGNoKC9eaHR0cHM/OlxcLy8pIDogZmFsc2U7XG59IC8vIFByb2R1Y2UgYSBudW1iZXIgYmV0d2VlbiAxIGFuZCA1IHRvIGJlIHVzZWQgZm9yIGNkbiBzdWIgZG9tYWlucyBkZXNpZ25hdGlvblxuXG5cbmZ1bmN0aW9uIGNkblN1YmRvbWFpbk51bWJlcihwdWJsaWNJZCkge1xuICByZXR1cm4gc3JjX2NyYzMyKHB1YmxpY0lkKSAlIDUgKyAxO1xufVxuLyoqXG4gKiBSZW1vdmVzIHNpZ25hdHVyZSBmcm9tIG9wdGlvbnMgYW5kIHJldHVybnMgdGhlIHNpZ25hdHVyZVxuICogTWFrZXMgc3VyZSBzaWduYXR1cmUgaXMgZW1wdHkgb3Igb2YgdGhpcyBmb3JtYXQ6IHMtLXNpZ25hdHVyZS0tXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHJldHVybnMge3N0cmluZ30gdGhlIGZvcm1hdHRlZCBzaWduYXR1cmVcbiAqL1xuXG5cbmZ1bmN0aW9uIGhhbmRsZVNpZ25hdHVyZShvcHRpb25zKSB7XG4gIHZhciBzaWduYXR1cmUgPSBvcHRpb25zLnNpZ25hdHVyZTtcbiAgdmFyIGlzRm9ybWF0dGVkID0gIXNpZ25hdHVyZSB8fCBzaWduYXR1cmUuaW5kZXhPZigncy0tJykgPT09IDAgJiYgc2lnbmF0dXJlLnN1YnN0cigtMikgPT09ICctLSc7XG4gIGRlbGV0ZSBvcHRpb25zLnNpZ25hdHVyZTtcbiAgcmV0dXJuIGlzRm9ybWF0dGVkID8gc2lnbmF0dXJlIDogXCJzLS1cIi5jb25jYXQoc2lnbmF0dXJlLCBcIi0tXCIpO1xufVxuLyoqXG4gKiBDcmVhdGUgdGhlIFVSTCBwcmVmaXggZm9yIENsb3VkaW5hcnkgcmVzb3VyY2VzLlxuICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIHRoZSByZXNvdXJjZSBwdWJsaWMgSURcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGFkZGl0aW9uYWwgb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2xvdWRfbmFtZSAtIHRoZSBjbG91ZCBuYW1lLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jZG5fc3ViZG9tYWluPWZhbHNlXSAtIFdoZXRoZXIgdG8gYXV0b21hdGljYWxseSBidWlsZCBVUkxzIHdpdGhcbiAqICBtdWx0aXBsZSBDRE4gc3ViLWRvbWFpbnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucHJpdmF0ZV9jZG5dIC0gQm9vbGVhbiAoZGVmYXVsdDogZmFsc2UpLiBTaG91bGQgYmUgc2V0IHRvIHRydWUgZm9yIEFkdmFuY2VkIHBsYW4ncyB1c2Vyc1xuICogIHRoYXQgaGF2ZSBhIHByaXZhdGUgQ0ROIGRpc3RyaWJ1dGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wcm90b2NvbD1cImh0dHA6Ly9cIl0gLSB0aGUgVVJJIHByb3RvY29sIHRvIHVzZS4gSWYgb3B0aW9ucy5zZWN1cmUgaXMgdHJ1ZSxcbiAqICB0aGUgdmFsdWUgaXMgb3ZlcnJpZGRlbiB0byBcImh0dHBzOi8vXCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zZWN1cmVfZGlzdHJpYnV0aW9uXSAtIFRoZSBkb21haW4gbmFtZSBvZiB0aGUgQ0ROIGRpc3RyaWJ1dGlvbiB0byB1c2UgZm9yIGJ1aWxkaW5nIEhUVFBTIFVSTHMuXG4gKiAgUmVsZXZhbnQgb25seSBmb3IgQWR2YW5jZWQgcGxhbidzIHVzZXJzIHRoYXQgaGF2ZSBhIHByaXZhdGUgQ0ROIGRpc3RyaWJ1dGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jbmFtZV0gLSBDdXN0b20gZG9tYWluIG5hbWUgdG8gdXNlIGZvciBidWlsZGluZyBIVFRQIFVSTHMuXG4gKiAgUmVsZXZhbnQgb25seSBmb3IgQWR2YW5jZWQgcGxhbidzIHVzZXJzIHRoYXQgaGF2ZSBhIHByaXZhdGUgQ0ROIGRpc3RyaWJ1dGlvbiBhbmQgYSBjdXN0b20gQ05BTUUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZV9jZG5fc3ViZG9tYWluPXRydWVdIC0gV2hlbiBvcHRpb25zLnNlY3VyZSBpcyB0cnVlIGFuZCB0aGlzIHBhcmFtZXRlciBpcyBmYWxzZSxcbiAqICB0aGUgc3ViZG9tYWluIGlzIHNldCB0byBcInJlc1wiLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWN1cmU9ZmFsc2VdIC0gRm9yY2UgSFRUUFMgVVJMcyBvZiBpbWFnZXMgZXZlbiBpZiBlbWJlZGRlZCBpbiBub24tc2VjdXJlIEhUVFAgcGFnZXMuXG4gKiAgV2hlbiB0aGlzIHZhbHVlIGlzIHRydWUsIG9wdGlvbnMuc2VjdXJlX2Rpc3RyaWJ1dGlvbiB3aWxsIGJlIHVzZWQgYXMgaG9zdCBpZiBwcm92aWRlZCwgYW5kIG9wdGlvbnMucHJvdG9jb2wgaXMgc2V0XG4gKiAgdG8gXCJodHRwczovL1wiLlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIFVSTCBwcmVmaXggZm9yIHRoZSByZXNvdXJjZS5cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBoYW5kbGVQcmVmaXgocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuY2xvdWRfbmFtZSAmJiBvcHRpb25zLmNsb3VkX25hbWVbMF0gPT09ICcvJykge1xuICAgIHJldHVybiAnL3JlcycgKyBvcHRpb25zLmNsb3VkX25hbWU7XG4gIH0gLy8gZGVmYXVsdHNcblxuXG4gIHZhciBwcm90b2NvbCA9IFwiaHR0cDovL1wiO1xuICB2YXIgY2RuUGFydCA9IFwiXCI7XG4gIHZhciBzdWJkb21haW4gPSBcInJlc1wiO1xuICB2YXIgaG9zdCA9IFwiLmNsb3VkaW5hcnkuY29tXCI7XG4gIHZhciBwYXRoID0gXCIvXCIgKyBvcHRpb25zLmNsb3VkX25hbWU7IC8vIG1vZGlmaWNhdGlvbnNcblxuICBpZiAob3B0aW9ucy5wcm90b2NvbCkge1xuICAgIHByb3RvY29sID0gb3B0aW9ucy5wcm90b2NvbCArICcvLyc7XG4gIH1cblxuICBpZiAob3B0aW9ucy5wcml2YXRlX2Nkbikge1xuICAgIGNkblBhcnQgPSBvcHRpb25zLmNsb3VkX25hbWUgKyBcIi1cIjtcbiAgICBwYXRoID0gXCJcIjtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmNkbl9zdWJkb21haW4pIHtcbiAgICBzdWJkb21haW4gPSBcInJlcy1cIiArIGNkblN1YmRvbWFpbk51bWJlcihwdWJsaWNJZCk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5zZWN1cmUpIHtcbiAgICBwcm90b2NvbCA9IFwiaHR0cHM6Ly9cIjtcblxuICAgIGlmIChvcHRpb25zLnNlY3VyZV9jZG5fc3ViZG9tYWluID09PSBmYWxzZSkge1xuICAgICAgc3ViZG9tYWluID0gXCJyZXNcIjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zZWN1cmVfZGlzdHJpYnV0aW9uICE9IG51bGwgJiYgb3B0aW9ucy5zZWN1cmVfZGlzdHJpYnV0aW9uICE9PSBPTERfQUtBTUFJX1NIQVJFRF9DRE4gJiYgb3B0aW9ucy5zZWN1cmVfZGlzdHJpYnV0aW9uICE9PSBTSEFSRURfQ0ROKSB7XG4gICAgICBjZG5QYXJ0ID0gXCJcIjtcbiAgICAgIHN1YmRvbWFpbiA9IFwiXCI7XG4gICAgICBob3N0ID0gb3B0aW9ucy5zZWN1cmVfZGlzdHJpYnV0aW9uO1xuICAgIH1cbiAgfSBlbHNlIGlmIChvcHRpb25zLmNuYW1lKSB7XG4gICAgcHJvdG9jb2wgPSBcImh0dHA6Ly9cIjtcbiAgICBjZG5QYXJ0ID0gXCJcIjtcbiAgICBzdWJkb21haW4gPSBvcHRpb25zLmNkbl9zdWJkb21haW4gPyAnYScgKyAoc3JjX2NyYzMyKHB1YmxpY0lkKSAlIDUgKyAxKSArICcuJyA6ICcnO1xuICAgIGhvc3QgPSBvcHRpb25zLmNuYW1lO1xuICB9XG5cbiAgcmV0dXJuIFtwcm90b2NvbCwgY2RuUGFydCwgc3ViZG9tYWluLCBob3N0LCBwYXRoXS5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiBSZXR1cm4gdGhlIHJlc291cmNlIHR5cGUgYW5kIGFjdGlvbiB0eXBlIGJhc2VkIG9uIHRoZSBnaXZlbiBjb25maWd1cmF0aW9uXG4gKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNoYW5kbGVSZXNvdXJjZVR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gcmVzb3VyY2VfdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlPSd1cGxvYWQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFt1cmxfc3VmZml4XVxuICogQHBhcmFtIHtib29sZWFufSBbdXNlX3Jvb3RfcGF0aF1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Nob3J0ZW5dXG4gKiBAcmV0dXJucyB7c3RyaW5nfSByZXNvdXJjZV90eXBlL3R5cGVcbiAqIEBpZ25vcmVcbiAqL1xuXG5cbmZ1bmN0aW9uIGhhbmRsZVJlc291cmNlVHlwZShfcmVmKSB7XG4gIHZhciBfcmVmJHJlc291cmNlX3R5cGUgPSBfcmVmLnJlc291cmNlX3R5cGUsXG4gICAgICByZXNvdXJjZV90eXBlID0gX3JlZiRyZXNvdXJjZV90eXBlID09PSB2b2lkIDAgPyBcImltYWdlXCIgOiBfcmVmJHJlc291cmNlX3R5cGUsXG4gICAgICBfcmVmJHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICB0eXBlID0gX3JlZiR0eXBlID09PSB2b2lkIDAgPyBcInVwbG9hZFwiIDogX3JlZiR0eXBlLFxuICAgICAgdXJsX3N1ZmZpeCA9IF9yZWYudXJsX3N1ZmZpeCxcbiAgICAgIHVzZV9yb290X3BhdGggPSBfcmVmLnVzZV9yb290X3BhdGgsXG4gICAgICBzaG9ydGVuID0gX3JlZi5zaG9ydGVuO1xuICB2YXIgb3B0aW9ucyxcbiAgICAgIHJlc291cmNlVHlwZSA9IHJlc291cmNlX3R5cGU7XG5cbiAgaWYgKGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQoKShyZXNvdXJjZVR5cGUpKSB7XG4gICAgb3B0aW9ucyA9IHJlc291cmNlVHlwZTtcbiAgICByZXNvdXJjZVR5cGUgPSBvcHRpb25zLnJlc291cmNlX3R5cGU7XG4gICAgdHlwZSA9IG9wdGlvbnMudHlwZTtcbiAgICBzaG9ydGVuID0gb3B0aW9ucy5zaG9ydGVuO1xuICB9XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHR5cGUgPSAndXBsb2FkJztcbiAgfVxuXG4gIGlmICh1cmxfc3VmZml4ICE9IG51bGwpIHtcbiAgICByZXNvdXJjZVR5cGUgPSBTRU9fVFlQRVNbXCJcIi5jb25jYXQocmVzb3VyY2VUeXBlLCBcIi9cIikuY29uY2F0KHR5cGUpXTtcbiAgICB0eXBlID0gbnVsbDtcblxuICAgIGlmIChyZXNvdXJjZVR5cGUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVVJMIFN1ZmZpeCBvbmx5IHN1cHBvcnRlZCBmb3IgXCIuY29uY2F0KE9iamVjdC5rZXlzKFNFT19UWVBFUykuam9pbignLCAnKSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh1c2Vfcm9vdF9wYXRoKSB7XG4gICAgaWYgKHJlc291cmNlVHlwZSA9PT0gJ2ltYWdlJyAmJiB0eXBlID09PSAndXBsb2FkJyB8fCByZXNvdXJjZVR5cGUgPT09IFwiaW1hZ2VzXCIpIHtcbiAgICAgIHJlc291cmNlVHlwZSA9IG51bGw7XG4gICAgICB0eXBlID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9vdCBwYXRoIG9ubHkgc3VwcG9ydGVkIGZvciBpbWFnZS91cGxvYWRcIik7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNob3J0ZW4gJiYgcmVzb3VyY2VUeXBlID09PSAnaW1hZ2UnICYmIHR5cGUgPT09ICd1cGxvYWQnKSB7XG4gICAgcmVzb3VyY2VUeXBlID0gJ2l1JztcbiAgICB0eXBlID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBbcmVzb3VyY2VUeXBlLCB0eXBlXS5qb2luKFwiL1wiKTtcbn1cbi8qKlxuICogRW5jb2RlIHB1YmxpY0lkXG4gKiBAcGFyYW0gcHVibGljSWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGVuY29kZWQgcHVibGljSWRcbiAqL1xuXG5cbmZ1bmN0aW9uIGVuY29kZVB1YmxpY0lkKHB1YmxpY0lkKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQocHVibGljSWQpLnJlcGxhY2UoLyUzQS9nLCAnOicpLnJlcGxhY2UoLyUyRi9nLCAnLycpO1xufVxuLyoqXG4gKiBFbmNvZGUgYW5kIGZvcm1hdCBwdWJsaWNJZFxuICogQHBhcmFtIHB1YmxpY0lkXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybnMge3N0cmluZ30gcHVibGljSWRcbiAqL1xuXG5cbmZ1bmN0aW9uIGZvcm1hdFB1YmxpY0lkKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gIGlmIChpc1VybChwdWJsaWNJZCkpIHtcbiAgICBwdWJsaWNJZCA9IGVuY29kZVB1YmxpY0lkKHB1YmxpY0lkKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgLy8gTWFrZSBzdXJlIHB1YmxpY0lkIGlzIFVSSSBlbmNvZGVkLlxuICAgICAgcHVibGljSWQgPSBkZWNvZGVVUklDb21wb25lbnQocHVibGljSWQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxuXG4gICAgcHVibGljSWQgPSBlbmNvZGVQdWJsaWNJZChwdWJsaWNJZCk7XG5cbiAgICBpZiAob3B0aW9ucy51cmxfc3VmZml4KSB7XG4gICAgICBwdWJsaWNJZCA9IHB1YmxpY0lkICsgJy8nICsgb3B0aW9ucy51cmxfc3VmZml4O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmZvcm1hdCkge1xuICAgICAgaWYgKCFvcHRpb25zLnRydXN0X3B1YmxpY19pZCkge1xuICAgICAgICBwdWJsaWNJZCA9IHB1YmxpY0lkLnJlcGxhY2UoL1xcLihqcGd8cG5nfGdpZnx3ZWJwKSQvLCAnJyk7XG4gICAgICB9XG5cbiAgICAgIHB1YmxpY0lkID0gcHVibGljSWQgKyAnLicgKyBvcHRpb25zLmZvcm1hdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHVibGljSWQ7XG59XG4vKipcbiAqIEdldCBhbnkgZXJyb3Igd2l0aCB1cmwgb3B0aW9uc1xuICogQHBhcmFtIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGlmIGVycm9yLCBvdGhlcndpc2UgcmV0dXJuIHVuZGVmaW5lZFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGUob3B0aW9ucykge1xuICB2YXIgY2xvdWRfbmFtZSA9IG9wdGlvbnMuY2xvdWRfbmFtZSxcbiAgICAgIHVybF9zdWZmaXggPSBvcHRpb25zLnVybF9zdWZmaXg7XG5cbiAgaWYgKCFjbG91ZF9uYW1lKSB7XG4gICAgcmV0dXJuICdVbmtub3duIGNsb3VkX25hbWUnO1xuICB9XG5cbiAgaWYgKHVybF9zdWZmaXggJiYgdXJsX3N1ZmZpeC5tYXRjaCgvW1xcLlxcL10vKSkge1xuICAgIHJldHVybiAndXJsX3N1ZmZpeCBzaG91bGQgbm90IGluY2x1ZGUgLiBvciAvJztcbiAgfVxufVxuLyoqXG4gKiBHZXQgdmVyc2lvbiBwYXJ0IG9mIHRoZSB1cmxcbiAqIEBwYXJhbSBwdWJsaWNJZFxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBoYW5kbGVWZXJzaW9uKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gIC8vIGZvcmNlX3ZlcnNpb24gcGFyYW0gbWVhbnMgdG8gbWFrZSBzdXJlIHRoZXJlIGlzIGEgdmVyc2lvbiBpbiB0aGUgdXJsIChEZWZhdWx0IGlzIHRydWUpXG4gIHZhciBpc0ZvcmNlVmVyc2lvbiA9IG9wdGlvbnMuZm9yY2VfdmVyc2lvbiB8fCB0eXBlb2Ygb3B0aW9ucy5mb3JjZV92ZXJzaW9uID09PSAndW5kZWZpbmVkJzsgLy8gSXMgdmVyc2lvbiBpbmNsdWRlZCBpbiBwdWJsaWNJZCBvciBpbiBvcHRpb25zLCBvciBwdWJsaWNJZCBpcyBhIHVybCAoZG9lc24ndCBuZWVkIHZlcnNpb24pXG5cbiAgdmFyIGlzVmVyc2lvbkV4aXN0ID0gcHVibGljSWQuaW5kZXhPZignLycpIDwgMCB8fCBwdWJsaWNJZC5tYXRjaCgvXnZbMC05XSsvKSB8fCBpc1VybChwdWJsaWNJZCkgfHwgb3B0aW9ucy52ZXJzaW9uO1xuXG4gIGlmIChpc0ZvcmNlVmVyc2lvbiAmJiAhaXNWZXJzaW9uRXhpc3QpIHtcbiAgICBvcHRpb25zLnZlcnNpb24gPSAxO1xuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnMudmVyc2lvbiA/IFwidlwiLmNvbmNhdChvcHRpb25zLnZlcnNpb24pIDogJyc7XG59XG4vKipcbiAqIEdldCBmaW5hbCB0cmFuc2Zvcm1hdGlvbiBjb21wb25lbnQgZm9yIHVybCBzdHJpbmdcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gaGFuZGxlVHJhbnNmb3JtYXRpb24ob3B0aW9ucykge1xuICB2YXIgX3JlZjIgPSBvcHRpb25zIHx8IHt9LFxuICAgICAgcGxhY2Vob2xkZXIgPSBfcmVmMi5wbGFjZWhvbGRlcixcbiAgICAgIGFjY2Vzc2liaWxpdHkgPSBfcmVmMi5hY2Nlc3NpYmlsaXR5LFxuICAgICAgb3RoZXJPcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBfZXhjbHVkZWQpO1xuXG4gIHZhciByZXN1bHQgPSBuZXcgc3JjX3RyYW5zZm9ybWF0aW9uKG90aGVyT3B0aW9ucyk7IC8vIEFwcGVuZCBhY2Nlc3NpYmlsaXR5IHRyYW5zZm9ybWF0aW9uc1xuXG4gIGlmIChhY2Nlc3NpYmlsaXR5ICYmIEFDQ0VTU0lCSUxJVFlfTU9ERVNbYWNjZXNzaWJpbGl0eV0pIHtcbiAgICByZXN1bHQuY2hhaW4oKS5lZmZlY3QoQUNDRVNTSUJJTElUWV9NT0RFU1thY2Nlc3NpYmlsaXR5XSk7XG4gIH0gLy8gQXBwZW5kIHBsYWNlaG9sZGVyIHRyYW5zZm9ybWF0aW9uc1xuXG5cbiAgaWYgKHBsYWNlaG9sZGVyKSB7XG4gICAgaWYgKHBsYWNlaG9sZGVyID09PSBcInByZWRvbWluYW50LWNvbG9yXCIgJiYgcmVzdWx0LmdldFZhbHVlKCd3aWR0aCcpICYmIHJlc3VsdC5nZXRWYWx1ZSgnaGVpZ2h0JykpIHtcbiAgICAgIHBsYWNlaG9sZGVyICs9ICctcGl4ZWwnO1xuICAgIH1cblxuICAgIHZhciBwbGFjZWhvbGRlclRyYW5zZm9ybWF0aW9ucyA9IFBMQUNFSE9MREVSX0lNQUdFX01PREVTW3BsYWNlaG9sZGVyXSB8fCBQTEFDRUhPTERFUl9JTUFHRV9NT0RFUy5ibHVyO1xuICAgIHBsYWNlaG9sZGVyVHJhbnNmb3JtYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQuY2hhaW4oKS50cmFuc2Zvcm1hdGlvbih0KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQuc2VyaWFsaXplKCk7XG59XG4vKipcbiAqIElmIHR5cGUgaXMgJ2ZldGNoJywgdXBkYXRlIHB1YmxpY0lkIHRvIGJlIGEgdXJsXG4gKiBAcGFyYW0gcHVibGljSWRcbiAqIEBwYXJhbSB0eXBlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gcHJlcGFyZVB1YmxpY0lkKHB1YmxpY0lkLCBfcmVmMykge1xuICB2YXIgdHlwZSA9IF9yZWYzLnR5cGU7XG4gIHJldHVybiAhaXNVcmwocHVibGljSWQpICYmIHR5cGUgPT09ICdmZXRjaCcgPyBtYWtlVXJsKHB1YmxpY0lkKSA6IHB1YmxpY0lkO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSB1cmwgc3RyaW5nXG4gKiBAcGFyYW0gcHVibGljSWRcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBmaW5hbCB1cmxcbiAqL1xuXG5cbmZ1bmN0aW9uIHVybFN0cmluZyhwdWJsaWNJZCwgb3B0aW9ucykge1xuICBpZiAoaXNVcmwocHVibGljSWQpICYmIChvcHRpb25zLnR5cGUgPT09ICd1cGxvYWQnIHx8IG9wdGlvbnMudHlwZSA9PT0gJ2Fzc2V0JykpIHtcbiAgICByZXR1cm4gcHVibGljSWQ7XG4gIH1cblxuICB2YXIgdmVyc2lvbiA9IGhhbmRsZVZlcnNpb24ocHVibGljSWQsIG9wdGlvbnMpO1xuICB2YXIgdHJhbnNmb3JtYXRpb25TdHJpbmcgPSBoYW5kbGVUcmFuc2Zvcm1hdGlvbihvcHRpb25zKTtcbiAgdmFyIHByZWZpeCA9IGhhbmRsZVByZWZpeChwdWJsaWNJZCwgb3B0aW9ucyk7XG4gIHZhciBzaWduYXR1cmUgPSBoYW5kbGVTaWduYXR1cmUob3B0aW9ucyk7XG4gIHZhciByZXNvdXJjZVR5cGUgPSBoYW5kbGVSZXNvdXJjZVR5cGUob3B0aW9ucyk7XG4gIHB1YmxpY0lkID0gZm9ybWF0UHVibGljSWQocHVibGljSWQsIG9wdGlvbnMpO1xuICByZXR1cm4gY29tcGFjdF9yb290X2NvbXBhY3RfZGVmYXVsdCgpKFtwcmVmaXgsIHJlc291cmNlVHlwZSwgc2lnbmF0dXJlLCB0cmFuc2Zvcm1hdGlvblN0cmluZywgdmVyc2lvbiwgcHVibGljSWRdKS5qb2luKCcvJykucmVwbGFjZSgvKFteOl0pXFwvKy9nLCAnJDEvJykgLy8gcmVwbGFjZSAnLy8vJyB3aXRoICcvLydcbiAgLnJlcGxhY2UoJyAnLCAnJTIwJyk7XG59XG4vKipcbiAqIE1lcmdlIG9wdGlvbnMgYW5kIGNvbmZpZyB3aXRoIGRlZmF1bHRzXG4gKiB1cGRhdGUgb3B0aW9ucyBmZXRjaF9mb3JtYXQgYWNjb3JkaW5nIHRvICd0eXBlJyBwYXJhbVxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSBjb25maWdcbiAqIEByZXR1cm5zIHsqfSB1cGRhdGVkIG9wdGlvbnNcbiAqL1xuXG5cbmZ1bmN0aW9uIHByZXBhcmVPcHRpb25zKG9wdGlvbnMsIGNvbmZpZykge1xuICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIHNyY190cmFuc2Zvcm1hdGlvbikge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zLnRvT3B0aW9ucygpO1xuICB9XG5cbiAgb3B0aW9ucyA9IGRlZmF1bHRzKHt9LCBvcHRpb25zLCBjb25maWcsIERFRkFVTFRfSU1BR0VfUEFSQU1TKTtcblxuICBpZiAob3B0aW9ucy50eXBlID09PSAnZmV0Y2gnKSB7XG4gICAgb3B0aW9ucy5mZXRjaF9mb3JtYXQgPSBvcHRpb25zLmZldGNoX2Zvcm1hdCB8fCBvcHRpb25zLmZvcm1hdDtcbiAgfVxuXG4gIHJldHVybiBvcHRpb25zO1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBVUkwgZm9yIGFueSBhc3NldCBpbiB5b3VyIE1lZGlhIGxpYnJhcnkuXG4gKiBAZnVuY3Rpb24gdXJsXG4gKiBAaWdub3JlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgcHVibGljIElEIG9mIHRoZSBtZWRpYSBhc3NldC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzIHRvIGluY2x1ZGUgaW4gdGhlIFVSTC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbY29uZmlnPXt9XSAtIFVSTCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7dHlwZX0gW29wdGlvbnMudHlwZT0ndXBsb2FkJ10gLSBUaGUgYXNzZXQncyBzdG9yYWdlIHR5cGUuXG4gKiAgRm9yIGRldGFpbHMgb24gYWxsIGZldGNoIHR5cGVzLCBzZWVcbiAqIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25zI2ZldGNoaW5nX2ltYWdlc19mcm9tX3JlbW90ZV9sb2NhdGlvbnNcIlxuICogIHRhcmdldD1cIl9ibGFua1wiPkZldGNoIHR5cGVzPC9hPi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5yZXNvdXJjZV90eXBlPSdpbWFnZSddIC0gVGhlIHR5cGUgb2YgYXNzZXQuIDxwPlBvc3NpYmxlIHZhbHVlczo8YnIvPlxuICogIC0gYGltYWdlYDxici8+XG4gKiAgLSBgdmlkZW9gPGJyLz5cbiAqICAtIGByYXdgXG4gKiBAcGFyYW0ge3NpZ25hdHVyZX0gW29wdGlvbnMuc2lnbmF0dXJlPSdzLS0xMjM0NTY3OC0tJ10gLSBUaGUgc2lnbmF0dXJlIGNvbXBvbmVudCBvZiBhXG4gKiAgc2lnbmVkIGRlbGl2ZXJ5IFVSTCBvZiB0aGUgZm9ybWF0OiAvcy0tU0lHTkFUVVJFLS0vLlxuICogIEZvciBkZXRhaWxzIG9uIHNpZ25hdHVyZXMsIHNlZVxuICogPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zaWduYXR1cmVzXCIgdGFyZ2V0PVwiX2JsYW5rXCI+U2lnbmF0dXJlczwvYT4uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBtZWRpYSBhc3NldCBVUkwuXG4gKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gKiAgQXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi92aWRlb190cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAqICBBdmFpbGFibGUgdmlkZW8gdHJhbnNmb3JtYXRpb25zPC9hPlxuICovXG5cblxuZnVuY3Rpb24gdXJsX3VybChwdWJsaWNJZCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBjb25maWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gIGlmICghcHVibGljSWQpIHtcbiAgICByZXR1cm4gcHVibGljSWQ7XG4gIH1cblxuICBvcHRpb25zID0gcHJlcGFyZU9wdGlvbnMob3B0aW9ucywgY29uZmlnKTtcbiAgcHVibGljSWQgPSBwcmVwYXJlUHVibGljSWQocHVibGljSWQsIG9wdGlvbnMpO1xuICB2YXIgZXJyb3IgPSB2YWxpZGF0ZShvcHRpb25zKTtcblxuICBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHZhciByZXN1bHRVcmwgPSB1cmxTdHJpbmcocHVibGljSWQsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zLnVybEFuYWx5dGljcykge1xuICAgIHZhciBhbmFseXRpY3NPcHRpb25zID0gZ2V0QW5hbHl0aWNzT3B0aW9ucyhvcHRpb25zKTtcbiAgICB2YXIgc2RrQW5hbHl0aWNzU2lnbmF0dXJlID0gZ2V0U0RLQW5hbHl0aWNzU2lnbmF0dXJlKGFuYWx5dGljc09wdGlvbnMpOyAvLyB1cmwgbWlnaHQgYWxyZWFkeSBoYXZlIGEgJz8nIHF1ZXJ5IHBhcmFtXG5cbiAgICB2YXIgYXBwZW5kZXIgPSAnPyc7XG5cbiAgICBpZiAocmVzdWx0VXJsLmluZGV4T2YoJz8nKSA+PSAwKSB7XG4gICAgICBhcHBlbmRlciA9ICcmJztcbiAgICB9XG5cbiAgICByZXN1bHRVcmwgPSBcIlwiLmNvbmNhdChyZXN1bHRVcmwpLmNvbmNhdChhcHBlbmRlciwgXCJfYT1cIikuY29uY2F0KHNka0FuYWx5dGljc1NpZ25hdHVyZSk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5hdXRoX3Rva2VuKSB7XG4gICAgdmFyIF9hcHBlbmRlciA9IHJlc3VsdFVybC5pbmRleE9mKCc/JykgPj0gMCA/ICcmJyA6ICc/JztcblxuICAgIHJlc3VsdFVybCA9IFwiXCIuY29uY2F0KHJlc3VsdFVybCkuY29uY2F0KF9hcHBlbmRlciwgXCJfX2NsZF90b2tlbl9fPVwiKS5jb25jYXQob3B0aW9ucy5hdXRoX3Rva2VuKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRVcmw7XG59XG47XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL2dlbmVyYXRlQnJlYWtwb2ludHMuanNcbmZ1bmN0aW9uIGdlbmVyYXRlQnJlYWtwb2ludHNfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIGdlbmVyYXRlQnJlYWtwb2ludHNfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBnZW5lcmF0ZUJyZWFrcG9pbnRzX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgZ2VuZXJhdGVCcmVha3BvaW50c191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IGdlbmVyYXRlQnJlYWtwb2ludHNfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gZ2VuZXJhdGVCcmVha3BvaW50c19ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gZ2VuZXJhdGVCcmVha3BvaW50c191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGdlbmVyYXRlQnJlYWtwb2ludHNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGdlbmVyYXRlQnJlYWtwb2ludHNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQnJlYWtwb2ludHNfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gZ2VuZXJhdGVCcmVha3BvaW50c19pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9zLCBfZTsgdHJ5IHsgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQnJlYWtwb2ludHNfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24uIEdldHMgb3IgcG9wdWxhdGVzIHNyY3NldCBicmVha3BvaW50cyB1c2luZyBwcm92aWRlZCBwYXJhbWV0ZXJzXG4gKiBFaXRoZXIgdGhlIGJyZWFrcG9pbnRzIG9yIG1pbl93aWR0aCwgbWF4X3dpZHRoLCBtYXhfaW1hZ2VzIG11c3QgYmUgcHJvdmlkZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3Jjc2V0fSBzcmNzZXQgT3B0aW9ucyB3aXRoIGVpdGhlciBgYnJlYWtwb2ludHNgIG9yIGBtaW5fd2lkdGhgLCBgbWF4X3dpZHRoYCwgYW5kIGBtYXhfaW1hZ2VzYFxuICpcbiAqIEByZXR1cm4ge251bWJlcltdfSBBcnJheSBvZiBicmVha3BvaW50c1xuICpcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVCcmVha3BvaW50cyhzcmNzZXQpIHtcbiAgdmFyIGJyZWFrcG9pbnRzID0gc3Jjc2V0LmJyZWFrcG9pbnRzIHx8IFtdO1xuXG4gIGlmIChicmVha3BvaW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYnJlYWtwb2ludHM7XG4gIH1cblxuICB2YXIgX21hcCA9IFtzcmNzZXQubWluX3dpZHRoLCBzcmNzZXQubWF4X3dpZHRoLCBzcmNzZXQubWF4X2ltYWdlc10ubWFwKE51bWJlciksXG4gICAgICBfbWFwMiA9IGdlbmVyYXRlQnJlYWtwb2ludHNfc2xpY2VkVG9BcnJheShfbWFwLCAzKSxcbiAgICAgIG1pbl93aWR0aCA9IF9tYXAyWzBdLFxuICAgICAgbWF4X3dpZHRoID0gX21hcDJbMV0sXG4gICAgICBtYXhfaW1hZ2VzID0gX21hcDJbMl07XG5cbiAgaWYgKFttaW5fd2lkdGgsIG1heF93aWR0aCwgbWF4X2ltYWdlc10uc29tZShpc05hTikpIHtcbiAgICB0aHJvdyAnRWl0aGVyIChtaW5fd2lkdGgsIG1heF93aWR0aCwgbWF4X2ltYWdlcykgJyArICdvciBicmVha3BvaW50cyBtdXN0IGJlIHByb3ZpZGVkIHRvIHRoZSBpbWFnZSBzcmNzZXQgYXR0cmlidXRlJztcbiAgfVxuXG4gIGlmIChtaW5fd2lkdGggPiBtYXhfd2lkdGgpIHtcbiAgICB0aHJvdyAnbWluX3dpZHRoIG11c3QgYmUgbGVzcyB0aGFuIG1heF93aWR0aCc7XG4gIH1cblxuICBpZiAobWF4X2ltYWdlcyA8PSAwKSB7XG4gICAgdGhyb3cgJ21heF9pbWFnZXMgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInO1xuICB9IGVsc2UgaWYgKG1heF9pbWFnZXMgPT09IDEpIHtcbiAgICBtaW5fd2lkdGggPSBtYXhfd2lkdGg7XG4gIH1cblxuICB2YXIgc3RlcFNpemUgPSBNYXRoLmNlaWwoKG1heF93aWR0aCAtIG1pbl93aWR0aCkgLyBNYXRoLm1heChtYXhfaW1hZ2VzIC0gMSwgMSkpO1xuXG4gIGZvciAodmFyIGN1cnJlbnQgPSBtaW5fd2lkdGg7IGN1cnJlbnQgPCBtYXhfd2lkdGg7IGN1cnJlbnQgKz0gc3RlcFNpemUpIHtcbiAgICBicmVha3BvaW50cy5wdXNoKGN1cnJlbnQpO1xuICB9XG5cbiAgYnJlYWtwb2ludHMucHVzaChtYXhfd2lkdGgpO1xuICByZXR1cm4gYnJlYWtwb2ludHM7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL3NyY3NldFV0aWxzLmpzXG5cbnZhciBzcmNzZXRVdGlsc19pc0VtcHR5ID0gaXNFbXB0eTtcblxuXG5cbi8qKlxuICogT3B0aW9ucyB1c2VkIHRvIGdlbmVyYXRlIHRoZSBzcmNzZXQgYXR0cmlidXRlLlxuICogQHR5cGVkZWYge29iamVjdH0gc3Jjc2V0XG4gKiBAcHJvcGVydHkgeyhudW1iZXJbXXxzdHJpbmdbXSl9ICAgW2JyZWFrcG9pbnRzXSBBbiBhcnJheSBvZiBicmVha3BvaW50cy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgICAgICAgICAgICAgICBbbWluX3dpZHRoXSAgIE1pbmltYWwgd2lkdGggb2YgdGhlIHNyY3NldCBpbWFnZXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gICAgICAgICAgICAgICAgW21heF93aWR0aF0gICBNYXhpbWFsIHdpZHRoIG9mIHRoZSBzcmNzZXQgaW1hZ2VzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9ICAgICAgICAgICAgICAgIFttYXhfaW1hZ2VzXSAgTnVtYmVyIG9mIHNyY3NldCBpbWFnZXMgdG8gZ2VuZXJhdGUuXG4gKiBAcHJvcGVydHkge29iamVjdHxzdHJpbmd9ICAgICAgICAgW3RyYW5zZm9ybWF0aW9uXSBUaGUgdHJhbnNmb3JtYXRpb24gdG8gdXNlIGluIHRoZSBzcmNzZXQgdXJscy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gICAgICAgICAgICAgICBbc2l6ZXNdIFdoZXRoZXIgdG8gY2FsY3VsYXRlIGFuZCBhZGQgdGhlIHNpemVzIGF0dHJpYnV0ZS5cbiAqL1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbi4gR2VuZXJhdGVzIGEgc2luZ2xlIHNyY3NldCBpdGVtIHVybFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHVibGljX2lkICBQdWJsaWMgSUQgb2YgdGhlIHJlc291cmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoICAgICAgV2lkdGggaW4gcGl4ZWxzIG9mIHRoZSBzcmNzZXQgaXRlbS5cbiAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gdHJhbnNmb3JtYXRpb25cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICAgIEFkZGl0aW9uYWwgb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFJlc3VsdGluZyBVUkwgb2YgdGhlIGl0ZW1cbiAqL1xuXG5mdW5jdGlvbiBzY2FsZWRVcmwocHVibGljX2lkLCB3aWR0aCwgdHJhbnNmb3JtYXRpb24pIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICB2YXIgY29uZmlnUGFyYW1zID0gZXh0cmFjdFVybFBhcmFtcyhvcHRpb25zKTtcbiAgdHJhbnNmb3JtYXRpb24gPSB0cmFuc2Zvcm1hdGlvbiB8fCBvcHRpb25zO1xuICBjb25maWdQYXJhbXMucmF3X3RyYW5zZm9ybWF0aW9uID0gbmV3IHNyY190cmFuc2Zvcm1hdGlvbihbbWVyZ2Vfcm9vdF9tZXJnZV9kZWZhdWx0LmEoe30sIHRyYW5zZm9ybWF0aW9uKSwge1xuICAgIGNyb3A6ICdzY2FsZScsXG4gICAgd2lkdGg6IHdpZHRoXG4gIH1dKS50b1N0cmluZygpO1xuICByZXR1cm4gdXJsX3VybChwdWJsaWNfaWQsIGNvbmZpZ1BhcmFtcyk7XG59XG4vKipcbiAqIElmIGNhY2hlIGlzIGVuYWJsZWQsIGdldCB0aGUgYnJlYWtwb2ludHMgZnJvbSB0aGUgY2FjaGUuIElmIHRoZSB2YWx1ZXMgd2VyZSBub3QgZm91bmQgaW4gdGhlIGNhY2hlLFxuICogb3IgY2FjaGUgaXMgbm90IGVuYWJsZWQsIGdlbmVyYXRlIHRoZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge3NyY3NldH0gc3Jjc2V0IFRoZSBzcmNzZXQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge3N0cmluZ30gcHVibGljX2lkXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7KnxBcnJheX1cbiAqL1xuXG5mdW5jdGlvbiBnZXRPckdlbmVyYXRlQnJlYWtwb2ludHMocHVibGljX2lkKSB7XG4gIHZhciBzcmNzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHJldHVybiBnZW5lcmF0ZUJyZWFrcG9pbnRzKHNyY3NldCk7XG59XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbi4gR2VuZXJhdGVzIHNyY3NldCBhdHRyaWJ1dGUgdmFsdWUgb2YgdGhlIEhUTUwgaW1nIHRhZ1xuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHVibGljX2lkICBQdWJsaWMgSUQgb2YgdGhlIHJlc291cmNlXG4gKiBAcGFyYW0ge251bWJlcltdfSBicmVha3BvaW50cyBBbiBhcnJheSBvZiBicmVha3BvaW50cyAoaW4gcGl4ZWxzKVxuICogQHBhcmFtIHtvYmplY3R9IHRyYW5zZm9ybWF0aW9uIFRoZSB0cmFuc2Zvcm1hdGlvblxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgSW5jbHVkZXMgaHRtbCB0YWcgb3B0aW9ucywgdHJhbnNmb3JtYXRpb24gb3B0aW9uc1xuICogQHJldHVybiB7c3RyaW5nfSBSZXN1bHRpbmcgc3Jjc2V0IGF0dHJpYnV0ZSB2YWx1ZVxuICovXG5cbmZ1bmN0aW9uIGdlbmVyYXRlU3Jjc2V0QXR0cmlidXRlKHB1YmxpY19pZCwgYnJlYWtwb2ludHMsIHRyYW5zZm9ybWF0aW9uLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBjbG9uZURlZXBfcm9vdF9jbG9uZURlZXBfZGVmYXVsdC5hKG9wdGlvbnMpO1xuICBwYXRjaEZldGNoRm9ybWF0KG9wdGlvbnMpO1xuICByZXR1cm4gYnJlYWtwb2ludHMubWFwKGZ1bmN0aW9uICh3aWR0aCkge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdChzY2FsZWRVcmwocHVibGljX2lkLCB3aWR0aCwgdHJhbnNmb3JtYXRpb24sIG9wdGlvbnMpLCBcIiBcIikuY29uY2F0KHdpZHRoLCBcIndcIik7XG4gIH0pLmpvaW4oJywgJyk7XG59XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbi4gR2VuZXJhdGVzIHNpemVzIGF0dHJpYnV0ZSB2YWx1ZSBvZiB0aGUgSFRNTCBpbWcgdGFnXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJbXX0gYnJlYWtwb2ludHMgQW4gYXJyYXkgb2YgYnJlYWtwb2ludHMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFJlc3VsdGluZyBzaXplcyBhdHRyaWJ1dGUgdmFsdWVcbiAqL1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVNpemVzQXR0cmlidXRlKGJyZWFrcG9pbnRzKSB7XG4gIGlmIChicmVha3BvaW50cyA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcmV0dXJuIGJyZWFrcG9pbnRzLm1hcChmdW5jdGlvbiAod2lkdGgpIHtcbiAgICByZXR1cm4gXCIobWF4LXdpZHRoOiBcIi5jb25jYXQod2lkdGgsIFwicHgpIFwiKS5jb25jYXQod2lkdGgsIFwicHhcIik7XG4gIH0pLmpvaW4oJywgJyk7XG59XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbi4gR2VuZXJhdGVzIHNyY3NldCBhbmQgc2l6ZXMgYXR0cmlidXRlcyBvZiB0aGUgaW1hZ2UgdGFnXG4gKlxuICogR2VuZXJhdGVkIGF0dHJpYnV0ZXMgYXJlIGFkZGVkIHRvIGF0dHJpYnV0ZXMgYXJndW1lbnRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9ICAgIHB1YmxpY0lkICBUaGUgcHVibGljIElEIG9mIHRoZSByZXNvdXJjZVxuICogQHBhcmFtIHtvYmplY3R9ICAgIGF0dHJpYnV0ZXMgRXhpc3RpbmcgSFRNTCBhdHRyaWJ1dGVzLlxuICogQHBhcmFtIHtzcmNzZXR9ICAgIHNyY3NldERhdGFcbiAqIEBwYXJhbSB7b2JqZWN0fSAgICBvcHRpb25zICAgIEFkZGl0aW9uYWwgb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJuIGFycmF5IFRoZSByZXNwb25zaXZlIGF0dHJpYnV0ZXNcbiAqL1xuXG5mdW5jdGlvbiBnZW5lcmF0ZUltYWdlUmVzcG9uc2l2ZUF0dHJpYnV0ZXMocHVibGljSWQpIHtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgc3Jjc2V0RGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgLy8gQ3JlYXRlIGJvdGggc3Jjc2V0IGFuZCBzaXplcyBoZXJlIHRvIGF2b2lkIGZldGNoaW5nIGJyZWFrcG9pbnRzIHR3aWNlXG4gIHZhciByZXNwb25zaXZlQXR0cmlidXRlcyA9IHt9O1xuXG4gIGlmIChzcmNzZXRVdGlsc19pc0VtcHR5KHNyY3NldERhdGEpKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNpdmVBdHRyaWJ1dGVzO1xuICB9XG5cbiAgdmFyIGdlbmVyYXRlU2l6ZXMgPSAhYXR0cmlidXRlcy5zaXplcyAmJiBzcmNzZXREYXRhLnNpemVzID09PSB0cnVlO1xuICB2YXIgZ2VuZXJhdGVTcmNzZXQgPSAhYXR0cmlidXRlcy5zcmNzZXQ7XG5cbiAgaWYgKGdlbmVyYXRlU3Jjc2V0IHx8IGdlbmVyYXRlU2l6ZXMpIHtcbiAgICB2YXIgYnJlYWtwb2ludHMgPSBnZXRPckdlbmVyYXRlQnJlYWtwb2ludHMocHVibGljSWQsIHNyY3NldERhdGEsIG9wdGlvbnMpO1xuXG4gICAgaWYgKGdlbmVyYXRlU3Jjc2V0KSB7XG4gICAgICB2YXIgdHJhbnNmb3JtYXRpb24gPSBzcmNzZXREYXRhLnRyYW5zZm9ybWF0aW9uO1xuICAgICAgdmFyIHNyY3NldEF0dHIgPSBnZW5lcmF0ZVNyY3NldEF0dHJpYnV0ZShwdWJsaWNJZCwgYnJlYWtwb2ludHMsIHRyYW5zZm9ybWF0aW9uLCBvcHRpb25zKTtcblxuICAgICAgaWYgKCFzcmNzZXRVdGlsc19pc0VtcHR5KHNyY3NldEF0dHIpKSB7XG4gICAgICAgIHJlc3BvbnNpdmVBdHRyaWJ1dGVzLnNyY3NldCA9IHNyY3NldEF0dHI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGdlbmVyYXRlU2l6ZXMpIHtcbiAgICAgIHZhciBzaXplc0F0dHIgPSBnZW5lcmF0ZVNpemVzQXR0cmlidXRlKGJyZWFrcG9pbnRzKTtcblxuICAgICAgaWYgKCFzcmNzZXRVdGlsc19pc0VtcHR5KHNpemVzQXR0cikpIHtcbiAgICAgICAgcmVzcG9uc2l2ZUF0dHJpYnV0ZXMuc2l6ZXMgPSBzaXplc0F0dHI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3BvbnNpdmVBdHRyaWJ1dGVzO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBhIG1lZGlhIHF1ZXJ5XG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBvcHRpb25zLm1pbl93aWR0aFxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBvcHRpb25zLm1heF93aWR0aFxuICogQHJldHVybiB7c3RyaW5nfSBhIG1lZGlhIHF1ZXJ5IHN0cmluZ1xuICovXG5cbmZ1bmN0aW9uIGdlbmVyYXRlTWVkaWFBdHRyKG9wdGlvbnMpIHtcbiAgdmFyIG1lZGlhUXVlcnkgPSBbXTtcblxuICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgaWYgKG9wdGlvbnMubWluX3dpZHRoICE9IG51bGwpIHtcbiAgICAgIG1lZGlhUXVlcnkucHVzaChcIihtaW4td2lkdGg6IFwiLmNvbmNhdChvcHRpb25zLm1pbl93aWR0aCwgXCJweClcIikpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm1heF93aWR0aCAhPSBudWxsKSB7XG4gICAgICBtZWRpYVF1ZXJ5LnB1c2goXCIobWF4LXdpZHRoOiBcIi5jb25jYXQob3B0aW9ucy5tYXhfd2lkdGgsIFwicHgpXCIpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWVkaWFRdWVyeS5qb2luKCcgYW5kICcpO1xufVxudmFyIHNyY3NldFVybCA9IHNjYWxlZFVybDtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3RhZ3MvaW1hZ2V0YWcuanNcbmZ1bmN0aW9uIGltYWdldGFnX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gaW1hZ2V0YWdfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgaW1hZ2V0YWdfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gaW1hZ2V0YWdfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBpbWFnZXRhZ19kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gaW1hZ2V0YWdfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBpbWFnZXRhZ19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgaW1hZ2V0YWdfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gaW1hZ2V0YWdfZ2V0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgaW1hZ2V0YWdfZ2V0ID0gUmVmbGVjdC5nZXQuYmluZCgpOyB9IGVsc2UgeyBpbWFnZXRhZ19nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gaW1hZ2V0YWdfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gaW1hZ2V0YWdfZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gaW1hZ2V0YWdfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IGltYWdldGFnX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gaW1hZ2V0YWdfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgaW1hZ2V0YWdfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIGltYWdldGFnX3NldFByb3RvdHlwZU9mKG8sIHApIHsgaW1hZ2V0YWdfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIGltYWdldGFnX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIGltYWdldGFnX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBpbWFnZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBpbWFnZXRhZ19nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gaW1hZ2V0YWdfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIGltYWdldGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBpbWFnZXRhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKGltYWdldGFnX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBpbWFnZXRhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gaW1hZ2V0YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gaW1hZ2V0YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gaW1hZ2V0YWdfZ2V0UHJvdG90eXBlT2YobykgeyBpbWFnZXRhZ19nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gaW1hZ2V0YWdfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuLyoqXG4gKiBJbWFnZSBUYWdcbiAqIERlcGVuZHMgb24gJ3RhZ3MvaHRtbHRhZycsICdjbG91ZGluYXJ5J1xuICovXG5cblxuXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBIVE1MIChET00pIEltYWdlIHRhZyB1c2luZyBDbG91ZGluYXJ5IGFzIHRoZSBzb3VyY2UuXG4gKiBAY29uc3RydWN0b3IgSW1hZ2VUYWdcbiAqIEBleHRlbmRzIEh0bWxUYWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHVibGljSWRdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKi9cblxudmFyIGltYWdldGFnX0ltYWdlVGFnID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSHRtbFRhZykge1xuICBpbWFnZXRhZ19pbmhlcml0cyhJbWFnZVRhZywgX0h0bWxUYWcpO1xuXG4gIHZhciBfc3VwZXIgPSBpbWFnZXRhZ19jcmVhdGVTdXBlcihJbWFnZVRhZyk7XG5cbiAgZnVuY3Rpb24gSW1hZ2VUYWcocHVibGljSWQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBpbWFnZXRhZ19jbGFzc0NhbGxDaGVjayh0aGlzLCBJbWFnZVRhZyk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgXCJpbWdcIiwgcHVibGljSWQsIG9wdGlvbnMpO1xuICB9XG4gIC8qKiBAb3ZlcnJpZGUgKi9cblxuXG4gIGltYWdldGFnX2NyZWF0ZUNsYXNzKEltYWdlVGFnLCBbe1xuICAgIGtleTogXCJjbG9zZVRhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZVRhZygpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhdHRyaWJ1dGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dHJpYnV0ZXMoKSB7XG4gICAgICB2YXIgYXR0ciwgb3B0aW9ucywgc3JjQXR0cmlidXRlO1xuICAgICAgYXR0ciA9IGltYWdldGFnX2dldChpbWFnZXRhZ19nZXRQcm90b3R5cGVPZihJbWFnZVRhZy5wcm90b3R5cGUpLCBcImF0dHJpYnV0ZXNcIiwgdGhpcykuY2FsbCh0aGlzKSB8fCB7fTtcbiAgICAgIG9wdGlvbnMgPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5nZXRPcHRpb24oJ2F0dHJpYnV0ZXMnKSB8fCB7fTtcbiAgICAgIHZhciBzcmNzZXRQYXJhbSA9IHRoaXMuZ2V0T3B0aW9uKCdzcmNzZXQnKSB8fCBhdHRyaWJ1dGVzLnNyY3NldDtcbiAgICAgIHZhciByZXNwb25zaXZlQXR0cmlidXRlcyA9IHt9O1xuXG4gICAgICBpZiAoaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkoc3Jjc2V0UGFyYW0pKSB7XG4gICAgICAgIHJlc3BvbnNpdmVBdHRyaWJ1dGVzLnNyY3NldCA9IHNyY3NldFBhcmFtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzcG9uc2l2ZUF0dHJpYnV0ZXMgPSBnZW5lcmF0ZUltYWdlUmVzcG9uc2l2ZUF0dHJpYnV0ZXModGhpcy5wdWJsaWNJZCwgYXR0cmlidXRlcywgc3Jjc2V0UGFyYW0sIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzRW1wdHkocmVzcG9uc2l2ZUF0dHJpYnV0ZXMpKSB7XG4gICAgICAgIGRlbGV0ZSBhdHRyLndpZHRoO1xuICAgICAgICBkZWxldGUgYXR0ci5oZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIG1lcmdlX3Jvb3RfbWVyZ2VfZGVmYXVsdCgpKGF0dHIsIHJlc3BvbnNpdmVBdHRyaWJ1dGVzKTtcbiAgICAgIHNyY0F0dHJpYnV0ZSA9IG9wdGlvbnMucmVzcG9uc2l2ZSAmJiAhb3B0aW9ucy5jbGllbnRfaGludHMgPyAnZGF0YS1zcmMnIDogJ3NyYyc7XG5cbiAgICAgIGlmIChhdHRyW3NyY0F0dHJpYnV0ZV0gPT0gbnVsbCkge1xuICAgICAgICBhdHRyW3NyY0F0dHJpYnV0ZV0gPSB1cmxfdXJsKHRoaXMucHVibGljSWQsIHRoaXMuZ2V0T3B0aW9ucygpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF0dHI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEltYWdlVGFnO1xufShodG1sdGFnKTtcblxuO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgaW1hZ2V0YWcgPSAoaW1hZ2V0YWdfSW1hZ2VUYWcpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdGFncy9zb3VyY2V0YWcuanNcbmZ1bmN0aW9uIHNvdXJjZXRhZ190eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIHNvdXJjZXRhZ190eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBzb3VyY2V0YWdfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gc291cmNldGFnX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gc291cmNldGFnX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBzb3VyY2V0YWdfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBzb3VyY2V0YWdfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIHNvdXJjZXRhZ19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBzb3VyY2V0YWdfZ2V0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgc291cmNldGFnX2dldCA9IFJlZmxlY3QuZ2V0LmJpbmQoKTsgfSBlbHNlIHsgc291cmNldGFnX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBzb3VyY2V0YWdfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gc291cmNldGFnX2dldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIHNvdXJjZXRhZ19zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gc291cmNldGFnX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gc291cmNldGFnX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIHNvdXJjZXRhZ19zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gc291cmNldGFnX3NldFByb3RvdHlwZU9mKG8sIHApIHsgc291cmNldGFnX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBzb3VyY2V0YWdfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gc291cmNldGFnX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBzb3VyY2V0YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gc291cmNldGFnX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBzb3VyY2V0YWdfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIHNvdXJjZXRhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gc291cmNldGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoc291cmNldGFnX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBzb3VyY2V0YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIHNvdXJjZXRhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBzb3VyY2V0YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gc291cmNldGFnX2dldFByb3RvdHlwZU9mKG8pIHsgc291cmNldGFnX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBzb3VyY2V0YWdfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuLyoqXG4gKiBJbWFnZSBUYWdcbiAqIERlcGVuZHMgb24gJ3RhZ3MvaHRtbHRhZycsICdjbG91ZGluYXJ5J1xuICovXG5cblxuXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBIVE1MIChET00pIEltYWdlIHRhZyB1c2luZyBDbG91ZGluYXJ5IGFzIHRoZSBzb3VyY2UuXG4gKiBAY29uc3RydWN0b3IgU291cmNlVGFnXG4gKiBAZXh0ZW5kcyBIdG1sVGFnXG4gKiBAcGFyYW0ge3N0cmluZ30gW3B1YmxpY0lkXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICovXG5cbnZhciBzb3VyY2V0YWdfU291cmNlVGFnID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSHRtbFRhZykge1xuICBzb3VyY2V0YWdfaW5oZXJpdHMoU291cmNlVGFnLCBfSHRtbFRhZyk7XG5cbiAgdmFyIF9zdXBlciA9IHNvdXJjZXRhZ19jcmVhdGVTdXBlcihTb3VyY2VUYWcpO1xuXG4gIGZ1bmN0aW9uIFNvdXJjZVRhZyhwdWJsaWNJZCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIHNvdXJjZXRhZ19jbGFzc0NhbGxDaGVjayh0aGlzLCBTb3VyY2VUYWcpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFwic291cmNlXCIsIHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgfVxuICAvKiogQG92ZXJyaWRlICovXG5cblxuICBzb3VyY2V0YWdfY3JlYXRlQ2xhc3MoU291cmNlVGFnLCBbe1xuICAgIGtleTogXCJjbG9zZVRhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZVRhZygpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhdHRyaWJ1dGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dHJpYnV0ZXMoKSB7XG4gICAgICB2YXIgc3Jjc2V0UGFyYW0gPSB0aGlzLmdldE9wdGlvbignc3Jjc2V0Jyk7XG4gICAgICB2YXIgYXR0ciA9IHNvdXJjZXRhZ19nZXQoc291cmNldGFnX2dldFByb3RvdHlwZU9mKFNvdXJjZVRhZy5wcm90b3R5cGUpLCBcImF0dHJpYnV0ZXNcIiwgdGhpcykuY2FsbCh0aGlzKSB8fCB7fTtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5nZXRPcHRpb25zKCk7XG4gICAgICBtZXJnZV9yb290X21lcmdlX2RlZmF1bHQoKShhdHRyLCBnZW5lcmF0ZUltYWdlUmVzcG9uc2l2ZUF0dHJpYnV0ZXModGhpcy5wdWJsaWNJZCwgYXR0ciwgc3Jjc2V0UGFyYW0sIG9wdGlvbnMpKTtcblxuICAgICAgaWYgKCFhdHRyLnNyY3NldCkge1xuICAgICAgICBhdHRyLnNyY3NldCA9IHVybF91cmwodGhpcy5wdWJsaWNJZCwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghYXR0ci5tZWRpYSAmJiBvcHRpb25zLm1lZGlhKSB7XG4gICAgICAgIGF0dHIubWVkaWEgPSBnZW5lcmF0ZU1lZGlhQXR0cihvcHRpb25zLm1lZGlhKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF0dHI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNvdXJjZVRhZztcbn0oaHRtbHRhZyk7XG5cbjtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNvdXJjZXRhZyA9IChzb3VyY2V0YWdfU291cmNlVGFnKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3RhZ3MvcGljdHVyZXRhZy5qc1xuZnVuY3Rpb24gcGljdHVyZXRhZ190eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIHBpY3R1cmV0YWdfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgcGljdHVyZXRhZ190eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBwaWN0dXJldGFnX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gcGljdHVyZXRhZ19kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gcGljdHVyZXRhZ19jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIHBpY3R1cmV0YWdfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIHBpY3R1cmV0YWdfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gcGljdHVyZXRhZ19nZXQoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBwaWN0dXJldGFnX2dldCA9IFJlZmxlY3QuZ2V0LmJpbmQoKTsgfSBlbHNlIHsgcGljdHVyZXRhZ19nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gcGljdHVyZXRhZ19zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogcmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBwaWN0dXJldGFnX2dldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIHBpY3R1cmV0YWdfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IHBpY3R1cmV0YWdfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBwaWN0dXJldGFnX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIHBpY3R1cmV0YWdfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIHBpY3R1cmV0YWdfc2V0UHJvdG90eXBlT2YobywgcCkgeyBwaWN0dXJldGFnX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBwaWN0dXJldGFnX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIHBpY3R1cmV0YWdfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IHBpY3R1cmV0YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gcGljdHVyZXRhZ19nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gcGljdHVyZXRhZ19nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gcGljdHVyZXRhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gcGljdHVyZXRhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKHBpY3R1cmV0YWdfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIHBpY3R1cmV0YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIHBpY3R1cmV0YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gcGljdHVyZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBwaWN0dXJldGFnX2dldFByb3RvdHlwZU9mKG8pIHsgcGljdHVyZXRhZ19nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gcGljdHVyZXRhZ19nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5cblxuXG5cblxuXG52YXIgcGljdHVyZXRhZ19QaWN0dXJlVGFnID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSHRtbFRhZykge1xuICBwaWN0dXJldGFnX2luaGVyaXRzKFBpY3R1cmVUYWcsIF9IdG1sVGFnKTtcblxuICB2YXIgX3N1cGVyID0gcGljdHVyZXRhZ19jcmVhdGVTdXBlcihQaWN0dXJlVGFnKTtcblxuICBmdW5jdGlvbiBQaWN0dXJlVGFnKHB1YmxpY0lkKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBzb3VyY2VzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBbXTtcblxuICAgIHBpY3R1cmV0YWdfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGljdHVyZVRhZyk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsICdwaWN0dXJlJywgcHVibGljSWQsIG9wdGlvbnMpO1xuICAgIF90aGlzLndpZHRoTGlzdCA9IHNvdXJjZXM7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKiBAb3ZlcnJpZGUgKi9cblxuXG4gIHBpY3R1cmV0YWdfY3JlYXRlQ2xhc3MoUGljdHVyZVRhZywgW3tcbiAgICBrZXk6IFwiY29udGVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb250ZW50KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLndpZHRoTGlzdC5tYXAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIG1pbl93aWR0aCA9IF9yZWYubWluX3dpZHRoLFxuICAgICAgICAgICAgbWF4X3dpZHRoID0gX3JlZi5tYXhfd2lkdGgsXG4gICAgICAgICAgICB0cmFuc2Zvcm1hdGlvbiA9IF9yZWYudHJhbnNmb3JtYXRpb247XG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSBfdGhpczIuZ2V0T3B0aW9ucygpO1xuXG4gICAgICAgIHZhciBzb3VyY2VUcmFuc2Zvcm1hdGlvbiA9IG5ldyBzcmNfdHJhbnNmb3JtYXRpb24ob3B0aW9ucyk7XG4gICAgICAgIHNvdXJjZVRyYW5zZm9ybWF0aW9uLmNoYWluKCkuZnJvbU9wdGlvbnModHlwZW9mIHRyYW5zZm9ybWF0aW9uID09PSAnc3RyaW5nJyA/IHtcbiAgICAgICAgICByYXdfdHJhbnNmb3JtYXRpb246IHRyYW5zZm9ybWF0aW9uXG4gICAgICAgIH0gOiB0cmFuc2Zvcm1hdGlvbik7XG4gICAgICAgIG9wdGlvbnMgPSBleHRyYWN0VXJsUGFyYW1zKG9wdGlvbnMpO1xuICAgICAgICBvcHRpb25zLm1lZGlhID0ge1xuICAgICAgICAgIG1pbl93aWR0aDogbWluX3dpZHRoLFxuICAgICAgICAgIG1heF93aWR0aDogbWF4X3dpZHRoXG4gICAgICAgIH07XG4gICAgICAgIG9wdGlvbnMudHJhbnNmb3JtYXRpb24gPSBzb3VyY2VUcmFuc2Zvcm1hdGlvbjtcbiAgICAgICAgcmV0dXJuIG5ldyBzb3VyY2V0YWcoX3RoaXMyLnB1YmxpY0lkLCBvcHRpb25zKS50b0h0bWwoKTtcbiAgICAgIH0pLmpvaW4oJycpICsgbmV3IGltYWdldGFnKHRoaXMucHVibGljSWQsIHRoaXMuZ2V0T3B0aW9ucygpKS50b0h0bWwoKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYXR0cmlidXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVzKCkge1xuICAgICAgdmFyIGF0dHIgPSBwaWN0dXJldGFnX2dldChwaWN0dXJldGFnX2dldFByb3RvdHlwZU9mKFBpY3R1cmVUYWcucHJvdG90eXBlKSwgXCJhdHRyaWJ1dGVzXCIsIHRoaXMpLmNhbGwodGhpcyk7XG5cbiAgICAgIGRlbGV0ZSBhdHRyLndpZHRoO1xuICAgICAgZGVsZXRlIGF0dHIuaGVpZ2h0O1xuICAgICAgcmV0dXJuIGF0dHI7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlVGFnKCkge1xuICAgICAgcmV0dXJuIFwiPC9cIiArIHRoaXMubmFtZSArIFwiPlwiO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQaWN0dXJlVGFnO1xufShodG1sdGFnKTtcblxuO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgcGljdHVyZXRhZyA9IChwaWN0dXJldGFnX1BpY3R1cmVUYWcpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdGFncy92aWRlb3RhZy5qc1xuZnVuY3Rpb24gdmlkZW90YWdfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiB2aWRlb3RhZ190eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCB2aWRlb3RhZ190eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiB2aWRlb3RhZ19jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIHZpZGVvdGFnX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiB2aWRlb3RhZ19jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIHZpZGVvdGFnX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSB2aWRlb3RhZ19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiB2aWRlb3RhZ19nZXQoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyB2aWRlb3RhZ19nZXQgPSBSZWZsZWN0LmdldC5iaW5kKCk7IH0gZWxzZSB7IHZpZGVvdGFnX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSB2aWRlb3RhZ19zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogcmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiB2aWRlb3RhZ19nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiB2aWRlb3RhZ19zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gdmlkZW90YWdfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiB2aWRlb3RhZ19pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSB2aWRlb3RhZ19zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gdmlkZW90YWdfc2V0UHJvdG90eXBlT2YobywgcCkgeyB2aWRlb3RhZ19zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gdmlkZW90YWdfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gdmlkZW90YWdfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IHZpZGVvdGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IHZpZGVvdGFnX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSB2aWRlb3RhZ19nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gdmlkZW90YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIHZpZGVvdGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAodmlkZW90YWdfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIHZpZGVvdGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiB2aWRlb3RhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiB2aWRlb3RhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiB2aWRlb3RhZ19nZXRQcm90b3R5cGVPZihvKSB7IHZpZGVvdGFnX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiB2aWRlb3RhZ19nZXRQcm90b3R5cGVPZihvKTsgfVxuXG4vKipcbiAqIFZpZGVvIFRhZ1xuICogRGVwZW5kcyBvbiAndGFncy9odG1sdGFnJywgJ3V0aWwnLCAnY2xvdWRpbmFyeSdcbiAqL1xuXG5cblxuXG52YXIgVklERU9fVEFHX1BBUkFNUyA9IFsnc291cmNlX3R5cGVzJywgJ3NvdXJjZV90cmFuc2Zvcm1hdGlvbicsICdmYWxsYmFja19jb250ZW50JywgJ3Bvc3RlcicsICdzb3VyY2VzJ107XG52YXIgdmlkZW90YWdfREVGQVVMVF9WSURFT19TT1VSQ0VfVFlQRVMgPSBbJ3dlYm0nLCAnbXA0JywgJ29ndiddO1xudmFyIHZpZGVvdGFnX0RFRkFVTFRfUE9TVEVSX09QVElPTlMgPSB7XG4gIGZvcm1hdDogJ2pwZycsXG4gIHJlc291cmNlX3R5cGU6ICd2aWRlbydcbn07XG4vKipcbiAqIENyZWF0ZXMgYW4gSFRNTCAoRE9NKSBWaWRlbyB0YWcgdXNpbmcgQ2xvdWRpbmFyeSBhcyB0aGUgc291cmNlLlxuICogQGNvbnN0cnVjdG9yIFZpZGVvVGFnXG4gKiBAZXh0ZW5kcyBIdG1sVGFnXG4gKiBAcGFyYW0ge3N0cmluZ30gW3B1YmxpY0lkXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICovXG5cbnZhciB2aWRlb3RhZ19WaWRlb1RhZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0h0bWxUYWcpIHtcbiAgdmlkZW90YWdfaW5oZXJpdHMoVmlkZW9UYWcsIF9IdG1sVGFnKTtcblxuICB2YXIgX3N1cGVyID0gdmlkZW90YWdfY3JlYXRlU3VwZXIoVmlkZW9UYWcpO1xuXG4gIGZ1bmN0aW9uIFZpZGVvVGFnKHB1YmxpY0lkKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgdmlkZW90YWdfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmlkZW9UYWcpO1xuXG4gICAgb3B0aW9ucyA9IGRlZmF1bHRzKHt9LCBvcHRpb25zLCBERUZBVUxUX1ZJREVPX1BBUkFNUyk7XG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFwidmlkZW9cIiwgcHVibGljSWQucmVwbGFjZSgvXFwuKG1wNHxvZ3Z8d2VibSkkLywgJycpLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSB0cmFuc2Zvcm1hdGlvbiB0byBhcHBseSBvbiBlYWNoIHNvdXJjZVxuICAgKiBAZnVuY3Rpb24gVmlkZW9UYWcjc2V0U291cmNlVHJhbnNmb3JtYXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGFuIG9iamVjdCB3aXRoIHBhaXJzIG9mIHNvdXJjZSB0eXBlIGFuZCBzb3VyY2UgdHJhbnNmb3JtYXRpb25cbiAgICogQHJldHVybnMge1ZpZGVvVGFnfSBSZXR1cm5zIHRoaXMgaW5zdGFuY2UgZm9yIGNoYWluaW5nIHB1cnBvc2VzLlxuICAgKi9cblxuXG4gIHZpZGVvdGFnX2NyZWF0ZUNsYXNzKFZpZGVvVGFnLCBbe1xuICAgIGtleTogXCJzZXRTb3VyY2VUcmFuc2Zvcm1hdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTb3VyY2VUcmFuc2Zvcm1hdGlvbih2YWx1ZSkge1xuICAgICAgdGhpcy50cmFuc2Zvcm1hdGlvbigpLnNvdXJjZVRyYW5zZm9ybWF0aW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHNvdXJjZSB0eXBlcyB0byBpbmNsdWRlIGluIHRoZSB2aWRlbyB0YWdcbiAgICAgKiBAZnVuY3Rpb24gVmlkZW9UYWcjc2V0U291cmNlVHlwZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGFuIGFycmF5IG9mIHNvdXJjZSB0eXBlc1xuICAgICAqIEByZXR1cm5zIHtWaWRlb1RhZ30gUmV0dXJucyB0aGlzIGluc3RhbmNlIGZvciBjaGFpbmluZyBwdXJwb3Nlcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFNvdXJjZVR5cGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNvdXJjZVR5cGVzKHZhbHVlKSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybWF0aW9uKCkuc291cmNlVHlwZXModmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcG9zdGVyIHRvIGJlIHVzZWQgaW4gdGhlIHZpZGVvIHRhZ1xuICAgICAqIEBmdW5jdGlvbiBWaWRlb1RhZyNzZXRQb3N0ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IHZhbHVlXG4gICAgICogLSBzdHJpbmc6IGEgVVJMIHRvIHVzZSBmb3IgdGhlIHBvc3RlclxuICAgICAqIC0gT2JqZWN0OiB0cmFuc2Zvcm1hdGlvbiBwYXJhbWV0ZXJzIHRvIGFwcGx5IHRvIHRoZSBwb3N0ZXIuIE1heSBvcHRpb25hbGx5IGluY2x1ZGUgYSBwdWJsaWNfaWQgdG8gdXNlIGluc3RlYWQgb2YgdGhlIHZpZGVvIHB1YmxpY19pZC5cbiAgICAgKiBAcmV0dXJucyB7VmlkZW9UYWd9IFJldHVybnMgdGhpcyBpbnN0YW5jZSBmb3IgY2hhaW5pbmcgcHVycG9zZXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRQb3N0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UG9zdGVyKHZhbHVlKSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybWF0aW9uKCkucG9zdGVyKHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGNvbnRlbnQgdG8gdXNlIGFzIGZhbGxiYWNrIGluIHRoZSB2aWRlbyB0YWdcbiAgICAgKiBAZnVuY3Rpb24gVmlkZW9UYWcjc2V0RmFsbGJhY2tDb250ZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gdGhlIGNvbnRlbnQgdG8gdXNlLCBpbiBIVE1MIGZvcm1hdFxuICAgICAqIEByZXR1cm5zIHtWaWRlb1RhZ30gUmV0dXJucyB0aGlzIGluc3RhbmNlIGZvciBjaGFpbmluZyBwdXJwb3Nlcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldEZhbGxiYWNrQ29udGVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGYWxsYmFja0NvbnRlbnQodmFsdWUpIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtYXRpb24oKS5mYWxsYmFja0NvbnRlbnQodmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udGVudCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBzb3VyY2VUeXBlcyA9IHRoaXMudHJhbnNmb3JtYXRpb24oKS5nZXRWYWx1ZSgnc291cmNlX3R5cGVzJyk7XG4gICAgICB2YXIgc291cmNlVHJhbnNmb3JtYXRpb24gPSB0aGlzLnRyYW5zZm9ybWF0aW9uKCkuZ2V0VmFsdWUoJ3NvdXJjZV90cmFuc2Zvcm1hdGlvbicpO1xuICAgICAgdmFyIGZhbGxiYWNrID0gdGhpcy50cmFuc2Zvcm1hdGlvbigpLmdldFZhbHVlKCdmYWxsYmFja19jb250ZW50Jyk7XG4gICAgICB2YXIgc291cmNlcyA9IHRoaXMuZ2V0T3B0aW9uKCdzb3VyY2VzJyk7XG4gICAgICB2YXIgaW5uZXJUYWdzID0gW107XG5cbiAgICAgIGlmIChpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkoc291cmNlcykgJiYgIWlzRW1wdHkoc291cmNlcykpIHtcbiAgICAgICAgaW5uZXJUYWdzID0gc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICAgIHZhciBzcmMgPSB1cmxfdXJsKF90aGlzLnB1YmxpY0lkLCBkZWZhdWx0cyh7fSwgc291cmNlLnRyYW5zZm9ybWF0aW9ucyB8fCB7fSwge1xuICAgICAgICAgICAgcmVzb3VyY2VfdHlwZTogJ3ZpZGVvJyxcbiAgICAgICAgICAgIGZvcm1hdDogc291cmNlLnR5cGVcbiAgICAgICAgICB9KSwgX3RoaXMuZ2V0T3B0aW9ucygpKTtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuY3JlYXRlU291cmNlVGFnKHNyYywgc291cmNlLnR5cGUsIHNvdXJjZS5jb2RlY3MpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0VtcHR5KHNvdXJjZVR5cGVzKSkge1xuICAgICAgICAgIHNvdXJjZVR5cGVzID0gdmlkZW90YWdfREVGQVVMVF9WSURFT19TT1VSQ0VfVFlQRVM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHNvdXJjZVR5cGVzKSkge1xuICAgICAgICAgIGlubmVyVGFncyA9IHNvdXJjZVR5cGVzLm1hcChmdW5jdGlvbiAoc3JjVHlwZSkge1xuICAgICAgICAgICAgdmFyIHNyYyA9IHVybF91cmwoX3RoaXMucHVibGljSWQsIGRlZmF1bHRzKHt9LCBzb3VyY2VUcmFuc2Zvcm1hdGlvbltzcmNUeXBlXSB8fCB7fSwge1xuICAgICAgICAgICAgICByZXNvdXJjZV90eXBlOiAndmlkZW8nLFxuICAgICAgICAgICAgICBmb3JtYXQ6IHNyY1R5cGVcbiAgICAgICAgICAgIH0pLCBfdGhpcy5nZXRPcHRpb25zKCkpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNyZWF0ZVNvdXJjZVRhZyhzcmMsIHNyY1R5cGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbm5lclRhZ3Muam9pbignJykgKyBmYWxsYmFjaztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXR0cmlidXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVzKCkge1xuICAgICAgdmFyIHNvdXJjZVR5cGVzID0gdGhpcy5nZXRPcHRpb24oJ3NvdXJjZV90eXBlcycpO1xuICAgICAgdmFyIHBvc3RlciA9IHRoaXMuZ2V0T3B0aW9uKCdwb3N0ZXInKTtcblxuICAgICAgaWYgKHBvc3RlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBvc3RlciA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfZGVmYXVsdCgpKHBvc3RlcikpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRPcHRpb25zID0gcG9zdGVyLnB1YmxpY19pZCAhPSBudWxsID8gREVGQVVMVF9JTUFHRV9QQVJBTVMgOiB2aWRlb3RhZ19ERUZBVUxUX1BPU1RFUl9PUFRJT05TO1xuICAgICAgICBwb3N0ZXIgPSB1cmxfdXJsKHBvc3Rlci5wdWJsaWNfaWQgfHwgdGhpcy5wdWJsaWNJZCwgZGVmYXVsdHMoe30sIHBvc3RlciwgZGVmYXVsdE9wdGlvbnMsIHRoaXMuZ2V0T3B0aW9ucygpKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBhdHRyID0gdmlkZW90YWdfZ2V0KHZpZGVvdGFnX2dldFByb3RvdHlwZU9mKFZpZGVvVGFnLnByb3RvdHlwZSksIFwiYXR0cmlidXRlc1wiLCB0aGlzKS5jYWxsKHRoaXMpIHx8IHt9O1xuICAgICAgYXR0ciA9IG9taXQoYXR0ciwgVklERU9fVEFHX1BBUkFNUyk7XG4gICAgICB2YXIgc291cmNlcyA9IHRoaXMuZ2V0T3B0aW9uKCdzb3VyY2VzJyk7IC8vIEluIGNhc2Ugb2YgZW1wdHkgc291cmNlVHlwZXMgLSBmYWxsYmFjayB0byBkZWZhdWx0IHNvdXJjZSB0eXBlcyBpcyB1c2VkLlxuXG4gICAgICB2YXIgaGFzU291cmNlVGFncyA9ICFpc0VtcHR5KHNvdXJjZXMpIHx8IGlzRW1wdHkoc291cmNlVHlwZXMpIHx8IGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKShzb3VyY2VUeXBlcyk7XG5cbiAgICAgIGlmICghaGFzU291cmNlVGFncykge1xuICAgICAgICBhdHRyW1wic3JjXCJdID0gdXJsX3VybCh0aGlzLnB1YmxpY0lkLCB0aGlzLmdldE9wdGlvbnMoKSwge1xuICAgICAgICAgIHJlc291cmNlX3R5cGU6ICd2aWRlbycsXG4gICAgICAgICAgZm9ybWF0OiBzb3VyY2VUeXBlc1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBvc3RlciAhPSBudWxsKSB7XG4gICAgICAgIGF0dHJbXCJwb3N0ZXJcIl0gPSBwb3N0ZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhdHRyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVTb3VyY2VUYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlU291cmNlVGFnKHNyYywgc291cmNlVHlwZSkge1xuICAgICAgdmFyIGNvZGVjcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICAgIHZhciBtaW1lVHlwZSA9IG51bGw7XG5cbiAgICAgIGlmICghaXNFbXB0eShzb3VyY2VUeXBlKSkge1xuICAgICAgICB2YXIgdmlkZW9UeXBlID0gc291cmNlVHlwZSA9PT0gJ29ndicgPyAnb2dnJyA6IHNvdXJjZVR5cGU7XG4gICAgICAgIG1pbWVUeXBlID0gJ3ZpZGVvLycgKyB2aWRlb1R5cGU7XG5cbiAgICAgICAgaWYgKCFpc0VtcHR5KGNvZGVjcykpIHtcbiAgICAgICAgICB2YXIgY29kZWNzU3RyID0gaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKGNvZGVjcykgPyBjb2RlY3Muam9pbignLCAnKSA6IGNvZGVjcztcbiAgICAgICAgICBtaW1lVHlwZSArPSAnOyBjb2RlY3M9JyArIGNvZGVjc1N0cjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCI8c291cmNlIFwiICsgdGhpcy5odG1sQXR0cnMoe1xuICAgICAgICBzcmM6IHNyYyxcbiAgICAgICAgdHlwZTogbWltZVR5cGVcbiAgICAgIH0pICsgXCI+XCI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFZpZGVvVGFnO1xufShodG1sdGFnKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdmlkZW90YWcgPSAodmlkZW90YWdfVmlkZW9UYWcpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdGFncy9jbGllbnRoaW50c21ldGF0YWcuanNcbmZ1bmN0aW9uIGNsaWVudGhpbnRzbWV0YXRhZ190eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIGNsaWVudGhpbnRzbWV0YXRhZ190eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBjbGllbnRoaW50c21ldGF0YWdfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gY2xpZW50aGludHNtZXRhdGFnX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gY2xpZW50aGludHNtZXRhdGFnX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBjbGllbnRoaW50c21ldGF0YWdfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBjbGllbnRoaW50c21ldGF0YWdfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGNsaWVudGhpbnRzbWV0YXRhZ19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBjbGllbnRoaW50c21ldGF0YWdfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgY2xpZW50aGludHNtZXRhdGFnX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBjbGllbnRoaW50c21ldGF0YWdfc2V0UHJvdG90eXBlT2YobywgcCkgeyBjbGllbnRoaW50c21ldGF0YWdfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIGNsaWVudGhpbnRzbWV0YXRhZ19zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBjbGllbnRoaW50c21ldGF0YWdfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGNsaWVudGhpbnRzbWV0YXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBjbGllbnRoaW50c21ldGF0YWdfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IGNsaWVudGhpbnRzbWV0YXRhZ19nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gY2xpZW50aGludHNtZXRhdGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBjbGllbnRoaW50c21ldGF0YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChjbGllbnRoaW50c21ldGF0YWdfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIGNsaWVudGhpbnRzbWV0YXRhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gY2xpZW50aGludHNtZXRhdGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIGNsaWVudGhpbnRzbWV0YXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBjbGllbnRoaW50c21ldGF0YWdfZ2V0UHJvdG90eXBlT2YobykgeyBjbGllbnRoaW50c21ldGF0YWdfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIGNsaWVudGhpbnRzbWV0YXRhZ19nZXRQcm90b3R5cGVPZihvKTsgfVxuXG4vKipcbiAqIEltYWdlIFRhZ1xuICogRGVwZW5kcyBvbiAndGFncy9odG1sdGFnJywgJ2Nsb3VkaW5hcnknXG4gKi9cblxuXG4vKipcbiAqIENyZWF0ZXMgYW4gSFRNTCAoRE9NKSBNZXRhIHRhZyB0aGF0IGVuYWJsZXMgQ2xpZW50LUhpbnRzIGZvciB0aGUgSFRNTCBwYWdlLiA8YnIvPlxuICogIFNlZVxuICogIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vcmVzcG9uc2l2ZV9pbWFnZXMjYXV0b21hdGluZ19yZXNwb25zaXZlX2ltYWdlc193aXRoX2NsaWVudF9oaW50c1wiXG4gKiAgdGFyZ2V0PVwiX25ld1wiPkF1dG9tYXRpbmcgcmVzcG9uc2l2ZSBpbWFnZXMgd2l0aCBDbGllbnQgSGludHM8L2E+IGZvciBtb3JlIGRldGFpbHMuXG4gKiBAY29uc3RydWN0b3IgQ2xpZW50SGludHNNZXRhVGFnXG4gKiBAZXh0ZW5kcyBIdG1sVGFnXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQGV4YW1wbGVcbiAqIHRhZyA9IG5ldyBDbGllbnRIaW50c01ldGFUYWcoKVxuICogLy9yZXR1cm5zOiA8bWV0YSBodHRwLWVxdWl2PVwiQWNjZXB0LUNIXCIgY29udGVudD1cIkRQUiwgVmlld3BvcnQtV2lkdGgsIFdpZHRoXCI+XG4gKi9cblxudmFyIGNsaWVudGhpbnRzbWV0YXRhZ19DbGllbnRIaW50c01ldGFUYWcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9IdG1sVGFnKSB7XG4gIGNsaWVudGhpbnRzbWV0YXRhZ19pbmhlcml0cyhDbGllbnRIaW50c01ldGFUYWcsIF9IdG1sVGFnKTtcblxuICB2YXIgX3N1cGVyID0gY2xpZW50aGludHNtZXRhdGFnX2NyZWF0ZVN1cGVyKENsaWVudEhpbnRzTWV0YVRhZyk7XG5cbiAgZnVuY3Rpb24gQ2xpZW50SGludHNNZXRhVGFnKG9wdGlvbnMpIHtcbiAgICBjbGllbnRoaW50c21ldGF0YWdfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2xpZW50SGludHNNZXRhVGFnKTtcblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCAnbWV0YScsIHZvaWQgMCwgYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKSh7XG4gICAgICBcImh0dHAtZXF1aXZcIjogXCJBY2NlcHQtQ0hcIixcbiAgICAgIGNvbnRlbnQ6IFwiRFBSLCBWaWV3cG9ydC1XaWR0aCwgV2lkdGhcIlxuICAgIH0sIG9wdGlvbnMpKTtcbiAgfVxuICAvKiogQG92ZXJyaWRlICovXG5cblxuICBjbGllbnRoaW50c21ldGF0YWdfY3JlYXRlQ2xhc3MoQ2xpZW50SGludHNNZXRhVGFnLCBbe1xuICAgIGtleTogXCJjbG9zZVRhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZVRhZygpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDbGllbnRIaW50c01ldGFUYWc7XG59KGh0bWx0YWcpO1xuXG47XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjbGllbnRoaW50c21ldGF0YWcgPSAoY2xpZW50aGludHNtZXRhdGFnX0NsaWVudEhpbnRzTWV0YVRhZyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL3BhcnNlL25vcm1hbGl6ZVRvQXJyYXkuanNcbmZ1bmN0aW9uIG5vcm1hbGl6ZVRvQXJyYXlfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBub3JtYWxpemVUb0FycmF5X2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgbm9ybWFsaXplVG9BcnJheV9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub3JtYWxpemVUb0FycmF5X3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9ybWFsaXplVG9BcnJheV9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRvQXJyYXlfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRvQXJyYXlfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBub3JtYWxpemVUb0FycmF5X2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBub3JtYWxpemVUb0FycmF5X2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBub3JtYWxpemVUb0FycmF5X2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRvQXJyYXlfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBub3JtYWxpemVUb0FycmF5X2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiBub3JtYWxpemVUb0FycmF5X2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cblxuLyoqXG4gKiBAZGVzYyBub3JtYWxpemUgZWxlbWVudHMsIHN1cHBvcnQgYSBzaW5nbGUgZWxlbWVudCwgYXJyYXkgb3Igbm9kZWxpc3QsIGFsd2F5cyBvdXRwdXRzIGFycmF5XG4gKiBAcGFyYW0gZWxlbWVudHM8SFRNTEVsZW1lbnRbXT5cbiAqIEByZXR1cm5zIHtbXX1cbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVUb0FycmF5KGVsZW1lbnRzKSB7XG4gIGlmIChpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkoZWxlbWVudHMpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnRzO1xuICB9IGVsc2UgaWYgKGVsZW1lbnRzLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiTm9kZUxpc3RcIikge1xuICAgIHJldHVybiBub3JtYWxpemVUb0FycmF5X3RvQ29uc3VtYWJsZUFycmF5KGVsZW1lbnRzKTsgLy8gZW5zdXJlIGFuIGFycmF5IGlzIGFsd2F5cyByZXR1cm5lZCwgZXZlbiBpZiBub2RlbGlzdFxuICB9IGVsc2UgaWYgKGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKGVsZW1lbnRzKSkge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGVsZW1lbnRzKSwgMCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtlbGVtZW50c107XG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvZmVhdHVyZXMvdHJhbnNwYXJlbnRWaWRlby9tb3VudENsb3VkaW5hcnlWaWRlb1RhZy5qc1xuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBodG1sRWxDb250YWluZXJcbiAqIEBwYXJhbSB7b2JqZWN0fSBjbEluc3RhbmNlIGNsb3VkaW5hcnkgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBUcmFuc2Zvcm1hdGlvbk9wdGlvbnNcbiAqIEByZXR1cm5zIFByb21pc2U8SFRNTEVsZW1lbnQ+XG4gKi9cbmZ1bmN0aW9uIG1vdW50Q2xvdWRpbmFyeVZpZGVvVGFnKGh0bWxFbENvbnRhaW5lciwgY2xJbnN0YW5jZSwgcHVibGljSWQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBodG1sRWxDb250YWluZXIuaW5uZXJIVE1MID0gY2xJbnN0YW5jZS52aWRlb1RhZyhwdWJsaWNJZCwgb3B0aW9ucykudG9IdG1sKCk7IC8vIEFsbCB2aWRlb3MgdW5kZXIgdGhlIGh0bWwgY29udGFpbmVyIG11c3QgaGF2ZSBhIHdpZHRoIG9mIDEwMCUsIG9yIHRoZXkgbWlnaHQgb3ZlcmZsb3cgZnJvbSB0aGUgY29udGFpbmVyXG5cbiAgICB2YXIgY2xvdWRpbmFyeVZpZGVvRWxlbWVudCA9IGh0bWxFbENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuY2xkLXRyYW5zcGFyZW50LXZpZGVvJyk7XG4gICAgY2xvdWRpbmFyeVZpZGVvRWxlbWVudC5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICByZXNvbHZlKGh0bWxFbENvbnRhaW5lcik7XG4gIH0pO1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0cmFuc3BhcmVudFZpZGVvX21vdW50Q2xvdWRpbmFyeVZpZGVvVGFnID0gKG1vdW50Q2xvdWRpbmFyeVZpZGVvVGFnKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvdHJhbnNmb3JtYXRpb25zL2FkZEZsYWcuanNcbi8qKlxuICogQGRlc2NyaXB0aW9uIC0gRnVuY3Rpb24gd2lsbCBwdXNoIGEgZmxhZyB0byBpbmNvbWluZyBvcHRpb25zXG4gKiBAcGFyYW0ge3t0cmFuc2Zvcm1hdGlvbn0gfCB7Li4udHJhbnNmb3JtYXRpb259fSBvcHRpb25zIC0gVGhlc2Ugb3B0aW9ucyBhcmUgdGhlIHNhbWUgb3B0aW9ucyBwcm92aWRlZCB0byBhbGwgb3VyIFNESyBtZXRob2RzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFdlIGV4cGVjdCBvcHRpb25zIHRvIGVpdGhlciBiZSB0aGUgdHJhbnNmb3JtYXRpb24gaXRzZWxmLCBvciBhbiBvYmplY3QgY29udGFpbmluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICBhbiBhcnJheSBvZiB0cmFuc2Zvcm1hdGlvbnNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmxhZ1xuICogQHJldHVybnMgdGhlIG11dGF0ZWQgb3B0aW9ucyBvYmplY3RcbiAqL1xuZnVuY3Rpb24gYWRkRmxhZ1RvT3B0aW9ucyhvcHRpb25zLCBmbGFnKSB7XG4gIC8vIERvIHdlIGhhdmUgdHJhbnNmb3JtYXRpb25cbiAgaWYgKG9wdGlvbnMudHJhbnNmb3JtYXRpb24pIHtcbiAgICBvcHRpb25zLnRyYW5zZm9ybWF0aW9uLnB1c2goe1xuICAgICAgZmxhZ3M6IFtmbGFnXVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG5vIHRyYW5zZm9ybWF0aW9uXG4gICAgLy8gZW5zdXJlIHRoZSBmbGFncyBhcmUgZXh0ZW5kZWRcbiAgICBpZiAoIW9wdGlvbnMuZmxhZ3MpIHtcbiAgICAgIG9wdGlvbnMuZmxhZ3MgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmxhZ3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHRpb25zLmZsYWdzID0gW29wdGlvbnMuZmxhZ3NdO1xuICAgIH1cblxuICAgIG9wdGlvbnMuZmxhZ3MucHVzaChmbGFnKTtcbiAgfVxufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBhZGRGbGFnID0gKGFkZEZsYWdUb09wdGlvbnMpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9mZWF0dXJlcy90cmFuc3BhcmVudFZpZGVvL2VuZm9yY2VPcHRpb25zRm9yVHJhbnNwYXJlbnRWaWRlby5qc1xuXG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIC0gRW5mb3JjZSBvcHRpb24gc3RydWN0dXJlLCBzZXRzIGRlZmF1bHRzIGFuZCBlbnN1cmVzIGFscGhhIGZsYWcgZXhpc3RzXG4gKiBAcGFyYW0gb3B0aW9ucyB7VHJhbnNmb3JtYXRpb25PcHRpb25zfVxuICovXG5cbmZ1bmN0aW9uIGVuZm9yY2VPcHRpb25zRm9yVHJhbnNwYXJlbnRWaWRlbyhvcHRpb25zKSB7XG4gIG9wdGlvbnMuYXV0b3BsYXkgPSB0cnVlO1xuICBvcHRpb25zLm11dGVkID0gdHJ1ZTtcbiAgb3B0aW9ucy5jb250cm9scyA9IGZhbHNlO1xuICBvcHRpb25zLm1heF90aW1lb3V0X21zID0gb3B0aW9ucy5tYXhfdGltZW91dF9tcyB8fCBERUZBVUxUX1RJTUVPVVRfTVM7XG4gIG9wdGlvbnNbXCJjbGFzc1wiXSA9IG9wdGlvbnNbXCJjbGFzc1wiXSB8fCAnJztcbiAgb3B0aW9uc1tcImNsYXNzXCJdICs9ICcgY2xkLXRyYW5zcGFyZW50LXZpZGVvJztcbiAgb3B0aW9ucy5leHRlcm5hbExpYnJhcmllcyA9IG9wdGlvbnMuZXh0ZXJuYWxMaWJyYXJpZXMgfHwge307XG5cbiAgaWYgKCFvcHRpb25zLmV4dGVybmFsTGlicmFyaWVzLnNlZVRocnUpIHtcbiAgICBvcHRpb25zLmV4dGVybmFsTGlicmFyaWVzLnNlZVRocnUgPSBERUZBVUxUX0VYVEVSTkFMX0xJQlJBUklFUy5zZWVUaHJ1O1xuICB9IC8vIGVuc3VyZSB0aGVyZSdzIGFuIGFscGhhIHRyYW5zZm9ybWF0aW9uIHByZXNlbnRcbiAgLy8gdGhpcyBpcyBhIG5vbiBkb2N1bWVudGVkIGludGVybmFsIGZsYWdcblxuXG4gIGFkZEZsYWcob3B0aW9ucywgJ2FscGhhJyk7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRyYW5zcGFyZW50VmlkZW9fZW5mb3JjZU9wdGlvbnNGb3JUcmFuc3BhcmVudFZpZGVvID0gKGVuZm9yY2VPcHRpb25zRm9yVHJhbnNwYXJlbnRWaWRlbyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL3hoci9sb2FkU2NyaXB0LmpzXG4vKipcbiAqIEBkZXNjcmlwdGlvbiAtIEdpdmVuIGEgc3RyaW5nIFVSTCwgdGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgdGhlIHNjcmlwdCBhbmQgcmVzb2x2ZSB0aGUgcHJvbWlzZS5cbiAqICAgICAgICAgICAgICAgIFRoZSBmdW5jdGlvbiBkb2Vzbid0IHJlc29sdmUgYW55IHZhbHVlLFxuICogICAgICAgICAgICAgICAgdGhpcyBpcyBub3QgYSBVTUQgbG9hZGVyIHdoZXJlIHlvdSBjYW4gZ2V0IHlvdXIgbGlicmFyeSBuYW1lIGJhY2suXG4gKiBAcGFyYW0gc2NyaXB0VVJMIHtzdHJpbmd9XG4gKiBAcGFyYW0ge251bWJlcn0gbWF4X3RpbWVvdXRfbXMgLSBUaW1lIHRvIGVsYXBzZSBiZWZvcmUgcHJvbWlzZSBpcyByZWplY3RlZFxuICogQHBhcmFtIGlzQWxyZWFkeUxvYWRlZCB7Ym9vbGVhbn0gaWYgdHJ1ZSwgdGhlIGxvYWRTY3JpcHQgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgaXMgdXNlZCBmb3IgbXVsdGlwbGUgaW52b2NhdGlvbnMgLSBwcmV2ZW50cyB0aGUgc2NyaXB0IGZyb20gYmVpbmcgbG9hZGVkIG11bHRpcGxlIHRpbWVzXG4gKiBAcmV0dXJuIHtQcm9taXNlPGFueSB8IHtzdGF0dXM6c3RyaW5nLCBtZXNzYWdlOnN0cmluZ30+fVxuICovXG5mdW5jdGlvbiBsb2FkU2NyaXB0KHNjcmlwdFVSTCwgbWF4X3RpbWVvdXRfbXMsIGlzQWxyZWFkeUxvYWRlZCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGlmIChpc0FscmVhZHlMb2FkZWQpIHtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNjcmlwdFRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgc2NyaXB0VGFnLnNyYyA9IHNjcmlwdFVSTDtcbiAgICAgIHZhciB0aW1lcklEID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICAgIG1lc3NhZ2U6IFwiVGltZW91dCBsb2FkaW5nIHNjcmlwdCBcIi5jb25jYXQoc2NyaXB0VVJMKVxuICAgICAgICB9KTtcbiAgICAgIH0sIG1heF90aW1lb3V0X21zKTsgLy8gMTAgc2Vjb25kcyBmb3IgdGltZW91dFxuXG4gICAgICBzY3JpcHRUYWcub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySUQpOyAvLyBjbGVhciB0aW1lb3V0IHJlamVjdCBlcnJvclxuXG4gICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICAgIG1lc3NhZ2U6IFwiRXJyb3IgbG9hZGluZyBcIi5jb25jYXQoc2NyaXB0VVJMKVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHNjcmlwdFRhZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklEKTsgLy8gY2xlYXIgdGltZW91dCByZWplY3QgZXJyb3JcblxuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9O1xuXG4gICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdFRhZyk7XG4gICAgfVxuICB9KTtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgeGhyX2xvYWRTY3JpcHQgPSAobG9hZFNjcmlwdCk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL3hoci9nZXRCbG9iRnJvbVVSTC5qc1xuLyoqXG4gKiBSZWplY3Qgb24gdGltZW91dFxuICogQHBhcmFtIG1heFRpbWVvdXRNU1xuICogQHBhcmFtIHJlamVjdFxuICogQHJldHVybnMge251bWJlcn0gdGltZXJJRFxuICovXG5mdW5jdGlvbiByZWplY3RPblRpbWVvdXQobWF4VGltZW91dE1TLCByZWplY3QpIHtcbiAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHJlamVjdCh7XG4gICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICBtZXNzYWdlOiAnVGltZW91dCBsb2FkaW5nIEJsb2IgVVJMJ1xuICAgIH0pO1xuICB9LCBtYXhUaW1lb3V0TVMpO1xufVxuLyoqXG4gKiBAZGVzY3JpcHRpb24gQ29udmVydHMgYSBVUkwgdG8gYSBCTE9CIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHVybFRvTG9hZFxuICogQHBhcmFtIHtudW1iZXJ9IG1heF90aW1lb3V0X21zIC0gVGltZSB0byBlbGFwc2UgYmVmb3JlIHByb21pc2UgaXMgcmVqZWN0ZWRcbiAqIEByZXR1cm4ge1Byb21pc2U8e1xuICogICBzdGF0dXM6ICdzdWNjZXNzJyB8ICdlcnJvcidcbiAqICAgbWVzc2FnZT86IHN0cmluZyxcbiAqICAgIHBheWxvYWQ6IHtcbiAqICAgICAgdXJsOiBzdHJpbmdcbiAqICAgIH1cbiAqIH0+fVxuICovXG5cblxuZnVuY3Rpb24gZ2V0QmxvYkZyb21VUkwodXJsVG9Mb2FkLCBtYXhUaW1lb3V0TVMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgdGltZXJJRCA9IHJlamVjdE9uVGltZW91dChtYXhUaW1lb3V0TVMsIHJlamVjdCk7IC8vIElmIGZldGNoIGV4aXN0cywgdXNlIGl0IHRvIGZldGNoIGJsb2IsIG90aGVyd2lzZSB1c2UgWEhSLlxuICAgIC8vIFhIUiBjYXVzZXMgaXNzdWVzIG9uIHNhZmFyaSAxNC4xIHNvIHdlIHByZWZlciBmZXRjaFxuXG4gICAgdmFyIGZldGNoQmxvYiA9IHR5cGVvZiBmZXRjaCAhPT0gJ3VuZGVmaW5lZCcgJiYgZmV0Y2ggPyBsb2FkVXJsVXNpbmdGZXRjaCA6IGxvYWRVcmxVc2luZ1hocjtcbiAgICBmZXRjaEJsb2IodXJsVG9Mb2FkKS50aGVuKGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICByZXNvbHZlKHtcbiAgICAgICAgc3RhdHVzOiAnc3VjY2VzcycsXG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICBibG9iVVJMOiBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge1xuICAgICAgcmVqZWN0KHtcbiAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICBtZXNzYWdlOiAnRXJyb3IgbG9hZGluZyBCbG9iIFVSTCdcbiAgICAgIH0pO1xuICAgIH0pW1wiZmluYWxseVwiXShmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBDbGVhciB0aGUgdGltZW91dCB0aW1lciBvbiBmYWlsIG9yIHN1Y2Nlc3MuXG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJRCk7XG4gICAgfSk7XG4gIH0pO1xufVxuLyoqXG4gKiBVc2UgZmV0Y2ggZnVuY3Rpb24gdG8gZmV0Y2ggZmlsZVxuICogQHBhcmFtIHVybFRvTG9hZFxuICogQHJldHVybnMge1Byb21pc2U8dW5rbm93bj59XG4gKi9cblxuXG5mdW5jdGlvbiBsb2FkVXJsVXNpbmdGZXRjaCh1cmxUb0xvYWQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmZXRjaCh1cmxUb0xvYWQpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICByZXNwb25zZS5ibG9iKCkudGhlbihmdW5jdGlvbiAoYmxvYikge1xuICAgICAgICByZXNvbHZlKGJsb2IpO1xuICAgICAgfSk7XG4gICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoKSB7XG4gICAgICByZWplY3QoJ2Vycm9yJyk7XG4gICAgfSk7XG4gIH0pO1xufVxuLyoqXG4gKiBVc2UgWEhSIHRvIGZldGNoIGZpbGVcbiAqIEBwYXJhbSB1cmxUb0xvYWRcbiAqIEByZXR1cm5zIHtQcm9taXNlPHVua25vd24+fVxuICovXG5cblxuZnVuY3Rpb24gbG9hZFVybFVzaW5nWGhyKHVybFRvTG9hZCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuXG4gICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgcmVzb2x2ZSh4aHIucmVzcG9uc2UpO1xuICAgIH07XG5cbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlamVjdCgnZXJyb3InKTtcbiAgICB9O1xuXG4gICAgeGhyLm9wZW4oJ0dFVCcsIHVybFRvTG9hZCwgdHJ1ZSk7XG4gICAgeGhyLnNlbmQoKTtcbiAgfSk7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHhocl9nZXRCbG9iRnJvbVVSTCA9IChnZXRCbG9iRnJvbVVSTCk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL2ZlYXR1cmVzL3RyYW5zcGFyZW50VmlkZW8vY3JlYXRlSGlkZGVuVmlkZW9UYWcuanNcbi8qKlxuICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBoaWRkZW4gSFRNTFZpZGVvRWxlbWVudCB3aXRoIHRoZSBzcGVjaWZpZWQgdmlkZW9PcHRpb25zXG4gKiBAcGFyYW0ge3thdXRvcGxheSwgcGxheXNpbmxpbmUsIGxvb3AsIG11dGVkLCBwb3N0ZXIsIGJsb2JVUkwsIHZpZGVvVVJMIH19IHZpZGVvT3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSB2aWRlb09wdGlvbnMuYXV0b3BsYXkgLSBhdXRvcGxheXMgdGhlIHZpZGVvIGlmIHRydWVcbiAqIEBwYXJhbSB7c3RyaW5nfSB2aWRlb09wdGlvbnMuYmxvYlVSTCAtIHRoZSBibG9iVVJMIHRvIHNldCBhcyB2aWRlby5zcmNcbiAqIEBwYXJhbSB7c3RyaW5nfSB2aWRlb09wdGlvbnMudmlkZW9VUkwgLSB0aGUgb3JpZ2luYWwgdmlkZW9VUkwgdGhlIHVzZXIgY3JlYXRlZCAod2l0aCB0cmFuc2Zvcm1hdGlvbnMpXG4gKiBAcmV0dXJuIHtIVE1MVmlkZW9FbGVtZW50fVxuICovXG5mdW5jdGlvbiBjcmVhdGVIaWRkZW5WaWRlb1RhZyh2aWRlb09wdGlvbnMpIHtcbiAgdmFyIGF1dG9wbGF5ID0gdmlkZW9PcHRpb25zLmF1dG9wbGF5LFxuICAgICAgcGxheXNpbmxpbmUgPSB2aWRlb09wdGlvbnMucGxheXNpbmxpbmUsXG4gICAgICBsb29wID0gdmlkZW9PcHRpb25zLmxvb3AsXG4gICAgICBtdXRlZCA9IHZpZGVvT3B0aW9ucy5tdXRlZCxcbiAgICAgIHBvc3RlciA9IHZpZGVvT3B0aW9ucy5wb3N0ZXIsXG4gICAgICBibG9iVVJMID0gdmlkZW9PcHRpb25zLmJsb2JVUkwsXG4gICAgICB2aWRlb1VSTCA9IHZpZGVvT3B0aW9ucy52aWRlb1VSTDtcbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgZWwuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICBlbC5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIGVsLnggPSAwO1xuICBlbC55ID0gMDtcbiAgZWwuc3JjID0gYmxvYlVSTDtcbiAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLXZpZGVvLXVybCcsIHZpZGVvVVJMKTsgLy8gZm9yIGRlYnVnZ2luZy90ZXN0aW5nXG5cbiAgYXV0b3BsYXkgJiYgZWwuc2V0QXR0cmlidXRlKCdhdXRvcGxheScsIGF1dG9wbGF5KTtcbiAgcGxheXNpbmxpbmUgJiYgZWwuc2V0QXR0cmlidXRlKCdwbGF5c2lubGluZScsIHBsYXlzaW5saW5lKTtcbiAgbG9vcCAmJiBlbC5zZXRBdHRyaWJ1dGUoJ2xvb3AnLCBsb29wKTtcbiAgbXV0ZWQgJiYgZWwuc2V0QXR0cmlidXRlKCdtdXRlZCcsIG11dGVkKTtcbiAgbXV0ZWQgJiYgKGVsLm11dGVkID0gbXV0ZWQpOyAvLyB0aGlzIGlzIGFsc28gbmVlZGVkIGZvciBhdXRvcGxheSwgb24gdG9wIG9mIHNldEF0dHJpYnV0ZVxuXG4gIHBvc3RlciAmJiBlbC5zZXRBdHRyaWJ1dGUoJ3Bvc3RlcicsIHBvc3Rlcik7IC8vIEZyZWUgbWVtb3J5IGF0IHRoZSBlbmQgb2YgdGhlIGZpbGUgbG9hZGluZy5cblxuICBlbC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgVVJMLnJldm9rZU9iamVjdFVSTChibG9iVVJMKTtcbiAgfTtcblxuICByZXR1cm4gZWw7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRyYW5zcGFyZW50VmlkZW9fY3JlYXRlSGlkZGVuVmlkZW9UYWcgPSAoY3JlYXRlSGlkZGVuVmlkZW9UYWcpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9mZWF0dXJlcy90cmFuc3BhcmVudFZpZGVvL2luc3RhbnRpYXRlU2VlVGhydS5qc1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBjcmVhdGVzIGEgbmV3IGluc3RhbmMgZW9mIHNlZVRocnUgKHNlZVRocnUuY3JlYXRlKCkpIGFuZCByZXR1cm5zIGEgcHJvbWlzZSBvZiB0aGUgc2VlVGhydSBpbnN0YW5jZVxuICogQHBhcmFtIHtIVE1MVmlkZW9FbGVtZW50fSB2aWRlb0VsZW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhfdGltZW91dF9tcyAtIFRpbWUgdG8gZWxhcHNlIGJlZm9yZSBwcm9taXNlIGlzIHJlamVjdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gY3VzdG9tQ2xhc3MgLSBBIGNsYXNzbmFtZSB0byBiZSBhZGRlZCB0byB0aGUgY2FudmFzIGVsZW1lbnQgY3JlYXRlZCBieSBzZWVUaHJ1XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGF1dG9QbGF5XG4gKiBAcmV0dXJuIHtQcm9taXNlPGFueT59IFNlZVRocnUgaW5zdGFuY2Ugb3IgcmVqZWN0aW9uIGVycm9yXG4gKi9cbmZ1bmN0aW9uIGluc3RhbnRpYXRlU2VlVGhydSh2aWRlb0VsZW1lbnQsIG1heF90aW1lb3V0X21zLCBjdXN0b21DbGFzcywgYXV0b1BsYXkpIHtcbiAgdmFyIF93aW5kb3cgPSB3aW5kb3csXG4gICAgICBzZWVUaHJ1ID0gX3dpbmRvdy5zZWVUaHJ1LFxuICAgICAgc2V0VGltZW91dCA9IF93aW5kb3cuc2V0VGltZW91dCxcbiAgICAgIGNsZWFyVGltZW91dCA9IF93aW5kb3cuY2xlYXJUaW1lb3V0O1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciB0aW1lcklEID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByZWplY3Qoe1xuICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgIG1lc3NhZ2U6ICdUaW1lb3V0IGluc3RhbnRpYXRpbmcgc2VlVGhydSBpbnN0YW5jZSdcbiAgICAgIH0pO1xuICAgIH0sIG1heF90aW1lb3V0X21zKTtcblxuICAgIGlmIChzZWVUaHJ1KSB7XG4gICAgICB2YXIgc2VlVGhydUluc3RhbmNlID0gc2VlVGhydS5jcmVhdGUodmlkZW9FbGVtZW50KS5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGNsZWFyIHRpbWVvdXQgcmVqZWN0IGVycm9yXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklEKTsgLy8gZm9yY2UgY29udGFpbmVyIHdpZHRoLCBlbHNlIHRoZSBjYW52YXMgY2FuIG92ZXJmbG93IG91dFxuXG4gICAgICAgIHZhciBjYW52YXNFbGVtZW50ID0gc2VlVGhydUluc3RhbmNlLmdldENhbnZhcygpO1xuICAgICAgICBjYW52YXNFbGVtZW50LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICBjYW52YXNFbGVtZW50LmNsYXNzTmFtZSArPSAnICcgKyBjdXN0b21DbGFzczsgLy8gc3RhcnQgdGhlIHZpZGVvIGlmIGF1dG9wbGF5IGlzIHNldFxuXG4gICAgICAgIGlmIChhdXRvUGxheSkge1xuICAgICAgICAgIHNlZVRocnVJbnN0YW5jZS5wbGF5KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKHNlZVRocnVJbnN0YW5jZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVqZWN0KHtcbiAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICBtZXNzYWdlOiAnRXJyb3IgaW5zdGFudGlhdGluZyBzZWVUaHJ1IGluc3RhbmNlJ1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdHJhbnNwYXJlbnRWaWRlb19pbnN0YW50aWF0ZVNlZVRocnUgPSAoaW5zdGFudGlhdGVTZWVUaHJ1KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvZmVhdHVyZXMvdHJhbnNwYXJlbnRWaWRlby9tb3VudFNlZVRocnVDYW52YXNUYWcuanNcblxuXG5cblxuLyoqXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaHRtbEVsQ29udGFpbmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gdmlkZW9VUkxcbiAqIEBwYXJhbSB7VHJhbnNmb3JtYXRpb25PcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJuIHtQcm9taXNlPGFueT59XG4gKi9cblxuZnVuY3Rpb24gbW91bnRTZWVUaHJ1Q2FudmFzVGFnKGh0bWxFbENvbnRhaW5lciwgdmlkZW9VUkwsIG9wdGlvbnMpIHtcbiAgdmFyIHBvc3RlciA9IG9wdGlvbnMucG9zdGVyLFxuICAgICAgYXV0b3BsYXkgPSBvcHRpb25zLmF1dG9wbGF5LFxuICAgICAgcGxheXNpbmxpbmUgPSBvcHRpb25zLnBsYXlzaW5saW5lLFxuICAgICAgbG9vcCA9IG9wdGlvbnMubG9vcCxcbiAgICAgIG11dGVkID0gb3B0aW9ucy5tdXRlZDtcbiAgdmlkZW9VUkwgPSB2aWRlb1VSTCArICcubXA0JzsgLy8gc2VlVGhydSBhbHdheXMgdXNlcyBtcDRcblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHhocl9sb2FkU2NyaXB0KG9wdGlvbnMuZXh0ZXJuYWxMaWJyYXJpZXMuc2VlVGhydSwgb3B0aW9ucy5tYXhfdGltZW91dF9tcywgd2luZG93LnNlZVRocnUpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgeGhyX2dldEJsb2JGcm9tVVJMKHZpZGVvVVJMLCBvcHRpb25zLm1heF90aW1lb3V0X21zKS50aGVuKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBwYXlsb2FkID0gX3JlZi5wYXlsb2FkO1xuICAgICAgICB2YXIgdmlkZW9FbGVtZW50ID0gdHJhbnNwYXJlbnRWaWRlb19jcmVhdGVIaWRkZW5WaWRlb1RhZyh7XG4gICAgICAgICAgYmxvYlVSTDogcGF5bG9hZC5ibG9iVVJMLFxuICAgICAgICAgIHZpZGVvVVJMOiB2aWRlb1VSTCxcbiAgICAgICAgICAvLyBmb3IgZGVidWdnaW5nL3Rlc3RpbmdcbiAgICAgICAgICBwb3N0ZXI6IHBvc3RlcixcbiAgICAgICAgICBhdXRvcGxheTogYXV0b3BsYXksXG4gICAgICAgICAgcGxheXNpbmxpbmU6IHBsYXlzaW5saW5lLFxuICAgICAgICAgIGxvb3A6IGxvb3AsXG4gICAgICAgICAgbXV0ZWQ6IG11dGVkXG4gICAgICAgIH0pO1xuICAgICAgICBodG1sRWxDb250YWluZXIuYXBwZW5kQ2hpbGQodmlkZW9FbGVtZW50KTtcbiAgICAgICAgdHJhbnNwYXJlbnRWaWRlb19pbnN0YW50aWF0ZVNlZVRocnUodmlkZW9FbGVtZW50LCBvcHRpb25zLm1heF90aW1lb3V0X21zLCBvcHRpb25zW1wiY2xhc3NcIl0sIG9wdGlvbnMuYXV0b3BsYXkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlc29sdmUoaHRtbEVsQ29udGFpbmVyKTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0pOyAvLyBjYXRjaCBmb3IgZ2V0QmxvYkZyb21VUkwoKVxuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgdmFyIHN0YXR1cyA9IF9yZWYyLnN0YXR1cyxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBfcmVmMi5tZXNzYWdlO1xuICAgICAgICByZWplY3Qoe1xuICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICB9KTsgLy8gY2F0Y2ggZm9yIGxvYWRTY3JpcHQoKVxuICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICB2YXIgc3RhdHVzID0gX3JlZjMuc3RhdHVzLFxuICAgICAgICAgIG1lc3NhZ2UgPSBfcmVmMy5tZXNzYWdlO1xuICAgICAgcmVqZWN0KHtcbiAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdHJhbnNwYXJlbnRWaWRlb19tb3VudFNlZVRocnVDYW52YXNUYWcgPSAobW91bnRTZWVUaHJ1Q2FudmFzVGFnKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvZmVhdHVyZXMvdHJhbnNwYXJlbnRWaWRlby9jaGVja1N1cHBvcnRGb3JUcmFuc3BhcmVuY3kuanNcbi8qKlxuICogQHJldHVybiB7UHJvbWlzZTxib29sZWFuPn0gLSBXaGV0aGVyIHRoZSBicm93c2VyIHN1cHBvcnRzIHRyYW5zcGFyZW50IHZpZGVvcyBvciBub3RcbiAqL1xuXG5cbmZ1bmN0aW9uIGNoZWNrU3VwcG9ydEZvclRyYW5zcGFyZW5jeSgpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAvLyBSZXNvbHZlIGVhcmx5IGZvciBzYWZhcmkuXG4gICAgLy8gQ3VycmVudGx5ICgyOSBEZWNlbWJlciAyMDIxKSBTYWZhcmkgY2FuIHBsYXkgd2VibS92cDksXG4gICAgLy8gYnV0IGl0IGRvZXMgbm90IHN1cHBvcnQgdHJhbnNwYXJlbnQgdmlkZW8gaW4gdGhlIGZvcm1hdCB3ZSdyZSBvdXRwdXR0aW5nXG4gICAgaWYgKGlzU2FmYXJpKCkpIHtcbiAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciB2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgdmFyIGNhblBsYXkgPSB2aWRlby5jYW5QbGF5VHlwZSAmJiB2aWRlby5jYW5QbGF5VHlwZSgndmlkZW8vd2VibTsgY29kZWNzPVwidnA5XCInKTtcbiAgICByZXNvbHZlKGNhblBsYXkgPT09ICdtYXliZScgfHwgY2FuUGxheSA9PT0gJ3Byb2JhYmx5Jyk7XG4gIH0pO1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0cmFuc3BhcmVudFZpZGVvX2NoZWNrU3VwcG9ydEZvclRyYW5zcGFyZW5jeSA9IChjaGVja1N1cHBvcnRGb3JUcmFuc3BhcmVuY3kpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY2xvdWRpbmFyeS5qc1xuZnVuY3Rpb24gY2xvdWRpbmFyeV9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIGNsb3VkaW5hcnlfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIGNsb3VkaW5hcnlfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBjbG91ZGluYXJ5X2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBjbG91ZGluYXJ5X2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cblxudmFyIGFwcGx5QnJlYWtwb2ludHMsIGNsb3Nlc3RBYm92ZSwgZGVmYXVsdEJyZWFrcG9pbnRzLCBjbG91ZGluYXJ5X2ZpbmRDb250YWluZXJXaWR0aCwgY2xvdWRpbmFyeV9tYXhXaWR0aCwgdXBkYXRlRHByO1xuXG5cblxuXG5cblxuXG5cblxuIC8vXG5cblxuXG5cblxuXG5kZWZhdWx0QnJlYWtwb2ludHMgPSBmdW5jdGlvbiBkZWZhdWx0QnJlYWtwb2ludHMod2lkdGgpIHtcbiAgdmFyIHN0ZXBzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxMDA7XG4gIHJldHVybiBzdGVwcyAqIE1hdGguY2VpbCh3aWR0aCAvIHN0ZXBzKTtcbn07XG5cbmNsb3Nlc3RBYm92ZSA9IGZ1bmN0aW9uIGNsb3Nlc3RBYm92ZShsaXN0LCB2YWx1ZSkge1xuICB2YXIgaTtcbiAgaSA9IGxpc3QubGVuZ3RoIC0gMjtcblxuICB3aGlsZSAoaSA+PSAwICYmIGxpc3RbaV0gPj0gdmFsdWUpIHtcbiAgICBpLS07XG4gIH1cblxuICByZXR1cm4gbGlzdFtpICsgMV07XG59O1xuXG5hcHBseUJyZWFrcG9pbnRzID0gZnVuY3Rpb24gYXBwbHlCcmVha3BvaW50cyh0YWcsIHdpZHRoLCBzdGVwcywgb3B0aW9ucykge1xuICB2YXIgcmVmLCByZWYxLCByZWYyLCByZXNwb25zaXZlX3VzZV9icmVha3BvaW50cztcbiAgcmVzcG9uc2l2ZV91c2VfYnJlYWtwb2ludHMgPSAocmVmID0gKHJlZjEgPSAocmVmMiA9IG9wdGlvbnNbJ3Jlc3BvbnNpdmVfdXNlX2JyZWFrcG9pbnRzJ10pICE9IG51bGwgPyByZWYyIDogb3B0aW9uc1sncmVzcG9uc2l2ZV91c2Vfc3RvcHBvaW50cyddKSAhPSBudWxsID8gcmVmMSA6IHRoaXMuY29uZmlnKCdyZXNwb25zaXZlX3VzZV9icmVha3BvaW50cycpKSAhPSBudWxsID8gcmVmIDogdGhpcy5jb25maWcoJ3Jlc3BvbnNpdmVfdXNlX3N0b3Bwb2ludHMnKTtcblxuICBpZiAoIXJlc3BvbnNpdmVfdXNlX2JyZWFrcG9pbnRzIHx8IHJlc3BvbnNpdmVfdXNlX2JyZWFrcG9pbnRzID09PSAncmVzaXplJyAmJiAhb3B0aW9ucy5yZXNpemluZykge1xuICAgIHJldHVybiB3aWR0aDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5jYWxjX2JyZWFrcG9pbnQodGFnLCB3aWR0aCwgc3RlcHMpO1xuICB9XG59O1xuXG5jbG91ZGluYXJ5X2ZpbmRDb250YWluZXJXaWR0aCA9IGZ1bmN0aW9uIGZpbmRDb250YWluZXJXaWR0aChlbGVtZW50KSB7XG4gIHZhciBjb250YWluZXJXaWR0aCwgc3R5bGU7XG4gIGNvbnRhaW5lcldpZHRoID0gMDtcblxuICB3aGlsZSAoKGVsZW1lbnQgPSBlbGVtZW50ICE9IG51bGwgPyBlbGVtZW50LnBhcmVudE5vZGUgOiB2b2lkIDApIGluc3RhbmNlb2YgRWxlbWVudCAmJiAhY29udGFpbmVyV2lkdGgpIHtcbiAgICBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXG4gICAgaWYgKCEvXmlubGluZS8udGVzdChzdHlsZS5kaXNwbGF5KSkge1xuICAgICAgY29udGFpbmVyV2lkdGggPSBsb2Rhc2hfd2lkdGgoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbnRhaW5lcldpZHRoO1xufTtcblxudXBkYXRlRHByID0gZnVuY3Rpb24gdXBkYXRlRHByKGRhdGFTcmMsIHJvdW5kRHByKSB7XG4gIHJldHVybiBkYXRhU3JjLnJlcGxhY2UoL1xcYmRwcl8oMVxcLjB8YXV0bylcXGIvZywgJ2Rwcl8nICsgdGhpcy5kZXZpY2VfcGl4ZWxfcmF0aW8ocm91bmREcHIpKTtcbn07XG5cbmNsb3VkaW5hcnlfbWF4V2lkdGggPSBmdW5jdGlvbiBtYXhXaWR0aChyZXF1aXJlZFdpZHRoLCB0YWcpIHtcbiAgdmFyIGltYWdlV2lkdGg7XG4gIGltYWdlV2lkdGggPSBsb2Rhc2hfZ2V0RGF0YSh0YWcsICd3aWR0aCcpIHx8IDA7XG5cbiAgaWYgKHJlcXVpcmVkV2lkdGggPiBpbWFnZVdpZHRoKSB7XG4gICAgaW1hZ2VXaWR0aCA9IHJlcXVpcmVkV2lkdGg7XG4gICAgbG9kYXNoX3NldERhdGEodGFnLCAnd2lkdGgnLCByZXF1aXJlZFdpZHRoKTtcbiAgfVxuXG4gIHJldHVybiBpbWFnZVdpZHRoO1xufTtcblxudmFyIGNsb3VkaW5hcnlfQ2xvdWRpbmFyeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IENsb3VkaW5hcnkgaW5zdGFuY2UuXG4gICAqIEBjbGFzcyBDbG91ZGluYXJ5XG4gICAqIEBjbGFzc2Rlc2MgTWFpbiBjbGFzcyBmb3IgYWNjZXNzaW5nIENsb3VkaW5hcnkgZnVuY3Rpb25hbGl0eS5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBBIHtAbGluayBDb25maWd1cmF0aW9ufSBvYmplY3QgZm9yIGdsb2JhbGx5IGNvbmZpZ3VyaW5nIENsb3VkaW5hcnkgYWNjb3VudCBzZXR0aW5ncy5cbiAgICogQGV4YW1wbGU8YnIvPlxuICAgKiAgdmFyIGNsID0gbmV3IGNsb3VkaW5hcnkuQ2xvdWRpbmFyeSggeyBjbG91ZF9uYW1lOiBcIm15Y2xvdWRcIn0pOzxici8+XG4gICAqICB2YXIgaW1nVGFnID0gY2wuaW1hZ2UoXCJteVBpY0lEXCIpO1xuICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vc29sdXRpb25fb3ZlcnZpZXcjY29uZmlndXJhdGlvbl9wYXJhbWV0ZXJzXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAqICBBdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgKi9cbiAgZnVuY3Rpb24gQ2xvdWRpbmFyeShvcHRpb25zKSB7XG4gICAgY2xvdWRpbmFyeV9jbGFzc0NhbGxDaGVjayh0aGlzLCBDbG91ZGluYXJ5KTtcblxuICAgIHZhciBjb25maWd1cmF0aW9uO1xuICAgIHRoaXMuZGV2aWNlUGl4ZWxSYXRpb0NhY2hlID0ge307XG4gICAgdGhpcy5yZXNwb25zaXZlQ29uZmlnID0ge307XG4gICAgdGhpcy5yZXNwb25zaXZlUmVzaXplSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICBjb25maWd1cmF0aW9uID0gbmV3IHNyY19jb25maWd1cmF0aW9uKG9wdGlvbnMpOyAvLyBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuXG4gICAgdGhpcy5jb25maWcgPSBmdW5jdGlvbiAobmV3Q29uZmlnLCBuZXdWYWx1ZSkge1xuICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb24uY29uZmlnKG5ld0NvbmZpZywgbmV3VmFsdWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXNlIFxcPG1ldGFcXD4gdGFncyBpbiB0aGUgZG9jdW1lbnQgdG8gY29uZmlndXJlIHRoaXMgYGNsb3VkaW5hcnlgIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm4gVGhpcyB7Q2xvdWRpbmFyeX0gaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuXG5cbiAgICB0aGlzLmZyb21Eb2N1bWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbmZpZ3VyYXRpb24uZnJvbURvY3VtZW50KCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVzZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdG8gY29uZmlndXJlIHRoaXMgYGNsb3VkaW5hcnlgIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm4gVGhpcyB7Q2xvdWRpbmFyeX0gaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuXG5cbiAgICB0aGlzLmZyb21FbnZpcm9ubWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbmZpZ3VyYXRpb24uZnJvbUVudmlyb25tZW50KCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBjb25maWd1cmF0aW9uIG9mIHRoaXMgYGNsb3VkaW5hcnlgIGluc3RhbmNlLlxuICAgICAqICBUaGlzIGlzIGEgY29udmVuaWVuY2UgbWV0aG9kIHRoYXQgaW52b2tlcyBib3RoIHtAbGluayBDb25maWd1cmF0aW9uI2Zyb21FbnZpcm9ubWVudHxmcm9tRW52aXJvbm1lbnQoKX1cbiAgICAgKiAgKE5vZGUuanMgZW52aXJvbm1lbnQgb25seSkgYW5kIHtAbGluayBDb25maWd1cmF0aW9uI2Zyb21Eb2N1bWVudHxmcm9tRG9jdW1lbnQoKX0uXG4gICAgICogIEl0IGZpcnN0IHRyaWVzIHRvIHJldHJpZXZlIHRoZSBjb25maWd1cmF0aW9uIGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICAgICAqICBJZiBub3QgYXZhaWxhYmxlLCBpdCB0cmllcyBmcm9tIHRoZSBkb2N1bWVudCBtZXRhIHRhZ3MuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjaW5pdFxuICAgICAqIEBzZWUgQ29uZmlndXJhdGlvbiNpbml0XG4gICAgICogQHJldHVybiBUaGlzIHtDbG91ZGluYXJ5fSBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gICAgICovXG5cblxuICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbmZpZ3VyYXRpb24uaW5pdCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ29udmVuaWVuY2UgY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7Q2xvdWRpbmFyeX1cbiAgICogQGV4YW1wbGUgY2wgPSBjbG91ZGluYXJ5LkNsb3VkaW5hcnkubmV3KCB7IGNsb3VkX25hbWU6IFwibXljbG91ZFwifSlcbiAgICovXG5cblxuICBjbG91ZGluYXJ5X2NyZWF0ZUNsYXNzKENsb3VkaW5hcnksIFt7XG4gICAga2V5OiBcInVybFwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIFVSTCBmb3IgYW55IGFzc2V0IGluIHlvdXIgTWVkaWEgbGlicmFyeS5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSN1cmxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgcHVibGljIElEIG9mIHRoZSBtZWRpYSBhc3NldC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycyB0byBpbmNsdWRlIGluIHRoZSBVUkwuXG4gICAgICogQHBhcmFtIHt0eXBlfSBbb3B0aW9ucy50eXBlPSd1cGxvYWQnXSAtIFRoZSBhc3NldCdzIHN0b3JhZ2UgdHlwZS5cbiAgICAgKiAgRm9yIGRldGFpbHMgb24gYWxsIGZldGNoIHR5cGVzLCBzZWVcbiAgICAgKiA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9ucyNmZXRjaGluZ19pbWFnZXNfZnJvbV9yZW1vdGVfbG9jYXRpb25zXCJcbiAgICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+RmV0Y2ggdHlwZXM8L2E+LlxuICAgICAqIEBwYXJhbSB7cmVzb3VyY2VUeXBlfSBbb3B0aW9ucy5yZXNvdXJjZV90eXBlPSdpbWFnZSddIC0gVGhlIHR5cGUgb2YgYXNzZXQuIFBvc3NpYmxlIHZhbHVlczo8YnIvPlxuICAgICAqICAtIGBpbWFnZWA8YnIvPlxuICAgICAqICAtIGB2aWRlb2A8YnIvPlxuICAgICAqICAtIGByYXdgXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgbWVkaWEgYXNzZXQgVVJMLlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vdmlkZW9fdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSB2aWRlbyB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICovXG4gICAgZnVuY3Rpb24gdXJsKHB1YmxpY0lkKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICByZXR1cm4gdXJsX3VybChwdWJsaWNJZCwgb3B0aW9ucywgdGhpcy5jb25maWcoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHZpZGVvIGFzc2V0IFVSTC5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSN2aWRlb191cmxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgcHVibGljIElEIG9mIHRoZSB2aWRlby5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycyB0byBpbmNsdWRlIGluIHRoZSBVUkwuXG4gICAgICogQHBhcmFtIHt0eXBlfSBbb3B0aW9ucy50eXBlPSd1cGxvYWQnXSAtIFRoZSBhc3NldCdzIHN0b3JhZ2UgdHlwZS5cbiAgICAgKiAgRm9yIGRldGFpbHMgb24gYWxsIGZldGNoIHR5cGVzLCBzZWVcbiAgICAgKiAgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbnMjZmV0Y2hpbmdfaW1hZ2VzX2Zyb21fcmVtb3RlX2xvY2F0aW9uc1wiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkZldGNoIHR5cGVzPC9hPi5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB2aWRlbyBVUkwuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3ZpZGVvX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSB2aWRlbyB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2aWRlb191cmxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmlkZW9fdXJsKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKSh7XG4gICAgICAgIHJlc291cmNlX3R5cGU6ICd2aWRlbydcbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMudXJsKHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgVVJMIGZvciBhbiBpbWFnZSBpbnRlbmRlZCB0byBiZSB1c2VkIGFzIGEgdGh1bWJuYWlsIGZvciB0aGUgc3BlY2lmaWVkIHZpZGVvLlxuICAgICAqICBJZGVudGljYWwgdG8ge0BsaW5rIENsb3VkaW5hcnkjdXJsfHVybH0sIGV4Y2VwdCB0aGF0IHRoZSBgcmVzb3VyY2VfdHlwZWAgaXMgYHZpZGVvYFxuICAgICAqICBhbmQgdGhlIGRlZmF1bHQgYGZvcm1hdGAgaXMgYGpwZ2AuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjdmlkZW9fdGh1bWJuYWlsX3VybFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtICBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHZpZGVvIGZyb20gd2hpY2ggeW91IHdhbnQgdG8gZ2VuZXJhdGUgYSB0aHVtYm5haWwgaW1hZ2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBpbWFnZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMgdG8gYXBwbHkgdG8gdGhlIHRodW1ibmFpbC5cbiAgICAgKiBJbiBhZGRpdGlvbiB0byBzdGFuZGFyZCBpbWFnZSB0cmFuc2Zvcm1hdGlvbnMsIHlvdSBjYW4gYWxzbyB1c2UgdGhlIGBzdGFydF9vZmZzZXRgIHRyYW5zZm9ybWF0aW9uIHBhcmFtZXRlclxuICAgICAqIHRvIGluc3RydWN0IENsb3VkaW5hcnkgdG8gZ2VuZXJhdGUgdGhlIHRodW1ibmFpbCBmcm9tIGEgZnJhbWUgb3RoZXIgdGhhbiB0aGUgbWlkZGxlIGZyYW1lIG9mIHRoZSB2aWRlby5cbiAgICAgKiBGb3IgZGV0YWlscywgc2VlXG4gICAgICogPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi92aWRlb19tYW5pcHVsYXRpb25fYW5kX2RlbGl2ZXJ5I2dlbmVyYXRpbmdfdmlkZW9fdGh1bWJuYWlsc1wiXG4gICAgICogdGFyZ2V0PVwiX2JsYW5rXCI+R2VuZXJhdGluZyB2aWRlbyB0aHVtYm5haWxzPC9hPiBpbiB0aGUgQ2xvdWRpbmFyeSBkb2N1bWVudGF0aW9uLlxuICAgICAqIEBwYXJhbSB7dHlwZX0gW29wdGlvbnMudHlwZT0ndXBsb2FkJ10gLSBUaGUgYXNzZXQncyBzdG9yYWdlIHR5cGUuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVJMIG9mIHRoZSB2aWRlbyB0aHVtYm5haWwgaW1hZ2UuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidmlkZW9fdGh1bWJuYWlsX3VybFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2aWRlb190aHVtYm5haWxfdXJsKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKSh7fSwgREVGQVVMVF9QT1NURVJfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcy51cmwocHVibGljSWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNwZWNpZmllZCB0cmFuc2Zvcm1hdGlvbiBvcHRpb25zLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3RyYW5zZm9ybWF0aW9uX3N0cmluZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gb3B0aW9ucy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgdHJhbnNmb3JtYXRpb24gc3RyaW5nLlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vdmlkZW9fdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSB2aWRlbyB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0cmFuc2Zvcm1hdGlvbl9zdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fc3RyaW5nKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgc3JjX3RyYW5zZm9ybWF0aW9uKG9wdGlvbnMpLnNlcmlhbGl6ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYW4gaW1hZ2UgdGFnLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I2ltYWdlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gVGhlIHB1YmxpYyBJRCBvZiB0aGUgaW1hZ2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzLCB7QGxpbmsgQ29uZmlndXJhdGlvbn0gcGFyYW1ldGVycyxcbiAgICAgKiAgYW5kIHN0YW5kYXJkIEhUTUwgJmx0O2ltZyZndDsgdGFnIGF0dHJpYnV0ZXMgdG8gYXBwbHkgdG8gdGhlIGltYWdlIHRhZy5cbiAgICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSBBbiBpbWFnZSB0YWcgRE9NIGVsZW1lbnQuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW1hZ2UocHVibGljSWQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciBjbGllbnRfaGludHMsIGltZywgcmVmO1xuICAgICAgaW1nID0gdGhpcy5pbWFnZVRhZyhwdWJsaWNJZCwgb3B0aW9ucyk7XG4gICAgICBjbGllbnRfaGludHMgPSAocmVmID0gb3B0aW9ucy5jbGllbnRfaGludHMgIT0gbnVsbCA/IG9wdGlvbnMuY2xpZW50X2hpbnRzIDogdGhpcy5jb25maWcoJ2NsaWVudF9oaW50cycpKSAhPSBudWxsID8gcmVmIDogZmFsc2U7XG5cbiAgICAgIGlmIChvcHRpb25zLnNyYyA9PSBudWxsICYmICFjbGllbnRfaGludHMpIHtcbiAgICAgICAgLy8gc3JjIG11c3QgYmUgcmVtb3ZlZCBiZWZvcmUgY3JlYXRpbmcgdGhlIERPTSBlbGVtZW50IHRvIGF2b2lkIGxvYWRpbmcgdGhlIGltYWdlXG4gICAgICAgIGltZy5zZXRBdHRyKFwic3JjXCIsICcnKTtcbiAgICAgIH1cblxuICAgICAgaW1nID0gaW1nLnRvRE9NKCk7XG5cbiAgICAgIGlmICghY2xpZW50X2hpbnRzKSB7XG4gICAgICAgIC8vIGNhY2hlIHRoZSBpbWFnZSBzcmNcbiAgICAgICAgbG9kYXNoX3NldERhdGEoaW1nLCAnc3JjLWNhY2hlJywgdGhpcy51cmwocHVibGljSWQsIG9wdGlvbnMpKTsgLy8gc2V0IGltYWdlIHNyYyB0YWtpbmcgcmVzcG9uc2l2ZW5lc3MgaW4gYWNjb3VudFxuXG4gICAgICAgIHRoaXMuY2xvdWRpbmFyeV91cGRhdGUoaW1nLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGltZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBJbWFnZVRhZyBpbnN0YW5jZSB1c2luZyB0aGUgY29uZmlndXJhdGlvbiBkZWZpbmVkIGZvciB0aGlzIGBjbG91ZGluYXJ5YCBpbnN0YW5jZS5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNpbWFnZVRhZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSBwdWJsaWMgSUQgb2YgdGhlIGltYWdlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzLCB7QGxpbmsgQ29uZmlndXJhdGlvbn0gcGFyYW1ldGVycyxcbiAgICAgKiAgYW5kIHN0YW5kYXJkIEhUTUwgJmx0O2ltZyZndDsgdGFnIGF0dHJpYnV0ZXMgdG8gYXBwbHkgdG8gdGhlIGltYWdlIHRhZy5cbiAgICAgKiBAcmV0dXJuIHtJbWFnZVRhZ30gQW4gSW1hZ2VUYWcgaW5zdGFuY2UgdGhhdCBpcyBhdHRhY2hlZCAoY2hhaW5lZCkgdG8gdGhpcyBDbG91ZGluYXJ5IGluc3RhbmNlLlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vc29sdXRpb25fb3ZlcnZpZXcjY29uZmlndXJhdGlvbl9wYXJhbWV0ZXJzXCJcbiAgICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXZhaWxhYmxlIGNvbmZpZ3VyYXRpb24gb3B0aW9uczwvYT5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImltYWdlVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGltYWdlVGFnKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgICB2YXIgdGFnO1xuICAgICAgdGFnID0gbmV3IGltYWdldGFnKHB1YmxpY0lkLCB0aGlzLmNvbmZpZygpKTtcbiAgICAgIHRhZy50cmFuc2Zvcm1hdGlvbigpLmZyb21PcHRpb25zKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRhZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBQaWN0dXJlVGFnIGluc3RhbmNlLCBjb25maWd1cmVkIHVzaW5nIHRoaXMgYGNsb3VkaW5hcnlgIGluc3RhbmNlLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I1BpY3R1cmVUYWdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSB0aGUgcHVibGljIElEIG9mIHRoZSByZXNvdXJjZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gYWRkaXRpb25hbCBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIG5ldyBJbWFnZVRhZyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gc291cmNlcyAtIHRoZSBzb3VyY2VzIGRlZmluaXRpb25zXG4gICAgICogQHJldHVybiB7UGljdHVyZVRhZ30gQSBQaWN0dXJlVGFnIHRoYXQgaXMgYXR0YWNoZWQgKGNoYWluZWQpIHRvIHRoaXMgQ2xvdWRpbmFyeSBpbnN0YW5jZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGljdHVyZVRhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwaWN0dXJlVGFnKHB1YmxpY0lkLCBvcHRpb25zLCBzb3VyY2VzKSB7XG4gICAgICB2YXIgdGFnO1xuICAgICAgdGFnID0gbmV3IHBpY3R1cmV0YWcocHVibGljSWQsIHRoaXMuY29uZmlnKCksIHNvdXJjZXMpO1xuICAgICAgdGFnLnRyYW5zZm9ybWF0aW9uKCkuZnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGFnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNvdXJjZVRhZyBpbnN0YW5jZSwgY29uZmlndXJlZCB1c2luZyB0aGlzIGBjbG91ZGluYXJ5YCBpbnN0YW5jZS5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNTb3VyY2VUYWdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSB0aGUgcHVibGljIElEIG9mIHRoZSByZXNvdXJjZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGFkZGl0aW9uYWwgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBuZXcgaW5zdGFuY2UuXG4gICAgICogQHJldHVybiB7U291cmNlVGFnfSBBIFNvdXJjZVRhZyB0aGF0IGlzIGF0dGFjaGVkIChjaGFpbmVkKSB0byB0aGlzIENsb3VkaW5hcnkgaW5zdGFuY2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNvdXJjZVRhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb3VyY2VUYWcocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciB0YWc7XG4gICAgICB0YWcgPSBuZXcgc291cmNldGFnKHB1YmxpY0lkLCB0aGlzLmNvbmZpZygpKTtcbiAgICAgIHRhZy50cmFuc2Zvcm1hdGlvbigpLmZyb21PcHRpb25zKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRhZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdmlkZW8gdGh1bWJuYWlsIFVSTCBmcm9tIHRoZSBzcGVjaWZpZWQgcmVtb3RlIHZpZGVvIGFuZCBpbmNsdWRlcyBpdCBpbiBhbiBpbWFnZSB0YWcuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjdmlkZW9fdGh1bWJuYWlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB2aWRlbyBmcm9tIHRoZSByZWxldmFudCB2aWRlbyBzaXRlLlxuICAgICAqICBBZGRpdGlvbmFsbHksIGVpdGhlciBhcHBlbmQgdGhlIGltYWdlIGV4dGVuc2lvbiB0eXBlIHRvIHRoZSBpZGVudGlmaWVyIHZhbHVlIG9yIHNldFxuICAgICAqICB0aGUgaW1hZ2UgZGVsaXZlcnkgZm9ybWF0IGluIHRoZSAnb3B0aW9ucycgcGFyYW1ldGVyIHVzaW5nIHRoZSAnZm9ybWF0JyB0cmFuc2Zvcm1hdGlvbiBvcHRpb24uXG4gICAgICogIEZvciBleGFtcGxlLCBhIFlvdVR1YmUgdmlkZW8gbWlnaHQgaGF2ZSB0aGUgaWRlbnRpZmllcjogJ28tdXJubGFKcE9BLmpwZycuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMgdG8gYXBwbHkuXG4gICAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH0gQW4gSFRNTCBpbWFnZSB0YWcgZWxlbWVudFxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi92aWRlb190cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIHZpZGVvIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vc29sdXRpb25fb3ZlcnZpZXcjY29uZmlndXJhdGlvbl9wYXJhbWV0ZXJzXCJcbiAgICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXZhaWxhYmxlIGNvbmZpZ3VyYXRpb24gb3B0aW9uczwvYT5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInZpZGVvX3RodW1ibmFpbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2aWRlb190aHVtYm5haWwocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmltYWdlKHB1YmxpY0lkLCBtZXJnZV9yb290X21lcmdlX2RlZmF1bHQoKSh7fSwgREVGQVVMVF9QT1NURVJfT1BUSU9OUywgb3B0aW9ucykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGEgZmFjZWJvb2sgcHJvZmlsZSBpbWFnZSBhbmQgZGVsaXZlcnMgaXQgaW4gYW4gaW1hZ2UgdGFnIGVsZW1lbnQuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjZmFjZWJvb2tfcHJvZmlsZV9pbWFnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSBGYWNlYm9vayBudW1lcmljIElELiBBZGRpdGlvbmFsbHksIGVpdGhlciBhcHBlbmQgdGhlIGltYWdlIGV4dGVuc2lvbiB0eXBlXG4gICAgICogIHRvIHRoZSBJRCBvciBzZXQgdGhlIGltYWdlIGRlbGl2ZXJ5IGZvcm1hdCBpbiB0aGUgJ29wdGlvbnMnIHBhcmFtZXRlciB1c2luZyB0aGUgJ2Zvcm1hdCcgdHJhbnNmb3JtYXRpb24gb3B0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzLCB7QGxpbmsgQ29uZmlndXJhdGlvbn0gcGFyYW1ldGVycyxcbiAgICAgKiAgYW5kIHN0YW5kYXJkIEhUTUwgJmx0O2ltZyZndDsgdGFnIGF0dHJpYnV0ZXMgdG8gYXBwbHkgdG8gdGhlIGltYWdlIHRhZy5cbiAgICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSBBbiBpbWFnZSB0YWcgZWxlbWVudC5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NvbHV0aW9uX292ZXJ2aWV3I2NvbmZpZ3VyYXRpb25fcGFyYW1ldGVyc1wiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM8L2E+XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmYWNlYm9va19wcm9maWxlX2ltYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZhY2Vib29rX3Byb2ZpbGVfaW1hZ2UocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmltYWdlKHB1YmxpY0lkLCBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHtcbiAgICAgICAgdHlwZTogJ2ZhY2Vib29rJ1xuICAgICAgfSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGEgVHdpdHRlciBwcm9maWxlIGltYWdlIGJ5IElEIGFuZCBkZWxpdmVycyBpdCBpbiBhbiBpbWFnZSB0YWcgZWxlbWVudC5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSN0d2l0dGVyX3Byb2ZpbGVfaW1hZ2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgVHdpdHRlciBudW1lcmljIElELiBBZGRpdGlvbmFsbHksIGVpdGhlciBhcHBlbmQgdGhlIGltYWdlIGV4dGVuc2lvbiB0eXBlXG4gICAgICogIHRvIHRoZSBJRCBvciBzZXQgdGhlIGltYWdlIGRlbGl2ZXJ5IGZvcm1hdCBpbiB0aGUgJ29wdGlvbnMnIHBhcmFtZXRlciB1c2luZyB0aGUgJ2Zvcm1hdCcgdHJhbnNmb3JtYXRpb24gb3B0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzLCB7QGxpbmsgQ29uZmlndXJhdGlvbn0gcGFyYW1ldGVycyxcbiAgICAgKiAgYW5kIHN0YW5kYXJkIEhUTUwgJmx0O2ltZyZndDsgdGFnIGF0dHJpYnV0ZXMgdG8gYXBwbHkgdG8gdGhlIGltYWdlIHRhZy5cbiAgICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSBBbiBpbWFnZSB0YWcgZWxlbWVudC5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NvbHV0aW9uX292ZXJ2aWV3I2NvbmZpZ3VyYXRpb25fcGFyYW1ldGVyc1wiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM8L2E+XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0d2l0dGVyX3Byb2ZpbGVfaW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHdpdHRlcl9wcm9maWxlX2ltYWdlKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbWFnZShwdWJsaWNJZCwgYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKSh7XG4gICAgICAgIHR5cGU6ICd0d2l0dGVyJ1xuICAgICAgfSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGEgVHdpdHRlciBwcm9maWxlIGltYWdlIGJ5IG5hbWUgYW5kIGRlbGl2ZXJzIGl0IGluIGFuIGltYWdlIHRhZyBlbGVtZW50LlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3R3aXR0ZXJfbmFtZV9wcm9maWxlX2ltYWdlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gVGhlIFR3aXR0ZXIgc2NyZWVuIG5hbWUuIEFkZGl0aW9uYWxseSwgZWl0aGVyIGFwcGVuZCB0aGUgaW1hZ2UgZXh0ZW5zaW9uIHR5cGVcbiAgICAgKiAgdG8gdGhlIHNjcmVlbiBuYW1lIG9yIHNldCB0aGUgaW1hZ2UgZGVsaXZlcnkgZm9ybWF0IGluIHRoZSAnb3B0aW9ucycgcGFyYW1ldGVyIHVzaW5nIHRoZSAnZm9ybWF0JyB0cmFuc2Zvcm1hdGlvbiBvcHRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMsIHtAbGluayBDb25maWd1cmF0aW9ufSBwYXJhbWV0ZXJzLFxuICAgICAqICBhbmQgc3RhbmRhcmQgSFRNTCAmbHQ7aW1nJmd0OyB0YWcgYXR0cmlidXRlcyB0byBhcHBseSB0byB0aGUgaW1hZ2UgdGFnLlxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IEFuIGltYWdlIHRhZyBlbGVtZW50LlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vc29sdXRpb25fb3ZlcnZpZXcjY29uZmlndXJhdGlvbl9wYXJhbWV0ZXJzXCJcbiAgICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXZhaWxhYmxlIGNvbmZpZ3VyYXRpb24gb3B0aW9uczwvYT5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInR3aXR0ZXJfbmFtZV9wcm9maWxlX2ltYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHR3aXR0ZXJfbmFtZV9wcm9maWxlX2ltYWdlKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbWFnZShwdWJsaWNJZCwgYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKSh7XG4gICAgICAgIHR5cGU6ICd0d2l0dGVyX25hbWUnXG4gICAgICB9LCBvcHRpb25zKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYSBHcmF2YXRhciBwcm9maWxlIGltYWdlIGFuZCBkZWxpdmVycyBpdCBpbiBhbiBpbWFnZSB0YWcgZWxlbWVudC5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNncmF2YXRhcl9pbWFnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSBjYWxjdWxhdGVkIGhhc2ggZm9yIHRoZSBHcmF2YXRhciBlbWFpbCBhZGRyZXNzLlxuICAgICAqICBBZGRpdGlvbmFsbHksIGVpdGhlciBhcHBlbmQgdGhlIGltYWdlIGV4dGVuc2lvbiB0eXBlIHRvIHRoZSBzY3JlZW4gbmFtZSBvciBzZXQgdGhlIGltYWdlIGRlbGl2ZXJ5IGZvcm1hdFxuICAgICAqICBpbiB0aGUgJ29wdGlvbnMnIHBhcmFtZXRlciB1c2luZyB0aGUgJ2Zvcm1hdCcgdHJhbnNmb3JtYXRpb24gb3B0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzLCB7QGxpbmsgQ29uZmlndXJhdGlvbn0gcGFyYW1ldGVycyxcbiAgICAgKiAgYW5kIHN0YW5kYXJkIEhUTUwgJmx0O2ltZyZndDsgdGFnIGF0dHJpYnV0ZXMgdG8gYXBwbHkgdG8gdGhlIGltYWdlIHRhZy5cbiAgICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSBBbiBpbWFnZSB0YWcgZWxlbWVudC5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NvbHV0aW9uX292ZXJ2aWV3I2NvbmZpZ3VyYXRpb25fcGFyYW1ldGVyc1wiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM8L2E+XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJncmF2YXRhcl9pbWFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBncmF2YXRhcl9pbWFnZShwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuaW1hZ2UocHVibGljSWQsIGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0KCkoe1xuICAgICAgICB0eXBlOiAnZ3JhdmF0YXInXG4gICAgICB9LCBvcHRpb25zKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYW4gaW1hZ2UgZnJvbSBhIHJlbW90ZSBVUkwgYW5kIGRlbGl2ZXJzIGl0IGluIGFuIGltYWdlIHRhZyBlbGVtZW50LlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I2ZldGNoX2ltYWdlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gVGhlIGZ1bGwgVVJMIG9mIHRoZSBpbWFnZSB0byBmZXRjaCwgaW5jbHVkaW5nIHRoZSBleHRlbnNpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMsIHtAbGluayBDb25maWd1cmF0aW9ufSBwYXJhbWV0ZXJzLFxuICAgICAqICBhbmQgc3RhbmRhcmQgSFRNTCAmbHQ7aW1nJmd0OyB0YWcgYXR0cmlidXRlcyB0byBhcHBseSB0byB0aGUgaW1hZ2UgdGFnLlxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IEFuIGltYWdlIHRhZyBlbGVtZW50LlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vc29sdXRpb25fb3ZlcnZpZXcjY29uZmlndXJhdGlvbl9wYXJhbWV0ZXJzXCJcbiAgICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXZhaWxhYmxlIGNvbmZpZ3VyYXRpb24gb3B0aW9uczwvYT5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZldGNoX2ltYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZldGNoX2ltYWdlKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbWFnZShwdWJsaWNJZCwgYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKSh7XG4gICAgICAgIHR5cGU6ICdmZXRjaCdcbiAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdmlkZW8gdGFnLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3ZpZGVvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gVGhlIHB1YmxpYyBJRCBvZiB0aGUgdmlkZW8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMsIHtAbGluayBDb25maWd1cmF0aW9ufSBwYXJhbWV0ZXJzLFxuICAgICAqICBhbmQgc3RhbmRhcmQgSFRNTCAmbHQ7aW1nJmd0OyB0YWcgYXR0cmlidXRlcyB0byBhcHBseSB0byB0aGUgaW1hZ2UgdGFnLlxuICAgICAqIEByZXR1cm4ge0hUTUxWaWRlb0VsZW1lbnR9IEEgdmlkZW8gdGFnIERPTSBlbGVtZW50LlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi92aWRlb190cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIHZpZGVvIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vc29sdXRpb25fb3ZlcnZpZXcjY29uZmlndXJhdGlvbl9wYXJhbWV0ZXJzXCJcbiAgICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXZhaWxhYmxlIGNvbmZpZ3VyYXRpb24gb3B0aW9uczwvYT5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInZpZGVvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZpZGVvKHB1YmxpY0lkKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICByZXR1cm4gdGhpcy52aWRlb1RhZyhwdWJsaWNJZCwgb3B0aW9ucykudG9IdG1sKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVmlkZW9UYWcgaW5zdGFuY2UgdXNpbmcgdGhlIGNvbmZpZ3VyYXRpb24gZGVmaW5lZCBmb3IgdGhpcyBgY2xvdWRpbmFyeWAgaW5zdGFuY2UuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjdmlkZW9UYWdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgcHVibGljIElEIG9mIHRoZSB2aWRlby5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMsIHtAbGluayBDb25maWd1cmF0aW9ufSBwYXJhbWV0ZXJzLFxuICAgICAqICBhbmQgc3RhbmRhcmQgSFRNTCAmbHQ7aW1nJmd0OyB0YWcgYXR0cmlidXRlcyB0byBhcHBseSB0byB0aGUgaW1hZ2UgdGFnLlxuICAgICAqIEByZXR1cm4ge1ZpZGVvVGFnfSBBIFZpZGVvVGFnIHRoYXQgaXMgYXR0YWNoZWQgKGNoYWluZWQpIHRvIHRoaXMgYGNsb3VkaW5hcnlgIGluc3RhbmNlLlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi92aWRlb190cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIHZpZGVvIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vc29sdXRpb25fb3ZlcnZpZXcjY29uZmlndXJhdGlvbl9wYXJhbWV0ZXJzXCJcbiAgICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXZhaWxhYmxlIGNvbmZpZ3VyYXRpb24gb3B0aW9uczwvYT5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInZpZGVvVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZpZGVvVGFnKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdHMoe30sIG9wdGlvbnMsIHRoaXMuY29uZmlnKCkpO1xuICAgICAgcmV0dXJuIG5ldyB2aWRlb3RhZyhwdWJsaWNJZCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHNwcml0ZSBQTkcgaW1hZ2UgdGhhdCBjb250YWlucyBhbGwgaW1hZ2VzIHdpdGggdGhlIHNwZWNpZmllZCB0YWcgYW5kIHRoZSBjb3JyZXNwb25kaW5nIGNzcyBmaWxlLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3Nwcml0ZV9jc3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgdGFnIG9uIHdoaWNoIHRvIGJhc2UgdGhlIHNwcml0ZSBpbWFnZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycyB0byBpbmNsdWRlIGluIHRoZSBVUkwuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVJMIG9mIHRoZSBnZW5lcmF0ZWQgQ1NTIGZpbGUuIFRoZSBzcHJpdGUgaW1hZ2UgaGFzIHRoZSBzYW1lIFVSTCwgYnV0IHdpdGggYSBQTkcgZXh0ZW5zaW9uLlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zcHJpdGVfZ2VuZXJhdGlvblwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBTcHJpdGUgZ2VuZXJhdGlvbjwvYT5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzcHJpdGVfY3NzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwcml0ZV9jc3MocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHtcbiAgICAgICAgdHlwZTogJ3Nwcml0ZSdcbiAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoIXB1YmxpY0lkLm1hdGNoKC8uY3NzJC8pKSB7XG4gICAgICAgIG9wdGlvbnMuZm9ybWF0ID0gJ2Nzcyc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnVybChwdWJsaWNJZCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHJlc3BvbnNpdmUgaW1hZ2UgYmVoYXZpb3IgZm9yIGFsbCBpbWFnZSB0YWdzIHdpdGggdGhlICdjbGQtcmVzcG9uc2l2ZSdcbiAgICAgKiAgKG9yIG90aGVyIGRlZmluZWQge0BsaW5rIENsb3VkaW5hcnkjcmVzcG9uc2l2ZXxyZXNwb25zaXZlfSBjbGFzcykuPGJyLz5cbiAgICAgKiAgVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGludm9rZWQgYWZ0ZXIgdGhlIHBhZ2UgaGFzIGxvYWRlZC48YnIvPlxuICAgICAqICA8Yj5Ob3RlPC9iPjogQ2FsbHMge0BsaW5rIENsb3VkaW5hcnkjY2xvdWRpbmFyeV91cGRhdGV8Y2xvdWRpbmFyeV91cGRhdGV9IHRvIG1vZGlmeSBpbWFnZSB0YWdzLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3Jlc3BvbnNpdmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5yZXNwb25zaXZlX2NsYXNzPSdjbGQtcmVzcG9uc2l2ZSddIC0gQW4gYWx0ZXJuYXRpdmUgY2xhc3NcbiAgICAgKiAgdG8gbG9jYXRlIHRoZSByZWxldmFudCAmbHQ7aW1nJmd0OyB0YWdzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yZXNwb25zaXZlX2RlYm91bmNlPTEwMF0gLSBUaGUgZGVib3VuY2UgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Jvb3RzdHJhcD10cnVlXSBJZiB0cnVlLCBwcm9jZXNzZXMgdGhlICZsdDtpbWcmZ3Q7IHRhZ3MgYnkgY2FsbGluZ1xuICAgICAqICB7QGxpbmsgQ2xvdWRpbmFyeSNjbG91ZGluYXJ5X3VwZGF0ZXxjbG91ZGluYXJ5X3VwZGF0ZX0uIFdoZW4gZmFsc2UsIHRoZSB0YWdzIGFyZSBwcm9jZXNzZWRcbiAgICAgKiAgb25seSBhZnRlciBhIHJlc2l6ZSBldmVudC5cbiAgICAgKiBAc2VlIHtAbGluayBDbG91ZGluYXJ5I2Nsb3VkaW5hcnlfdXBkYXRlfGNsb3VkaW5hcnlfdXBkYXRlfSBmb3IgYWRkaXRpb25hbCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnNcbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vcmVzcG9uc2l2ZV9pbWFnZXMjYXV0b21hdGluZ19yZXNwb25zaXZlX2ltYWdlc193aXRoX2phdmFzY3JpcHRcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdXRvbWF0aW5nIHJlc3BvbnNpdmUgaW1hZ2VzIHdpdGggSmF2YVNjcmlwdDwvYT5cbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gdGhhdCB3aGVuIGNhbGxlZCwgcmVtb3ZlcyB0aGUgcmVzaXplIEV2ZW50TGlzdGVuZXIgYWRkZWQgYnkgdGhpcyBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVzcG9uc2l2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNwb25zaXZlKG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBib290c3RyYXAgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICB2YXIgcmVmLCByZWYxLCByZWYyLCByZXNwb25zaXZlQ2xhc3MsIHJlc3BvbnNpdmVSZXNpemUsIHRpbWVvdXQ7XG4gICAgICB0aGlzLnJlc3BvbnNpdmVDb25maWcgPSBtZXJnZV9yb290X21lcmdlX2RlZmF1bHQoKSh0aGlzLnJlc3BvbnNpdmVDb25maWcgfHwge30sIG9wdGlvbnMpO1xuICAgICAgcmVzcG9uc2l2ZUNsYXNzID0gKHJlZiA9IHRoaXMucmVzcG9uc2l2ZUNvbmZpZy5yZXNwb25zaXZlX2NsYXNzKSAhPSBudWxsID8gcmVmIDogdGhpcy5jb25maWcoJ3Jlc3BvbnNpdmVfY2xhc3MnKTtcblxuICAgICAgaWYgKGJvb3RzdHJhcCkge1xuICAgICAgICB0aGlzLmNsb3VkaW5hcnlfdXBkYXRlKFwiaW1nLlwiLmNvbmNhdChyZXNwb25zaXZlQ2xhc3MsIFwiLCBpbWcuY2xkLWhpZHBpXCIpLCB0aGlzLnJlc3BvbnNpdmVDb25maWcpO1xuICAgICAgfVxuXG4gICAgICByZXNwb25zaXZlUmVzaXplID0gKHJlZjEgPSAocmVmMiA9IHRoaXMucmVzcG9uc2l2ZUNvbmZpZy5yZXNwb25zaXZlX3Jlc2l6ZSkgIT0gbnVsbCA/IHJlZjIgOiB0aGlzLmNvbmZpZygncmVzcG9uc2l2ZV9yZXNpemUnKSkgIT0gbnVsbCA/IHJlZjEgOiB0cnVlO1xuXG4gICAgICBpZiAocmVzcG9uc2l2ZVJlc2l6ZSAmJiAhdGhpcy5yZXNwb25zaXZlUmVzaXplSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5yZXNwb25zaXZlQ29uZmlnLnJlc2l6aW5nID0gdGhpcy5yZXNwb25zaXZlUmVzaXplSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcblxuICAgICAgICB2YXIgbWFrZVJlc3BvbnNpdmUgPSBmdW5jdGlvbiBtYWtlUmVzcG9uc2l2ZSgpIHtcbiAgICAgICAgICB2YXIgZGVib3VuY2UsIHJlZjMsIHJlZjQsIHJlc2V0LCBydW4sIHdhaXQsIHdhaXRGdW5jO1xuICAgICAgICAgIGRlYm91bmNlID0gKHJlZjMgPSAocmVmNCA9IF90aGlzLnJlc3BvbnNpdmVDb25maWcucmVzcG9uc2l2ZV9kZWJvdW5jZSkgIT0gbnVsbCA/IHJlZjQgOiBfdGhpcy5jb25maWcoJ3Jlc3BvbnNpdmVfZGVib3VuY2UnKSkgIT0gbnVsbCA/IHJlZjMgOiAxMDA7XG5cbiAgICAgICAgICByZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcnVuID0gZnVuY3Rpb24gcnVuKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNsb3VkaW5hcnlfdXBkYXRlKFwiaW1nLlwiLmNvbmNhdChyZXNwb25zaXZlQ2xhc3MpLCBfdGhpcy5yZXNwb25zaXZlQ29uZmlnKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgd2FpdEZ1bmMgPSBmdW5jdGlvbiB3YWl0RnVuYygpIHtcbiAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gcnVuKCk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHdhaXQgPSBmdW5jdGlvbiB3YWl0KCkge1xuICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHdhaXRGdW5jLCBkZWJvdW5jZSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChkZWJvdW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHdhaXQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJ1bigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgbWFrZVJlc3BvbnNpdmUpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgbWFrZVJlc3BvbnNpdmUpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNjYWxjX2JyZWFrcG9pbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNhbGNfYnJlYWtwb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjX2JyZWFrcG9pbnQoZWxlbWVudCwgd2lkdGgsIHN0ZXBzKSB7XG4gICAgICB2YXIgYnJlYWtwb2ludHMgPSBsb2Rhc2hfZ2V0RGF0YShlbGVtZW50LCAnYnJlYWtwb2ludHMnKSB8fCBsb2Rhc2hfZ2V0RGF0YShlbGVtZW50LCAnc3RvcHBvaW50cycpIHx8IHRoaXMuY29uZmlnKCdicmVha3BvaW50cycpIHx8IHRoaXMuY29uZmlnKCdzdG9wcG9pbnRzJykgfHwgZGVmYXVsdEJyZWFrcG9pbnRzO1xuXG4gICAgICBpZiAoaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGJyZWFrcG9pbnRzKSkge1xuICAgICAgICByZXR1cm4gYnJlYWtwb2ludHMod2lkdGgsIHN0ZXBzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQoKShicmVha3BvaW50cykpIHtcbiAgICAgICAgICBicmVha3BvaW50cyA9IGJyZWFrcG9pbnRzLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHBvaW50KTtcbiAgICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xvc2VzdEFib3ZlKGJyZWFrcG9pbnRzLCB3aWR0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I2NhbGNfc3RvcHBvaW50XG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBjYWxjX2JyZWFrcG9pbnR9IGluc3RlYWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjYWxjX3N0b3Bwb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjX3N0b3Bwb2ludChlbGVtZW50LCB3aWR0aCwgc3RlcHMpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGNfYnJlYWtwb2ludChlbGVtZW50LCB3aWR0aCwgc3RlcHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNkZXZpY2VfcGl4ZWxfcmF0aW9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGV2aWNlX3BpeGVsX3JhdGlvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRldmljZV9waXhlbF9yYXRpbyhyb3VuZERwcikge1xuICAgICAgcm91bmREcHIgPSByb3VuZERwciA9PSBudWxsID8gdHJ1ZSA6IHJvdW5kRHByO1xuICAgICAgdmFyIGRwciA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyAhPT0gbnVsbCA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogdm9pZCAwKSB8fCAxO1xuXG4gICAgICBpZiAocm91bmREcHIpIHtcbiAgICAgICAgZHByID0gTWF0aC5jZWlsKGRwcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChkcHIgPD0gMCB8fCBkcHIgPT09IDAgLyAwKSB7XG4gICAgICAgIGRwciA9IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBkcHJTdHJpbmcgPSBkcHIudG9TdHJpbmcoKTtcblxuICAgICAgaWYgKGRwclN0cmluZy5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgICAgZHByU3RyaW5nICs9ICcuMCc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkcHJTdHJpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICogQXBwbGllcyByZXNwb25zaXZlbmVzcyB0byBhbGwgPGNvZGU+Jmx0O2ltZyZndDs8L2NvZGU+IHRhZ3MgdW5kZXIgZWFjaCByZWxldmFudCBub2RlXG4gICAgKiAgKHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdGFnIGNvbnRhaW5zIHRoZSB7QGxpbmsgQ2xvdWRpbmFyeSNyZXNwb25zaXZlfHJlc3BvbnNpdmV9IGNsYXNzKS5cbiAgICAqIEBwYXJhbSB7RWxlbWVudFtdfSBub2RlcyBUaGUgcGFyZW50IG5vZGVzIHdoZXJlIHlvdSB3YW50IHRvIHNlYXJjaCBmb3IgJmx0O2ltZyZndDsgdGFncy5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIHtAbGluayBDbG91ZGluYXJ5I2Nsb3VkaW5hcnlfdXBkYXRlfGNsb3VkaW5hcnlfdXBkYXRlfSBvcHRpb25zIHRvIGFwcGx5LlxuICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiXG4gICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3Byb2Nlc3NJbWFnZVRhZ3NcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHJvY2Vzc0ltYWdlVGFnc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzSW1hZ2VUYWdzKG5vZGVzLCBvcHRpb25zKSB7XG4gICAgICBpZiAoaXNFbXB0eShub2RlcykpIHtcbiAgICAgICAgLy8gc2ltaWxhciB0byBgJC5mbi5jbG91ZGluYXJ5YFxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRzKHt9LCBvcHRpb25zIHx8IHt9LCB0aGlzLmNvbmZpZygpKTtcbiAgICAgIHZhciBpbWFnZXMgPSBub2Rlcy5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIC9eaW1nJC9pLnRlc3Qobm9kZS50YWdOYW1lKTtcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgaW1nT3B0aW9ucyA9IGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0KCkoe1xuICAgICAgICAgIHdpZHRoOiBub2RlLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSxcbiAgICAgICAgICBoZWlnaHQ6IG5vZGUuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSxcbiAgICAgICAgICBzcmM6IG5vZGUuZ2V0QXR0cmlidXRlKCdzcmMnKVxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgdmFyIHB1YmxpY0lkID0gaW1nT3B0aW9uc1snc291cmNlJ10gfHwgaW1nT3B0aW9uc1snc3JjJ107XG4gICAgICAgIGRlbGV0ZSBpbWdPcHRpb25zWydzb3VyY2UnXTtcbiAgICAgICAgZGVsZXRlIGltZ09wdGlvbnNbJ3NyYyddO1xuICAgICAgICB2YXIgYXR0ciA9IG5ldyBzcmNfdHJhbnNmb3JtYXRpb24oaW1nT3B0aW9ucykudG9IdG1sQXR0cmlidXRlcygpO1xuICAgICAgICBsb2Rhc2hfc2V0RGF0YShub2RlLCAnc3JjLWNhY2hlJywgdXJsX3VybChwdWJsaWNJZCwgaW1nT3B0aW9ucykpO1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBhdHRyLndpZHRoKTtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGF0dHIuaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY2xvdWRpbmFyeV91cGRhdGUoaW1hZ2VzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFVwZGF0ZXMgdGhlIGRwciAoZm9yIGBkcHJfYXV0b2ApIGFuZCByZXNwb25zaXZlIChmb3IgYHdfYXV0b2ApIGZpZWxkcyBhY2NvcmRpbmcgdG9cbiAgICAqICB0aGUgY3VycmVudCBjb250YWluZXIgc2l6ZSBhbmQgdGhlIGRldmljZSBwaXhlbCByYXRpby48YnIvPlxuICAgICogIDxiPk5vdGU8L2I+OmB3X2F1dG9gIGlzIHVwZGF0ZWQgb25seSBmb3IgaW1hZ2VzIG1hcmtlZCB3aXRoIHRoZSBgY2xkLXJlc3BvbnNpdmVgXG4gICAgKiAgKG9yIG90aGVyIGRlZmluZWQge0BsaW5rIENsb3VkaW5hcnkjcmVzcG9uc2l2ZXxyZXNwb25zaXZlfSkgY2xhc3MuXG4gICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNjbG91ZGluYXJ5X3VwZGF0ZVxuICAgICogQHBhcmFtIHsoQXJyYXl8c3RyaW5nfE5vZGVMaXN0KX0gZWxlbWVudHMgLSBUaGUgSFRNTCBpbWFnZSBlbGVtZW50cyB0byBtb2RpZnkuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICogQHBhcmFtIHtib29sZWFufHN0cmluZ30gW29wdGlvbnMucmVzcG9uc2l2ZV91c2VfYnJlYWtwb2ludHM9dHJ1ZV1cbiAgICAqIFBvc3NpYmxlIHZhbHVlczo8YnIvPlxuICAgICogIC0gYHRydWVgOiBBbHdheXMgdXNlIGJyZWFrcG9pbnRzIGZvciB3aWR0aC48YnIvPlxuICAgICogIC0gYHJlc2l6ZWA6IFVzZSBleGFjdCB3aWR0aCBvbiBmaXJzdCByZW5kZXIgYW5kIGJyZWFrcG9pbnRzIG9uIHJlc2l6ZS48YnIvPlxuICAgICogIC0gYGZhbHNlYDogQWx3YXlzIHVzZSBleGFjdCB3aWR0aC5cbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVzcG9uc2l2ZV0gLSBJZiBgdHJ1ZWAsIGVuYWJsZSByZXNwb25zaXZlIG9uIGFsbCBzcGVjaWZpZWQgZWxlbWVudHMuXG4gICAgKiAgQWx0ZXJuYXRpdmVseSwgeW91IGNhbiBkZWZpbmUgc3BlY2lmaWMgSFRNTCBlbGVtZW50cyB0byBtb2RpZnkgYnkgYWRkaW5nIHRoZSBgY2xkLXJlc3BvbnNpdmVgXG4gICAgKiAgKG9yIG90aGVyIGN1c3RvbS1kZWZpbmVkIHtAbGluayBDbG91ZGluYXJ5I3Jlc3BvbnNpdmV8cmVzcG9uc2l2ZV9jbGFzc30pIGNsYXNzIHRvIHRob3NlIGVsZW1lbnRzLlxuICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZXNwb25zaXZlX3ByZXNlcnZlX2hlaWdodF0gLSBJZiBgdHJ1ZWAsIG9yaWdpbmFsIGNzcyBoZWlnaHQgaXMgcHJlc2VydmVkLlxuICAgICogIFNob3VsZCBiZSB1c2VkIG9ubHkgaWYgdGhlIHRyYW5zZm9ybWF0aW9uIHN1cHBvcnRzIGRpZmZlcmVudCBhc3BlY3QgcmF0aW9zLlxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbG91ZGluYXJ5X3VwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG91ZGluYXJ5X3VwZGF0ZShlbGVtZW50cywgb3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBjb250YWluZXJXaWR0aCwgZGF0YVNyYywgbWF0Y2gsIHJlZjQsIHJlcXVpcmVkV2lkdGg7XG5cbiAgICAgIGlmIChlbGVtZW50cyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgIHZhciByZXNwb25zaXZlID0gb3B0aW9ucy5yZXNwb25zaXZlICE9IG51bGwgPyBvcHRpb25zLnJlc3BvbnNpdmUgOiB0aGlzLmNvbmZpZygncmVzcG9uc2l2ZScpO1xuICAgICAgZWxlbWVudHMgPSBub3JtYWxpemVUb0FycmF5KGVsZW1lbnRzKTtcbiAgICAgIHZhciByZXNwb25zaXZlQ2xhc3M7XG5cbiAgICAgIGlmICh0aGlzLnJlc3BvbnNpdmVDb25maWcgJiYgdGhpcy5yZXNwb25zaXZlQ29uZmlnLnJlc3BvbnNpdmVfY2xhc3MgIT0gbnVsbCkge1xuICAgICAgICByZXNwb25zaXZlQ2xhc3MgPSB0aGlzLnJlc3BvbnNpdmVDb25maWcucmVzcG9uc2l2ZV9jbGFzcztcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5yZXNwb25zaXZlX2NsYXNzICE9IG51bGwpIHtcbiAgICAgICAgcmVzcG9uc2l2ZUNsYXNzID0gb3B0aW9ucy5yZXNwb25zaXZlX2NsYXNzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzcG9uc2l2ZUNsYXNzID0gdGhpcy5jb25maWcoJ3Jlc3BvbnNpdmVfY2xhc3MnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJvdW5kRHByID0gb3B0aW9ucy5yb3VuZF9kcHIgIT0gbnVsbCA/IG9wdGlvbnMucm91bmRfZHByIDogdGhpcy5jb25maWcoJ3JvdW5kX2RwcicpO1xuICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgIGlmICgvaW1nL2kudGVzdCh0YWcudGFnTmFtZSkpIHtcbiAgICAgICAgICB2YXIgc2V0VXJsID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChyZXNwb25zaXZlKSB7XG4gICAgICAgICAgICBsb2Rhc2hfYWRkQ2xhc3ModGFnLCByZXNwb25zaXZlQ2xhc3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRhdGFTcmMgPSBsb2Rhc2hfZ2V0RGF0YSh0YWcsICdzcmMtY2FjaGUnKSB8fCBsb2Rhc2hfZ2V0RGF0YSh0YWcsICdzcmMnKTtcblxuICAgICAgICAgIGlmICghaXNFbXB0eShkYXRhU3JjKSkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIGRwciBhY2NvcmRpbmcgdG8gdGhlIGRldmljZSdzIGRldmljZVBpeGVsUmF0aW9cbiAgICAgICAgICAgIGRhdGFTcmMgPSB1cGRhdGVEcHIuY2FsbChfdGhpczIsIGRhdGFTcmMsIHJvdW5kRHByKTtcblxuICAgICAgICAgICAgaWYgKGh0bWx0YWcuaXNSZXNwb25zaXZlKHRhZywgcmVzcG9uc2l2ZUNsYXNzKSkge1xuICAgICAgICAgICAgICBjb250YWluZXJXaWR0aCA9IGNsb3VkaW5hcnlfZmluZENvbnRhaW5lcldpZHRoKHRhZyk7XG5cbiAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lcldpZHRoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKC93X2F1dG86YnJlYWtwb2ludHMvLnRlc3QoZGF0YVNyYykpIHtcbiAgICAgICAgICAgICAgICAgIHJlcXVpcmVkV2lkdGggPSBjbG91ZGluYXJ5X21heFdpZHRoKGNvbnRhaW5lcldpZHRoLCB0YWcpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAocmVxdWlyZWRXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhU3JjID0gZGF0YVNyYy5yZXBsYWNlKC93X2F1dG86YnJlYWtwb2ludHMoW18wLTldKikoOlswLTldKyk/LywgXCJ3X2F1dG86YnJlYWtwb2ludHMkMTpcIi5jb25jYXQocmVxdWlyZWRXaWR0aCkpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VXJsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG1hdGNoID0gL3dfYXV0byg6KFxcZCspKT8vLmV4ZWMoZGF0YVNyYyk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZFdpZHRoID0gYXBwbHlCcmVha3BvaW50cy5jYWxsKF90aGlzMiwgdGFnLCBjb250YWluZXJXaWR0aCwgbWF0Y2hbMl0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZFdpZHRoID0gY2xvdWRpbmFyeV9tYXhXaWR0aChyZXF1aXJlZFdpZHRoLCB0YWcpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1aXJlZFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGF0YVNyYyA9IGRhdGFTcmMucmVwbGFjZSgvd19hdXRvW14sXFwvXSovZywgXCJ3X1wiLmNvbmNhdChyZXF1aXJlZFdpZHRoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2V0VXJsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsb2Rhc2hfcmVtb3ZlQXR0cmlidXRlKHRhZywgJ3dpZHRoJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMucmVzcG9uc2l2ZV9wcmVzZXJ2ZV9oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgIGxvZGFzaF9yZW1vdmVBdHRyaWJ1dGUodGFnLCAnaGVpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENvbnRhaW5lciBkb2Vzbid0IGtub3cgdGhlIHNpemUgeWV0IC0gdXN1YWxseSBiZWNhdXNlIHRoZSBpbWFnZSBpcyBoaWRkZW4gb3Igb3V0c2lkZSB0aGUgRE9NLlxuICAgICAgICAgICAgICAgIHNldFVybCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpc0xhenlMb2FkaW5nID0gb3B0aW9ucy5sb2FkaW5nID09PSAnbGF6eScgJiYgIV90aGlzMi5pc05hdGl2ZUxhenlMb2FkU3VwcG9ydGVkKCkgJiYgX3RoaXMyLmlzTGF6eUxvYWRTdXBwb3J0ZWQoKSAmJiAhZWxlbWVudHNbMF0uZ2V0QXR0cmlidXRlKCdzcmMnKTtcblxuICAgICAgICAgICAgaWYgKHNldFVybCB8fCBpc0xhenlMb2FkaW5nKSB7XG4gICAgICAgICAgICAgIC8vIElmIGRhdGEtd2lkdGggZXhpc3RzLCBzZXQgd2lkdGggdG8gYmUgZGF0YS13aWR0aFxuICAgICAgICAgICAgICBfdGhpczIuc2V0QXR0cmlidXRlSWZFeGlzdHMoZWxlbWVudHNbMF0sICd3aWR0aCcsICdkYXRhLXdpZHRoJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZXRVcmwgJiYgIWlzTGF6eUxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgbG9kYXNoX3NldEF0dHJpYnV0ZSh0YWcsICdzcmMnLCBkYXRhU3JjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgZWxlbWVudFt0b0F0dHJpYnV0ZV0gPSBlbGVtZW50W2Zyb21BdHRyaWJ1dGVdIGlmIGVsZW1lbnRbZnJvbUF0dHJpYnV0ZV0gaXMgc2V0XG4gICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gdG9BdHRyaWJ1dGVcbiAgICAgKiBAcGFyYW0gZnJvbUF0dHJpYnV0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0QXR0cmlidXRlSWZFeGlzdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QXR0cmlidXRlSWZFeGlzdHMoZWxlbWVudCwgdG9BdHRyaWJ1dGUsIGZyb21BdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVWYWx1ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKGZyb21BdHRyaWJ1dGUpO1xuXG4gICAgICBpZiAoYXR0cmlidXRlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBsb2Rhc2hfc2V0QXR0cmlidXRlKGVsZW1lbnQsIHRvQXR0cmlidXRlLCBhdHRyaWJ1dGVWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBJbnRlcnNlY3Rpb24gT2JzZXJ2ZXIgQVBJIGlzIHN1cHBvcnRlZFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNMYXp5TG9hZFN1cHBvcnRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0xhenlMb2FkU3VwcG9ydGVkKCkge1xuICAgICAgcmV0dXJuIHdpbmRvdyAmJiAnSW50ZXJzZWN0aW9uT2JzZXJ2ZXInIGluIHdpbmRvdztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHVzaW5nIENocm9tZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNOYXRpdmVMYXp5TG9hZFN1cHBvcnRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc05hdGl2ZUxhenlMb2FkU3VwcG9ydGVkKCkge1xuICAgICAgcmV0dXJuICdsb2FkaW5nJyBpbiBIVE1MSW1hZ2VFbGVtZW50LnByb3RvdHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gb2JqZWN0LCBpbml0aWFsaXplZCB3aXRoIHRoZSBzcGVjaWZpZWQgb3B0aW9ucywgZm9yIGNoYWluaW5nIHB1cnBvc2VzLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3RyYW5zZm9ybWF0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gb3B0aW9ucyB0byBhcHBseS5cbiAgICAgKiBAcmV0dXJuIHtUcmFuc2Zvcm1hdGlvbn1cbiAgICAgKiBAc2VlIFRyYW5zZm9ybWF0aW9uXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi92aWRlb190cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIHZpZGVvIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBzcmNfdHJhbnNmb3JtYXRpb25bXCJuZXdcIl0odGhpcy5jb25maWcoKSkuZnJvbU9wdGlvbnMob3B0aW9ucykuc2V0UGFyZW50KHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiB3aWxsIGFwcGVuZCBhIFRyYW5zcGFyZW50VmlkZW8gZWxlbWVudCB0byB0aGUgaHRtbEVsQ29udGFpbmVyIHBhc3NlZCB0byBpdC5cbiAgICAgKiAgICAgICAgICAgICAgVHJhbnNwYXJlbnRWaWRlbyBjYW4gZWl0aGVyIGJlIGFuIEhUTUwgVmlkZW8gdGFnLCBvciBhbiBIVE1MIENhbnZhcyBUYWcuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaHRtbEVsQ29udGFpbmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgVGhlIHtAbGluayBUcmFuc3BhcmVudFZpZGVvT3B0aW9uc30gb3B0aW9ucyB0byBhcHBseSAtIEV4dGVuZHMgVHJhbnNmb3JtYXRpb25PcHRpb25zXG4gICAgICogICAgICAgICAgICAgICAgIG9wdGlvbnMucGxheXNpbmxpbmUgICAgLSBIVE1MIFZpZGVvIFRhZydzIG5hdGl2ZSBwbGF5c2lubGluZSAtIHBhc3NlZCB0byB2aWRlbyBlbGVtZW50LlxuICAgICAqICAgICAgICAgICAgICAgICBvcHRpb25zLnBvc3RlciAgICAgICAgIC0gSFRNTCBWaWRlbyBUYWcncyBuYXRpdmUgcG9zdGVyIC0gcGFzc2VkIHRvIHZpZGVvIGVsZW1lbnQuXG4gICAgICogICAgICAgICAgICAgICAgIG9wdGlvbnMubG9vcCAgICAgICAgICAgLSBIVE1MIFZpZGVvIFRhZydzIG5hdGl2ZSBsb29wIC0gcGFzc2VkIHRvIHZpZGVvIGVsZW1lbnQuXG4gICAgICogICAgICAgICAgICAgICAgIG9wdGlvbnM/LmV4dGVybmFsTGlicmFyaWVzID0geyBba2V5OiBzdHJpbmddOiBzdHJpbmd9IC0gbWFwIG9mIGV4dGVybmFsIGxpYnJhcmllcyB0byBiZSBsb2FkZWRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPEhUTUxFbGVtZW50IHwge3N0YXR1czpzdHJpbmcsIG1lc3NhZ2U6c3RyaW5nfT59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpbmplY3RUcmFuc3BhcmVudFZpZGVvRWxlbWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmplY3RUcmFuc3BhcmVudFZpZGVvRWxlbWVudChodG1sRWxDb250YWluZXIsIHB1YmxpY0lkKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgaWYgKCFodG1sRWxDb250YWluZXIpIHtcbiAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICAgICAgbWVzc2FnZTogJ0V4cGVjdGluZyBodG1sRWxDb250YWluZXIgdG8gYmUgSFRNTEVsZW1lbnQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cmFuc3BhcmVudFZpZGVvX2VuZm9yY2VPcHRpb25zRm9yVHJhbnNwYXJlbnRWaWRlbyhvcHRpb25zKTtcblxuICAgICAgICB2YXIgdmlkZW9VUkwgPSBfdGhpczMudmlkZW9fdXJsKHB1YmxpY0lkLCBvcHRpb25zKTtcblxuICAgICAgICB0cmFuc3BhcmVudFZpZGVvX2NoZWNrU3VwcG9ydEZvclRyYW5zcGFyZW5jeSgpLnRoZW4oZnVuY3Rpb24gKGlzTmF0aXZlbHlUcmFuc3BhcmVudCkge1xuICAgICAgICAgIHZhciBtb3VudFByb21pc2U7XG5cbiAgICAgICAgICBpZiAoaXNOYXRpdmVseVRyYW5zcGFyZW50KSB7XG4gICAgICAgICAgICBtb3VudFByb21pc2UgPSB0cmFuc3BhcmVudFZpZGVvX21vdW50Q2xvdWRpbmFyeVZpZGVvVGFnKGh0bWxFbENvbnRhaW5lciwgX3RoaXMzLCBwdWJsaWNJZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICByZXNvbHZlKGh0bWxFbENvbnRhaW5lcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vdW50UHJvbWlzZSA9IHRyYW5zcGFyZW50VmlkZW9fbW91bnRTZWVUaHJ1Q2FudmFzVGFnKGh0bWxFbENvbnRhaW5lciwgdmlkZW9VUkwsIG9wdGlvbnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1vdW50UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc29sdmUoaHRtbEVsQ29udGFpbmVyKTtcbiAgICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgICB2YXIgc3RhdHVzID0gX3JlZi5zdGF0dXMsXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IF9yZWYubWVzc2FnZTtcbiAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTsgLy8gY2F0Y2ggZm9yIGNoZWNrU3VwcG9ydEZvclRyYW5zcGFyZW5jeSgpXG4gICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgICAgdmFyIHN0YXR1cyA9IF9yZWYyLnN0YXR1cyxcbiAgICAgICAgICAgICAgbWVzc2FnZSA9IF9yZWYyLm1lc3NhZ2U7XG4gICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcIm5ld1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbmV3KG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhvcHRpb25zKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2xvdWRpbmFyeTtcbn0oKTtcblxuYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKShjbG91ZGluYXJ5X0Nsb3VkaW5hcnksIGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY2xvdWRpbmFyeSA9IChjbG91ZGluYXJ5X0Nsb3VkaW5hcnkpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbmFtZXNwYWNlL2Nsb3VkaW5hcnktY29yZS5qc1xuLyoqXG4gKiBDcmVhdGVzIHRoZSBuYW1lc3BhY2UgZm9yIENsb3VkaW5hcnlcbiAqL1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNsb3VkaW5hcnlfY29yZSA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgQ2xpZW50SGludHNNZXRhVGFnOiBjbGllbnRoaW50c21ldGF0YWcsXG4gIENsb3VkaW5hcnk6IGNsb3VkaW5hcnksXG4gIENvbmRpdGlvbjogY29uZGl0aW9uLFxuICBDb25maWd1cmF0aW9uOiBzcmNfY29uZmlndXJhdGlvbixcbiAgY3JjMzI6IHNyY19jcmMzMixcbiAgRXhwcmVzc2lvbjogZXhwcmVzc2lvbixcbiAgRmV0Y2hMYXllcjogZmV0Y2hsYXllcixcbiAgSHRtbFRhZzogaHRtbHRhZyxcbiAgSW1hZ2VUYWc6IGltYWdldGFnLFxuICBMYXllcjogbGF5ZXJfbGF5ZXIsXG4gIFBpY3R1cmVUYWc6IHBpY3R1cmV0YWcsXG4gIFN1YnRpdGxlc0xheWVyOiBzdWJ0aXRsZXNsYXllcixcbiAgVGV4dExheWVyOiB0ZXh0bGF5ZXIsXG4gIFRyYW5zZm9ybWF0aW9uOiBzcmNfdHJhbnNmb3JtYXRpb24sXG4gIHV0ZjhfZW5jb2RlOiBzcmNfdXRmOF9lbmNvZGUsXG4gIFV0aWw6IGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsXG4gIFZpZGVvVGFnOiB2aWRlb3RhZ1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL2Fzc2lnblwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2Fzc2lnbl9fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvY2xvbmVEZWVwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfY2xvbmVEZWVwX187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9jb21wYWN0XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfY29tcGFjdF9fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvZGlmZmVyZW5jZVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2RpZmZlcmVuY2VfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL2Z1bmN0aW9uc1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2Z1bmN0aW9uc19fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvaWRlbnRpdHlcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pZGVudGl0eV9fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvaW5jbHVkZXNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pbmNsdWRlc19fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvaXNBcnJheVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzQXJyYXlfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL2lzRWxlbWVudFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzRWxlbWVudF9fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvaXNGdW5jdGlvblwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzRnVuY3Rpb25fXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL2lzUGxhaW5PYmplY3RcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc1BsYWluT2JqZWN0X187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9pc1N0cmluZ1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzU3RyaW5nX187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9tZXJnZVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX21lcmdlX187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC90cmltXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfdHJpbV9fO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyB9KTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xvdWRpbmFyeS1jb3JlLmpzLm1hcCJdLCJuYW1lcyI6WyJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsInJvb3QiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsInJlcXVpcmUiLCJkZWZpbmUiLCJhbWQiLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9hc3NpZ25fXyIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2Nsb25lRGVlcF9fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfY29tcGFjdF9fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfZGlmZmVyZW5jZV9fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfZnVuY3Rpb25zX18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pZGVudGl0eV9fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaW5jbHVkZXNfXyIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzQXJyYXlfXyIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzRWxlbWVudF9fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNGdW5jdGlvbl9fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNQbGFpbk9iamVjdF9fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNTdHJpbmdfXyIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX21lcmdlX18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF90cmltX18iLCJtb2R1bGVzIiwiaW5zdGFsbGVkTW9kdWxlcyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJtb2R1bGVJZCIsImkiLCJsIiwiY2FsbCIsIm0iLCJjIiwiZCIsIm5hbWUiLCJnZXR0ZXIiLCJvIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiciIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwidmFsdWUiLCJ0IiwibW9kZSIsIl9fZXNNb2R1bGUiLCJucyIsImNyZWF0ZSIsImtleSIsImJpbmQiLCJuIiwiZ2V0RGVmYXVsdCIsImdldE1vZHVsZUV4cG9ydHMiLCJvYmplY3QiLCJwcm9wZXJ0eSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwicCIsInMiLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwiY2xpZW50aGludHNtZXRhdGFnIiwiY2xvdWRpbmFyeSIsImNvbmRpdGlvbiIsInNyY19jb25maWd1cmF0aW9uIiwic3JjX2NyYzMyIiwiZXhwcmVzc2lvbiIsImZldGNobGF5ZXIiLCJodG1sdGFnIiwiaW1hZ2V0YWciLCJsYXllcl9sYXllciIsInBpY3R1cmV0YWciLCJzdWJ0aXRsZXNsYXllciIsInRleHRsYXllciIsInNyY190cmFuc2Zvcm1hdGlvbiIsInNyY191dGY4X2VuY29kZSIsImxvZGFzaF9uYW1lc3BhY2VPYmplY3QiLCJ2aWRlb3RhZyIsImNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QiLCJWRVJTSU9OIiwiQ0ZfU0hBUkVEX0NETiIsIk9MRF9BS0FNQUlfU0hBUkVEX0NETiIsIkFLQU1BSV9TSEFSRURfQ0ROIiwiU0hBUkVEX0NETiIsIkRFRkFVTFRfVElNRU9VVF9NUyIsIkRFRkFVTFRfUE9TVEVSX09QVElPTlMiLCJERUZBVUxUX1ZJREVPX1NPVVJDRV9UWVBFUyIsIlNFT19UWVBFUyIsIkRFRkFVTFRfSU1BR0VfUEFSQU1TIiwiREVGQVVMVF9WSURFT19QQVJBTVMiLCJERUZBVUxUX1ZJREVPX1NPVVJDRVMiLCJERUZBVUxUX0VYVEVSTkFMX0xJQlJBUklFUyIsIlBMQUNFSE9MREVSX0lNQUdFX01PREVTIiwiQUNDRVNTSUJJTElUWV9NT0RFUyIsIlVSTF9LRVlTIiwiZ2V0U0RLQW5hbHl0aWNzU2lnbmF0dXJlIiwiZ2V0QW5hbHl0aWNzT3B0aW9ucyIsImFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0IiwiYSIsImNsb25lRGVlcF9yb290X2Nsb25lRGVlcF9kZWZhdWx0IiwiY29tcGFjdF9yb290X2NvbXBhY3RfZGVmYXVsdCIsImRpZmZlcmVuY2Vfcm9vdF9kaWZmZXJlbmNlX2RlZmF1bHQiLCJmdW5jdGlvbnNfcm9vdF9mdW5jdGlvbnNfZGVmYXVsdCIsImlkZW50aXR5X3Jvb3RfaWRlbnRpdHlfZGVmYXVsdCIsImluY2x1ZGVzX3Jvb3RfaW5jbHVkZXNfZGVmYXVsdCIsImlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQiLCJpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0IiwiaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0IiwibWVyZ2Vfcm9vdF9tZXJnZV9kZWZhdWx0IiwiaXNJbnRlcnNlY3Rpb25PYnNlcnZlclN1cHBvcnRlZCIsImlzTmF0aXZlTGF6eUxvYWRTdXBwb3J0ZWQiLCJkZXRlY3RJbnRlcnNlY3Rpb24iLCJvbWl0IiwiYmFzZXV0aWxfYWxsU3RyaW5ncyIsIndpdGhvdXQiLCJpc051bWJlckxpa2UiLCJzbWFydEVzY2FwZSIsImRlZmF1bHRzIiwib2JqZWN0UHJvdG8iLCJvYmpUb1N0cmluZyIsImlzT2JqZWN0IiwiZnVuY1RhZyIsInJlV29yZHMiLCJjYW1lbENhc2UiLCJzbmFrZUNhc2UiLCJjb252ZXJ0S2V5cyIsIndpdGhDYW1lbENhc2VLZXlzIiwid2l0aFNuYWtlQ2FzZUtleXMiLCJiYXNlNjRFbmNvZGUiLCJiYXNlNjRFbmNvZGVVUkwiLCJleHRyYWN0VXJsUGFyYW1zIiwicGF0Y2hGZXRjaEZvcm1hdCIsIm9wdGlvbkNvbnN1bWUiLCJpc0VtcHR5IiwiaXNBbmRyb2lkIiwiaXNFZGdlIiwiaXNDaHJvbWUiLCJpc1NhZmFyaSIsImlzRWxlbWVudF9yb290X2lzRWxlbWVudF9kZWZhdWx0IiwiaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCIsInRyaW1fcm9vdF90cmltX2RlZmF1bHQiLCJsb2Rhc2hfZ2V0RGF0YSIsImxvZGFzaF9zZXREYXRhIiwibG9kYXNoX2dldEF0dHJpYnV0ZSIsImxvZGFzaF9zZXRBdHRyaWJ1dGUiLCJsb2Rhc2hfcmVtb3ZlQXR0cmlidXRlIiwic2V0QXR0cmlidXRlcyIsImxvZGFzaF9oYXNDbGFzcyIsImxvZGFzaF9hZGRDbGFzcyIsImdldFN0eWxlcyIsImNzc0V4cGFuZCIsImRvbVN0eWxlIiwiY3VyQ1NTIiwiY3NzVmFsdWUiLCJhdWdtZW50V2lkdGhPckhlaWdodCIsImdldFdpZHRoT3JIZWlnaHQiLCJsb2Rhc2hfd2lkdGgiLCJ1dGY4X2VuY29kZSIsImFyZ1N0cmluZyIsImMxIiwiZW5jIiwiZW5kIiwic3RhcnQiLCJzdHJpbmciLCJzdHJpbmdsIiwidXRmdGV4dCIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJzbGljZSIsImNyYzMyIiwic3RyIiwiY3JjIiwiaVRvcCIsInRhYmxlIiwieCIsInkiLCJzdWJzdHIiLCJzdHJpbmdQYWQiLCJ0YXJnZXRMZW5ndGgiLCJwYWRTdHJpbmciLCJyZXBlYXRTdHJpbmdOdW1UaW1lcyIsInRpbWVzIiwicmVwZWF0ZWRTdHJpbmciLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwiVHlwZUVycm9yIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJ0b1N0cmluZyIsImNvbnN0cnVjdG9yIiwiQXJyYXkiLCJmcm9tIiwidGVzdCIsIml0ZXIiLCJpdGVyYXRvciIsImlzQXJyYXkiLCJsZW4iLCJhcnIyIiwiY2hhcnMiLCJiYXNlNjRNYXBfbnVtIiwibWFwIiwiZm9yRWFjaCIsIl9jaGFyIiwiYmFzZTY0TWFwIiwicmV2ZXJzZVZlcnNpb24iLCJzZW1WZXIiLCJzcGxpdCIsIkVycm9yIiwicmV2ZXJzZSIsInNlZ21lbnQiLCJqb2luIiwiZW5jb2RlVmVyc2lvbiIsInN0clJlc3VsdCIsInBhcnRzIiwicGFkZGVkU3RyaW5nTGVuZ3RoIiwicGFkZGVkUmV2ZXJzZWRTZW12ZXIiLCJudW0iLCJwYXJzZUludCIsInBhZGRlZEJpbmFyeSIsIm1hdGNoIiwiYml0U3RyaW5nIiwiYW5hbHl0aWNzT3B0aW9ucyIsImFyZ3VtZW50cyIsInVuZGVmaW5lZCIsInR3b1BhcnRWZXJzaW9uIiwicmVtb3ZlUGF0Y2hGcm9tU2VtdmVyIiwidGVjaFZlcnNpb24iLCJlbmNvZGVkU0RLVmVyc2lvbiIsInNka1NlbXZlciIsImVuY29kZWRUZWNoVmVyc2lvbiIsImZlYXR1cmVDb2RlIiwiZmVhdHVyZSIsIlNES0NvZGUiLCJzZGtDb2RlIiwiYWxnb1ZlcnNpb24iLCJjb25jYXQiLCJlIiwic2VtVmVyU3RyIiwib3B0aW9ucyIsInVybEFuYWx5dGljcyIsImFjY2Vzc2liaWxpdHkiLCJsb2FkaW5nIiwicmVzcG9uc2l2ZSIsInBsYWNlaG9sZGVyIiwiYXNzaWduX3Jvb3RfYXNzaWduXyIsImNsb25lRGVlcF9yb290X2Nsb25lRGVlcF8iLCJjb21wYWN0X3Jvb3RfY29tcGFjdF8iLCJkaWZmZXJlbmNlX3Jvb3RfZGlmZmVyZW5jZV8iLCJmdW5jdGlvbnNfcm9vdF9mdW5jdGlvbnNfIiwiaWRlbnRpdHlfcm9vdF9pZGVudGl0eV8iLCJpbmNsdWRlc19yb290X2luY2x1ZGVzXyIsImlzQXJyYXlfcm9vdF9pc0FycmF5XyIsImlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0XyIsImlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfIiwibWVyZ2Vfcm9vdF9tZXJnZV8iLCJpc0VsZW1lbnRfcm9vdF9pc0VsZW1lbnRfIiwiaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fIiwidHJpbV9yb290X3RyaW1fIiwiX3R5cGVvZiIsIm9iaiIsIndpbmRvdyIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwiSFRNTEltYWdlRWxlbWVudCIsImVsIiwib25JbnRlcnNlY3QiLCJvYnNlcnZlciIsImVudHJpZXMiLCJlbnRyeSIsImlzSW50ZXJzZWN0aW5nIiwidW5vYnNlcnZlIiwidGFyZ2V0IiwidGhyZXNob2xkIiwib2JzZXJ2ZSIsImZvcm1hdCIsInJlc291cmNlX3R5cGUiLCJ0cmFuc2Zvcm1hdGlvbiIsInR5cGUiLCJmYWxsYmFja19jb250ZW50Iiwic291cmNlX3RyYW5zZm9ybWF0aW9uIiwic291cmNlX3R5cGVzIiwiY29kZWNzIiwidHJhbnNmb3JtYXRpb25zIiwidmlkZW9fY29kZWMiLCJzZWVUaHJ1IiwiZWZmZWN0IiwicXVhbGl0eSIsImZldGNoX2Zvcm1hdCIsIndpZHRoIiwiYXNwZWN0X3JhdGlvIiwiY3JvcCIsImJhY2tncm91bmQiLCJoZWlnaHQiLCJncmF2aXR5IiwidmFyaWFibGVzIiwiZGFya21vZGUiLCJicmlnaHRtb2RlIiwibW9ub2Nocm9tZSIsImNvbG9yYmxpbmQiLCJiYXNldXRpbF90eXBlb2YiLCJrZXlzIiwic3JjS2V5cyIsImZpbHRlciIsImZpbHRlcmVkIiwiYWxsU3RyaW5ncyIsImxpc3QiLCJldmVyeSIsImFycmF5IiwiaXRlbSIsInYiLCJpc05hTiIsInBhcnNlRmxvYXQiLCJ1bnNhZmUiLCJyZXBsYWNlIiwidG9VcHBlckNhc2UiLCJkZXN0aW5hdGlvbiIsIl9sZW4iLCJzb3VyY2VzIiwiX2tleSIsInJlZHVjZSIsImRlc3QiLCJzb3VyY2UiLCJpc0Z1bmN0aW9uIiwibG93ZXIiLCJ1cHBlciIsIlJlZ0V4cCIsIndvcmRzIiwid29yZCIsImNoYXJBdCIsInRvTG9jYWxlVXBwZXJDYXNlIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJjb252ZXJ0ZXIiLCJyZXN1bHQiLCJidG9hIiwiQnVmZmVyIiwiaW5wdXQiLCJ1cmwiLCJkZWNvZGVVUkkiLCJlbmNvZGVVUkkiLCJvcHRpb25fbmFtZSIsImRlZmF1bHRfdmFsdWUiLCJzaXplIiwiZ2V0VXNlckFnZW50IiwibmF2aWdhdG9yIiwidXNlckFnZW50Iiwibm9kZUNvbnRhaW5zIiwiZ2V0RGF0YSIsImVsZW1lbnQiLCJnZXRBdHRyaWJ1dGUiLCJnZXRBdHRyIiwiZGF0YSIsImpRdWVyeSIsImZuIiwic2V0RGF0YSIsInNldEF0dHJpYnV0ZSIsInNldEF0dHIiLCJhdHRyIiwicmVtb3ZlQXR0cmlidXRlIiwiYXR0cmlidXRlcyIsInJlc3VsdHMiLCJwdXNoIiwiaGFzQ2xhc3MiLCJjbGFzc05hbWUiLCJhZGRDbGFzcyIsImVsZW0iLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJvcGVuZXIiLCJnZXRDb21wdXRlZFN0eWxlIiwiYiIsImFkb3duIiwiYnVwIiwibm9kZVR5cGUiLCJkb2N1bWVudEVsZW1lbnQiLCJwYXJlbnROb2RlIiwiY29udGFpbnMiLCJzdHlsZSIsImNvbXB1dGVkIiwibWF4V2lkdGgiLCJtaW5XaWR0aCIsInJldCIsInJtYXJnaW4iLCJnZXRQcm9wZXJ0eVZhbHVlIiwicm51bW5vbnB4IiwiY29udmVydCIsInN0eWxlcyIsInZhbCIsImV4dHJhIiwiaXNCb3JkZXJCb3giLCJzaWRlIiwic2lkZXMiLCJwbnVtIiwidmFsdWVJc0JvcmRlckJveCIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0IiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJFeHByZXNzaW9uIiwiZXhwcmVzc2lvblN0ciIsImV4cHJlc3Npb25zIiwibm9ybWFsaXplIiwic2VyaWFsaXplIiwiZ2V0UGFyZW50IiwicGFyZW50Iiwic2V0UGFyZW50IiwicHJlZGljYXRlIiwib3BlcmF0b3IiLCJPUEVSQVRPUlMiLCJhbmQiLCJvciIsInRoZW4iLCJhc3BlY3RSYXRpbyIsInBhZ2VDb3VudCIsImZhY2VDb3VudCIsIl92YWx1ZSIsIl9uZXciLCJvcGVyYXRvcnMiLCJvcGVyYXRvcnNQYXR0ZXJuIiwib3BlcmF0b3JzUmVwbGFjZVJFIiwicHJlZGVmaW5lZFZhcnNQYXR0ZXJuIiwiUFJFREVGSU5FRF9WQVJTIiwidXNlclZhcmlhYmxlUGF0dGVybiIsInZhcmlhYmxlc1JlcGxhY2VSRSIsInZhcmlhYmxlIiwiaW5pdGlhbFdpZHRoIiwiaW5pdGlhbEhlaWdodCIsImluaXRpYWxBc3BlY3RSYXRpbyIsImN1cnJlbnRQYWdlIiwidGFncyIsInBhZ2VYIiwicGFnZVkiLCJCT1VORFJZIiwiY29uZGl0aW9uX3R5cGVvZiIsImNvbmRpdGlvbl9jbGFzc0NhbGxDaGVjayIsImNvbmRpdGlvbl9kZWZpbmVQcm9wZXJ0aWVzIiwiY29uZGl0aW9uX2NyZWF0ZUNsYXNzIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiX3NldFByb3RvdHlwZU9mIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJfY3JlYXRlU3VwZXIiLCJEZXJpdmVkIiwiaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfY3JlYXRlU3VwZXJJbnRlcm5hbCIsIlN1cGVyIiwiX2dldFByb3RvdHlwZU9mIiwiTmV3VGFyZ2V0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsImFwcGx5IiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJzZWxmIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwic2hhbSIsIlByb3h5IiwiQm9vbGVhbiIsInZhbHVlT2YiLCJnZXRQcm90b3R5cGVPZiIsIkNvbmRpdGlvbiIsIl9FeHByZXNzaW9uIiwiX3N1cGVyIiwiY29uZGl0aW9uU3RyIiwiZHVyYXRpb24iLCJpbml0aWFsRHVyYXRpb24iLCJfc2xpY2VkVG9BcnJheSIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsImNvbmZpZ3VyYXRpb25fdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiY29uZmlndXJhdGlvbl9hcnJheUxpa2VUb0FycmF5IiwiX2kiLCJfYXJyIiwiX24iLCJfZCIsIl9zIiwiX2UiLCJuZXh0IiwiZG9uZSIsImVyciIsImNvbmZpZ3VyYXRpb25fY2xhc3NDYWxsQ2hlY2siLCJjb25maWd1cmF0aW9uX2RlZmluZVByb3BlcnRpZXMiLCJjb25maWd1cmF0aW9uX2NyZWF0ZUNsYXNzIiwiY29uZmlndXJhdGlvbl9Db25maWd1cmF0aW9uIiwiQ29uZmlndXJhdGlvbiIsImNvbmZpZ3VyYXRpb24iLCJERUZBVUxUX0NPTkZJR1VSQVRJT05fUEFSQU1TIiwiaW5pdCIsImZyb21FbnZpcm9ubWVudCIsImZyb21Eb2N1bWVudCIsInNldCIsIm1lcmdlIiwiY29uZmlnIiwibWV0YV9lbGVtZW50cyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsIl90aGlzIiwiY2xvdWRpbmFyeV91cmwiLCJxdWVyeSIsInVyaSIsInVyaVJlZ2V4IiwicHJvY2VzcyIsImVudiIsIkNMT1VESU5BUllfVVJMIiwiZXhlYyIsIl92YWx1ZSRzcGxpdCIsIl92YWx1ZSRzcGxpdDIiLCJrIiwibmV3X2NvbmZpZyIsIm5ld192YWx1ZSIsInRvT3B0aW9ucyIsInJlc3BvbnNpdmVfY2xhc3MiLCJyZXNwb25zaXZlX3VzZV9icmVha3BvaW50cyIsInJvdW5kX2RwciIsInNlY3VyZSIsImxvY2F0aW9uIiwicHJvdG9jb2wiLCJDT05GSUdfUEFSQU1TIiwibGF5ZXJfY2xhc3NDYWxsQ2hlY2siLCJsYXllcl9kZWZpbmVQcm9wZXJ0aWVzIiwibGF5ZXJfY3JlYXRlQ2xhc3MiLCJsYXllcl9MYXllciIsIkxheWVyIiwicmVmIiwicmVzb3VyY2VUeXBlIiwicHVibGljSWQiLCJnZXRQdWJsaWNJZCIsImdldEZ1bGxQdWJsaWNJZCIsImNvbXBvbmVudHMiLCJjbG9uZSIsInRleHRsYXllcl90eXBlb2YiLCJ0ZXh0bGF5ZXJfY2xhc3NDYWxsQ2hlY2siLCJ0ZXh0bGF5ZXJfZGVmaW5lUHJvcGVydGllcyIsInRleHRsYXllcl9jcmVhdGVDbGFzcyIsInRleHRsYXllcl9pbmhlcml0cyIsInRleHRsYXllcl9zZXRQcm90b3R5cGVPZiIsInRleHRsYXllcl9jcmVhdGVTdXBlciIsInRleHRsYXllcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJ0ZXh0bGF5ZXJfZ2V0UHJvdG90eXBlT2YiLCJ0ZXh0bGF5ZXJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInRleHRsYXllcl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJ0ZXh0bGF5ZXJfVGV4dExheWVyIiwiX0xheWVyIiwiVGV4dExheWVyIiwiX3Jlc291cmNlVHlwZSIsIl90eXBlIiwiX2Zvcm1hdCIsImZvbnRGYW1pbHkiLCJfZm9udEZhbWlseSIsImZvbnRTaXplIiwiX2ZvbnRTaXplIiwiZm9udFdlaWdodCIsIl9mb250V2VpZ2h0IiwiZm9udFN0eWxlIiwiX2ZvbnRTdHlsZSIsInRleHREZWNvcmF0aW9uIiwiX3RleHREZWNvcmF0aW9uIiwidGV4dEFsaWduIiwiX3RleHRBbGlnbiIsInN0cm9rZSIsIl9zdHJva2UiLCJsZXR0ZXJTcGFjaW5nIiwiX2xldHRlclNwYWNpbmciLCJsaW5lU3BhY2luZyIsIl9saW5lU3BhY2luZyIsImZvbnRIaW50aW5nIiwiX2ZvbnRIaW50aW5nIiwiZm9udEFudGlhbGlhc2luZyIsIl9mb250QW50aWFsaWFzaW5nIiwidGV4dCIsIl90ZXh0IiwidGV4dFN0eWxlIiwiX3RleHRTdHlsZSIsImhhc1B1YmxpY0lkIiwiaGFzU3R5bGUiLCJyZSIsInJlcyIsInRleHRTb3VyY2UiLCJ0ZXh0U3R5bGVJZGVudGlmaWVyIiwiaW5kZXgiLCJ1bnNoaWZ0Iiwic3VidGl0bGVzbGF5ZXJfdHlwZW9mIiwic3VidGl0bGVzbGF5ZXJfZGVmaW5lUHJvcGVydGllcyIsInN1YnRpdGxlc2xheWVyX2NyZWF0ZUNsYXNzIiwic3VidGl0bGVzbGF5ZXJfY2xhc3NDYWxsQ2hlY2siLCJzdWJ0aXRsZXNsYXllcl9pbmhlcml0cyIsInN1YnRpdGxlc2xheWVyX3NldFByb3RvdHlwZU9mIiwic3VidGl0bGVzbGF5ZXJfY3JlYXRlU3VwZXIiLCJzdWJ0aXRsZXNsYXllcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJzdWJ0aXRsZXNsYXllcl9nZXRQcm90b3R5cGVPZiIsInN1YnRpdGxlc2xheWVyX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJzdWJ0aXRsZXNsYXllcl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJTdWJ0aXRsZXNMYXllciIsIl9UZXh0TGF5ZXIiLCJmZXRjaGxheWVyX3R5cGVvZiIsImZldGNobGF5ZXJfY2xhc3NDYWxsQ2hlY2siLCJmZXRjaGxheWVyX2RlZmluZVByb3BlcnRpZXMiLCJmZXRjaGxheWVyX2NyZWF0ZUNsYXNzIiwiZmV0Y2hsYXllcl9pbmhlcml0cyIsImZldGNobGF5ZXJfc2V0UHJvdG90eXBlT2YiLCJmZXRjaGxheWVyX2NyZWF0ZVN1cGVyIiwiZmV0Y2hsYXllcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJmZXRjaGxheWVyX2dldFByb3RvdHlwZU9mIiwiZmV0Y2hsYXllcl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiZmV0Y2hsYXllcl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJmZXRjaGxheWVyX0ZldGNoTGF5ZXIiLCJGZXRjaExheWVyIiwiX3VybCIsInBhcmFtZXRlcnNfdHlwZW9mIiwiX2dldCIsInJlY2VpdmVyIiwiYmFzZSIsIl9zdXBlclByb3BCYXNlIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInBhcmFtZXRlcnNfZ2V0UHJvdG90eXBlT2YiLCJwYXJhbWV0ZXJzX2luaGVyaXRzIiwicGFyYW1ldGVyc19zZXRQcm90b3R5cGVPZiIsInBhcmFtZXRlcnNfY3JlYXRlU3VwZXIiLCJwYXJhbWV0ZXJzX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsInBhcmFtZXRlcnNfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInBhcmFtZXRlcnNfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwicGFyYW1ldGVyc19jbGFzc0NhbGxDaGVjayIsInBhcmFtZXRlcnNfZGVmaW5lUHJvcGVydGllcyIsInBhcmFtZXRlcnNfY3JlYXRlQ2xhc3MiLCJwYXJhbWV0ZXJzX1BhcmFtIiwiUGFyYW0iLCJzaG9ydE5hbWUiLCJvcmlnVmFsdWUiLCJ2YWxpZCIsIm5vcm1fY29sb3IiLCJidWlsZF9hcnJheSIsImFyZyIsInByb2Nlc3NfdmlkZW9fcGFyYW1zIiwicGFyYW0iLCJ2aWRlbyIsImNvZGVjIiwicHJvZmlsZSIsImxldmVsIiwiYl9mcmFtZXMiLCJwYXJhbWV0ZXJzX0FycmF5UGFyYW0iLCJfUGFyYW0iLCJBcnJheVBhcmFtIiwic2VwIiwiYXJyYXlWYWx1ZSIsImZsYXQiLCJfdGhpczIiLCJwYXJhbWV0ZXJzX1RyYW5zZm9ybWF0aW9uUGFyYW0iLCJfUGFyYW0yIiwiVHJhbnNmb3JtYXRpb25QYXJhbSIsIl9zdXBlcjIiLCJfdGhpczMiLCJfdGhpczQiLCJqb2luZWQiLCJvcmlnVmFsdWUxIiwibnVtYmVyX3BhdHRlcm4iLCJvZmZzZXRfYW55X3BhdHRlcm4iLCJwYXJhbWV0ZXJzX1JhbmdlUGFyYW0iLCJfUGFyYW0zIiwiUmFuZ2VQYXJhbSIsIl9zdXBlcjMiLCJub3JtX3JhbmdlX3ZhbHVlIiwib2Zmc2V0IiwibW9kaWZpZXIiLCJwYXJhbWV0ZXJzX1Jhd1BhcmFtIiwiX1BhcmFtNCIsIlJhd1BhcmFtIiwiX3N1cGVyNCIsInBhcmFtZXRlcnNfTGF5ZXJQYXJhbSIsIl9QYXJhbTUiLCJMYXllclBhcmFtIiwiX3N1cGVyNSIsImxheWVyT3B0aW9ucyIsImxheWVyIiwicGFyYW1ldGVyc19FeHByZXNzaW9uUGFyYW0iLCJfUGFyYW02IiwiRXhwcmVzc2lvblBhcmFtIiwiX3N1cGVyNiIsInRyYW5zZm9ybWF0aW9uX3R5cGVvZiIsInRyYW5zZm9ybWF0aW9uX2luaGVyaXRzIiwidHJhbnNmb3JtYXRpb25fc2V0UHJvdG90eXBlT2YiLCJ0cmFuc2Zvcm1hdGlvbl9jcmVhdGVTdXBlciIsInRyYW5zZm9ybWF0aW9uX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsInRyYW5zZm9ybWF0aW9uX2dldFByb3RvdHlwZU9mIiwidHJhbnNmb3JtYXRpb25fcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInRyYW5zZm9ybWF0aW9uX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInRyYW5zZm9ybWF0aW9uX3NsaWNlZFRvQXJyYXkiLCJ0cmFuc2Zvcm1hdGlvbl9hcnJheVdpdGhIb2xlcyIsInRyYW5zZm9ybWF0aW9uX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwidHJhbnNmb3JtYXRpb25fdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJ0cmFuc2Zvcm1hdGlvbl9ub25JdGVyYWJsZVJlc3QiLCJ0cmFuc2Zvcm1hdGlvbl9hcnJheUxpa2VUb0FycmF5IiwidHJhbnNmb3JtYXRpb25fY2xhc3NDYWxsQ2hlY2siLCJ0cmFuc2Zvcm1hdGlvbl9kZWZpbmVQcm9wZXJ0aWVzIiwidHJhbnNmb3JtYXRpb25fY3JlYXRlQ2xhc3MiLCJhc3NpZ25Ob3ROdWxsIiwidHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb25CYXNlIiwiVHJhbnNmb3JtYXRpb25CYXNlIiwidHJhbnMiLCJ3aXRoQ2hhaW4iLCJvcHQiLCJvdGhlck9wdGlvbnMiLCJjaGFpbmVkIiwidHIiLCJmcm9tT3B0aW9ucyIsImFiYnIiLCJkZWZhdWx0VmFsdWUiLCJyYXdQYXJhbSIsImxhc3RBcmdDYWxsYmFjayIsInJhbmdlUGFyYW0iLCJhcnJheVBhcmFtIiwidHJhbnNmb3JtYXRpb25QYXJhbSIsImxheWVyUGFyYW0iLCJnZXRWYWx1ZSIsInJlbW92ZSIsInRlbXAiLCJWQVJfTkFNRV9SRSIsInNvcnQiLCJ0b1BsYWluT2JqZWN0IiwiaGFzaCIsImNoYWluIiwibmFtZXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwicmVzZXRUcmFuc2Zvcm1hdGlvbnMiLCJmcm9tVHJhbnNmb3JtYXRpb24iLCJvdGhlciIsImNhbWVsS2V5IiwiX2xlbjIiLCJ2YWx1ZXMiLCJfa2V5MiIsInRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uIiwibWV0aG9kcyIsImhhc0xheWVyIiwiaWZQYXJhbSIsImoiLCJwYXJhbUxpc3QiLCJyZWYxIiwicmVmMiIsInJlZjMiLCJyZWY0IiwicmVzdWx0QXJyYXkiLCJ0cmFuc2Zvcm1hdGlvbkxpc3QiLCJ0cmFuc2Zvcm1hdGlvblN0cmluZyIsInZhcnMiLCJwcm9jZXNzVmFyIiwibGVuMSIsInBhcmFtX3NlcGFyYXRvciIsInRyYW5zX3NlcGFyYXRvciIsInRvSHRtbEF0dHJpYnV0ZXMiLCJhdHRyTmFtZSIsInNuYWtlQ2FzZUtleSIsIlBBUkFNX05BTUVTIiwidG9IdG1sIiwibGlzdE5hbWVzIiwiaXNWYWxpZFBhcmFtTmFtZSIsImluZGV4T2YiLCJhcmdzIiwiY2FsbGJhY2siLCJ2YXJBcnJheSIsIl92YXJBcnJheSRqIiwicHJvY2Vzc0N1c3RvbUZ1bmN0aW9uIiwiX3JlZiIsImZ1bmN0aW9uX3R5cGUiLCJfVHJhbnNmb3JtYXRpb25CYXNlIiwiVHJhbnNmb3JtYXRpb24iLCJhbmdsZSIsImF1ZGlvQ29kZWMiLCJhdWRpb0ZyZXF1ZW5jeSIsImJpdFJhdGUiLCJib3JkZXIiLCJjb2xvciIsImNvbG9yU3BhY2UiLCJjdXN0b21GdW5jdGlvbiIsImN1c3RvbVByZUZ1bmN0aW9uIiwiZGVmYXVsdEltYWdlIiwiZGVsYXkiLCJkZW5zaXR5IiwiZHByIiwiX2Vsc2UiLCJlbmRJZiIsImVuZE9mZnNldCIsImZhbGxiYWNrQ29udGVudCIsImZldGNoRm9ybWF0IiwiZmxhZ3MiLCJmcHMiLCJodG1sSGVpZ2h0IiwiaHRtbFdpZHRoIiwiX2lmIiwiaWZWYWwiLCJ0cklmIiwidHJSZXN0Iiwia2V5ZnJhbWVJbnRlcnZhbCIsIm9jciIsImVuZF9vIiwic3RhcnRfbyIsIl9yZWYyIiwiX3JlZjMiLCJzdGFydE9mZnNldCIsIm9wYWNpdHkiLCJvdmVybGF5IiwicGFnZSIsInBvc3RlciIsInByZWZpeCIsInJhZGl1cyIsInJhd1RyYW5zZm9ybWF0aW9uIiwic291cmNlVHlwZXMiLCJzb3VyY2VUcmFuc2Zvcm1hdGlvbiIsInN0cmVhbWluZ1Byb2ZpbGUiLCJ1bmRlcmxheSIsInZpZGVvQ29kZWMiLCJ2aWRlb1NhbXBsaW5nIiwiem9vbSIsImh0bWx0YWdfY2xhc3NDYWxsQ2hlY2siLCJodG1sdGFnX2RlZmluZVByb3BlcnRpZXMiLCJodG1sdGFnX2NyZWF0ZUNsYXNzIiwiaHRtbHRhZ19IdG1sVGFnIiwiSHRtbFRhZyIsImh0bWxBdHRycyIsImF0dHJzIiwicGFpcnMiLCJlc2NhcGVRdW90ZXMiLCJodG1sdGFnX3RvQXR0cmlidXRlIiwiZ2V0T3B0aW9ucyIsImdldE9wdGlvbiIsImh0bWxBdHRyaWJ1dGVzIiwicmVtb3ZlQXR0ciIsImNvbnRlbnQiLCJvcGVuVGFnIiwidGFnIiwiY2xvc2VUYWciLCJ0b0RPTSIsImNyZWF0ZUVsZW1lbnQiLCJpc1Jlc3BvbnNpdmUiLCJyZXNwb25zaXZlQ2xhc3MiLCJkYXRhU3JjIiwiX2V4Y2x1ZGVkIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiZXhjbHVkZWQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImdldE93blByb3BlcnR5U3ltYm9scyIsInNvdXJjZVN5bWJvbEtleXMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInNvdXJjZUtleXMiLCJtYWtlVXJsIiwiaG9zdCIsInBhdGhuYW1lIiwiaXNVcmwiLCJjZG5TdWJkb21haW5OdW1iZXIiLCJoYW5kbGVTaWduYXR1cmUiLCJzaWduYXR1cmUiLCJpc0Zvcm1hdHRlZCIsImhhbmRsZVByZWZpeCIsImNsb3VkX25hbWUiLCJjZG5QYXJ0Iiwic3ViZG9tYWluIiwicGF0aCIsInByaXZhdGVfY2RuIiwiY2RuX3N1YmRvbWFpbiIsInNlY3VyZV9jZG5fc3ViZG9tYWluIiwic2VjdXJlX2Rpc3RyaWJ1dGlvbiIsImNuYW1lIiwiaGFuZGxlUmVzb3VyY2VUeXBlIiwiX3JlZiRyZXNvdXJjZV90eXBlIiwiX3JlZiR0eXBlIiwidXJsX3N1ZmZpeCIsInVzZV9yb290X3BhdGgiLCJzaG9ydGVuIiwiZW5jb2RlUHVibGljSWQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJmb3JtYXRQdWJsaWNJZCIsImRlY29kZVVSSUNvbXBvbmVudCIsImVycm9yIiwidHJ1c3RfcHVibGljX2lkIiwidmFsaWRhdGUiLCJoYW5kbGVWZXJzaW9uIiwiaXNGb3JjZVZlcnNpb24iLCJmb3JjZV92ZXJzaW9uIiwiaXNWZXJzaW9uRXhpc3QiLCJ2ZXJzaW9uIiwiaGFuZGxlVHJhbnNmb3JtYXRpb24iLCJwbGFjZWhvbGRlclRyYW5zZm9ybWF0aW9ucyIsImJsdXIiLCJwcmVwYXJlUHVibGljSWQiLCJ1cmxTdHJpbmciLCJwcmVwYXJlT3B0aW9ucyIsInVybF91cmwiLCJyZXN1bHRVcmwiLCJzZGtBbmFseXRpY3NTaWduYXR1cmUiLCJhcHBlbmRlciIsImF1dGhfdG9rZW4iLCJfYXBwZW5kZXIiLCJnZW5lcmF0ZUJyZWFrcG9pbnRzX3NsaWNlZFRvQXJyYXkiLCJnZW5lcmF0ZUJyZWFrcG9pbnRzX2FycmF5V2l0aEhvbGVzIiwiZ2VuZXJhdGVCcmVha3BvaW50c19pdGVyYWJsZVRvQXJyYXlMaW1pdCIsImdlbmVyYXRlQnJlYWtwb2ludHNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJnZW5lcmF0ZUJyZWFrcG9pbnRzX25vbkl0ZXJhYmxlUmVzdCIsImdlbmVyYXRlQnJlYWtwb2ludHNfYXJyYXlMaWtlVG9BcnJheSIsImdlbmVyYXRlQnJlYWtwb2ludHMiLCJzcmNzZXQiLCJicmVha3BvaW50cyIsIl9tYXAiLCJtaW5fd2lkdGgiLCJtYXhfd2lkdGgiLCJtYXhfaW1hZ2VzIiwiTnVtYmVyIiwiX21hcDIiLCJzb21lIiwic3RlcFNpemUiLCJNYXRoIiwiY2VpbCIsIm1heCIsImN1cnJlbnQiLCJzcmNzZXRVdGlsc19pc0VtcHR5Iiwic2NhbGVkVXJsIiwicHVibGljX2lkIiwiY29uZmlnUGFyYW1zIiwicmF3X3RyYW5zZm9ybWF0aW9uIiwiZ2V0T3JHZW5lcmF0ZUJyZWFrcG9pbnRzIiwiZ2VuZXJhdGVTcmNzZXRBdHRyaWJ1dGUiLCJnZW5lcmF0ZVNpemVzQXR0cmlidXRlIiwiZ2VuZXJhdGVJbWFnZVJlc3BvbnNpdmVBdHRyaWJ1dGVzIiwic3Jjc2V0RGF0YSIsInJlc3BvbnNpdmVBdHRyaWJ1dGVzIiwiZ2VuZXJhdGVTaXplcyIsInNpemVzIiwiZ2VuZXJhdGVTcmNzZXQiLCJzcmNzZXRBdHRyIiwic2l6ZXNBdHRyIiwiZ2VuZXJhdGVNZWRpYUF0dHIiLCJtZWRpYVF1ZXJ5Iiwic3Jjc2V0VXJsIiwiaW1hZ2V0YWdfdHlwZW9mIiwiaW1hZ2V0YWdfY2xhc3NDYWxsQ2hlY2siLCJpbWFnZXRhZ19kZWZpbmVQcm9wZXJ0aWVzIiwiaW1hZ2V0YWdfY3JlYXRlQ2xhc3MiLCJpbWFnZXRhZ19nZXQiLCJpbWFnZXRhZ19zdXBlclByb3BCYXNlIiwiaW1hZ2V0YWdfZ2V0UHJvdG90eXBlT2YiLCJpbWFnZXRhZ19pbmhlcml0cyIsImltYWdldGFnX3NldFByb3RvdHlwZU9mIiwiaW1hZ2V0YWdfY3JlYXRlU3VwZXIiLCJpbWFnZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJpbWFnZXRhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiaW1hZ2V0YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiaW1hZ2V0YWdfSW1hZ2VUYWciLCJfSHRtbFRhZyIsIkltYWdlVGFnIiwic3JjQXR0cmlidXRlIiwic3Jjc2V0UGFyYW0iLCJjbGllbnRfaGludHMiLCJzb3VyY2V0YWdfdHlwZW9mIiwic291cmNldGFnX2NsYXNzQ2FsbENoZWNrIiwic291cmNldGFnX2RlZmluZVByb3BlcnRpZXMiLCJzb3VyY2V0YWdfY3JlYXRlQ2xhc3MiLCJzb3VyY2V0YWdfZ2V0Iiwic291cmNldGFnX3N1cGVyUHJvcEJhc2UiLCJzb3VyY2V0YWdfZ2V0UHJvdG90eXBlT2YiLCJzb3VyY2V0YWdfaW5oZXJpdHMiLCJzb3VyY2V0YWdfc2V0UHJvdG90eXBlT2YiLCJzb3VyY2V0YWdfY3JlYXRlU3VwZXIiLCJzb3VyY2V0YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0Iiwic291cmNldGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJzb3VyY2V0YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwic291cmNldGFnX1NvdXJjZVRhZyIsIlNvdXJjZVRhZyIsIm1lZGlhIiwic291cmNldGFnIiwicGljdHVyZXRhZ190eXBlb2YiLCJwaWN0dXJldGFnX2NsYXNzQ2FsbENoZWNrIiwicGljdHVyZXRhZ19kZWZpbmVQcm9wZXJ0aWVzIiwicGljdHVyZXRhZ19jcmVhdGVDbGFzcyIsInBpY3R1cmV0YWdfZ2V0IiwicGljdHVyZXRhZ19zdXBlclByb3BCYXNlIiwicGljdHVyZXRhZ19nZXRQcm90b3R5cGVPZiIsInBpY3R1cmV0YWdfaW5oZXJpdHMiLCJwaWN0dXJldGFnX3NldFByb3RvdHlwZU9mIiwicGljdHVyZXRhZ19jcmVhdGVTdXBlciIsInBpY3R1cmV0YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwicGljdHVyZXRhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwicGljdHVyZXRhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJwaWN0dXJldGFnX1BpY3R1cmVUYWciLCJQaWN0dXJlVGFnIiwid2lkdGhMaXN0IiwidmlkZW90YWdfdHlwZW9mIiwidmlkZW90YWdfY2xhc3NDYWxsQ2hlY2siLCJ2aWRlb3RhZ19kZWZpbmVQcm9wZXJ0aWVzIiwidmlkZW90YWdfY3JlYXRlQ2xhc3MiLCJ2aWRlb3RhZ19nZXQiLCJ2aWRlb3RhZ19zdXBlclByb3BCYXNlIiwidmlkZW90YWdfZ2V0UHJvdG90eXBlT2YiLCJ2aWRlb3RhZ19pbmhlcml0cyIsInZpZGVvdGFnX3NldFByb3RvdHlwZU9mIiwidmlkZW90YWdfY3JlYXRlU3VwZXIiLCJ2aWRlb3RhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJ2aWRlb3RhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwidmlkZW90YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiVklERU9fVEFHX1BBUkFNUyIsInZpZGVvdGFnX0RFRkFVTFRfVklERU9fU09VUkNFX1RZUEVTIiwidmlkZW90YWdfREVGQVVMVF9QT1NURVJfT1BUSU9OUyIsInZpZGVvdGFnX1ZpZGVvVGFnIiwiVmlkZW9UYWciLCJzZXRTb3VyY2VUcmFuc2Zvcm1hdGlvbiIsInNldFNvdXJjZVR5cGVzIiwic2V0UG9zdGVyIiwic2V0RmFsbGJhY2tDb250ZW50IiwiZmFsbGJhY2siLCJpbm5lclRhZ3MiLCJzcmMiLCJjcmVhdGVTb3VyY2VUYWciLCJzcmNUeXBlIiwiZGVmYXVsdE9wdGlvbnMiLCJoYXNTb3VyY2VUYWdzIiwic291cmNlVHlwZSIsIm1pbWVUeXBlIiwidmlkZW9UeXBlIiwiY29kZWNzU3RyIiwiY2xpZW50aGludHNtZXRhdGFnX3R5cGVvZiIsImNsaWVudGhpbnRzbWV0YXRhZ19jbGFzc0NhbGxDaGVjayIsImNsaWVudGhpbnRzbWV0YXRhZ19kZWZpbmVQcm9wZXJ0aWVzIiwiY2xpZW50aGludHNtZXRhdGFnX2NyZWF0ZUNsYXNzIiwiY2xpZW50aGludHNtZXRhdGFnX2luaGVyaXRzIiwiY2xpZW50aGludHNtZXRhdGFnX3NldFByb3RvdHlwZU9mIiwiY2xpZW50aGludHNtZXRhdGFnX2NyZWF0ZVN1cGVyIiwiY2xpZW50aGludHNtZXRhdGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsImNsaWVudGhpbnRzbWV0YXRhZ19nZXRQcm90b3R5cGVPZiIsImNsaWVudGhpbnRzbWV0YXRhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiY2xpZW50aGludHNtZXRhdGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsImNsaWVudGhpbnRzbWV0YXRhZ19DbGllbnRIaW50c01ldGFUYWciLCJDbGllbnRIaW50c01ldGFUYWciLCJub3JtYWxpemVUb0FycmF5X3RvQ29uc3VtYWJsZUFycmF5Iiwibm9ybWFsaXplVG9BcnJheV9hcnJheVdpdGhvdXRIb2xlcyIsIm5vcm1hbGl6ZVRvQXJyYXlfaXRlcmFibGVUb0FycmF5Iiwibm9ybWFsaXplVG9BcnJheV91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIm5vcm1hbGl6ZVRvQXJyYXlfbm9uSXRlcmFibGVTcHJlYWQiLCJub3JtYWxpemVUb0FycmF5X2FycmF5TGlrZVRvQXJyYXkiLCJub3JtYWxpemVUb0FycmF5IiwiZWxlbWVudHMiLCJtb3VudENsb3VkaW5hcnlWaWRlb1RhZyIsImh0bWxFbENvbnRhaW5lciIsImNsSW5zdGFuY2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImlubmVySFRNTCIsInZpZGVvVGFnIiwiY2xvdWRpbmFyeVZpZGVvRWxlbWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJ0cmFuc3BhcmVudFZpZGVvX21vdW50Q2xvdWRpbmFyeVZpZGVvVGFnIiwiYWRkRmxhZ1RvT3B0aW9ucyIsImZsYWciLCJhZGRGbGFnIiwiZW5mb3JjZU9wdGlvbnNGb3JUcmFuc3BhcmVudFZpZGVvIiwiYXV0b3BsYXkiLCJtdXRlZCIsImNvbnRyb2xzIiwibWF4X3RpbWVvdXRfbXMiLCJleHRlcm5hbExpYnJhcmllcyIsInRyYW5zcGFyZW50VmlkZW9fZW5mb3JjZU9wdGlvbnNGb3JUcmFuc3BhcmVudFZpZGVvIiwibG9hZFNjcmlwdCIsInNjcmlwdFVSTCIsImlzQWxyZWFkeUxvYWRlZCIsInNjcmlwdFRhZyIsInRpbWVySUQiLCJzZXRUaW1lb3V0Iiwic3RhdHVzIiwibWVzc2FnZSIsIm9uZXJyb3IiLCJjbGVhclRpbWVvdXQiLCJvbmxvYWQiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJ4aHJfbG9hZFNjcmlwdCIsInJlamVjdE9uVGltZW91dCIsIm1heFRpbWVvdXRNUyIsImdldEJsb2JGcm9tVVJMIiwidXJsVG9Mb2FkIiwiZmV0Y2hCbG9iIiwiZmV0Y2giLCJsb2FkVXJsVXNpbmdGZXRjaCIsImxvYWRVcmxVc2luZ1hociIsImJsb2IiLCJwYXlsb2FkIiwiYmxvYlVSTCIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsInJlc3BvbnNlIiwieGhyIiwiWE1MSHR0cFJlcXVlc3QiLCJyZXNwb25zZVR5cGUiLCJvcGVuIiwic2VuZCIsInhocl9nZXRCbG9iRnJvbVVSTCIsImNyZWF0ZUhpZGRlblZpZGVvVGFnIiwidmlkZW9PcHRpb25zIiwicGxheXNpbmxpbmUiLCJsb29wIiwidmlkZW9VUkwiLCJ2aXNpYmlsaXR5IiwicG9zaXRpb24iLCJyZXZva2VPYmplY3RVUkwiLCJ0cmFuc3BhcmVudFZpZGVvX2NyZWF0ZUhpZGRlblZpZGVvVGFnIiwiaW5zdGFudGlhdGVTZWVUaHJ1IiwidmlkZW9FbGVtZW50IiwiY3VzdG9tQ2xhc3MiLCJhdXRvUGxheSIsIl93aW5kb3ciLCJzZWVUaHJ1SW5zdGFuY2UiLCJyZWFkeSIsImNhbnZhc0VsZW1lbnQiLCJnZXRDYW52YXMiLCJwbGF5IiwidHJhbnNwYXJlbnRWaWRlb19pbnN0YW50aWF0ZVNlZVRocnUiLCJtb3VudFNlZVRocnVDYW52YXNUYWciLCJ0cmFuc3BhcmVudFZpZGVvX21vdW50U2VlVGhydUNhbnZhc1RhZyIsImNoZWNrU3VwcG9ydEZvclRyYW5zcGFyZW5jeSIsImNhblBsYXkiLCJjYW5QbGF5VHlwZSIsInRyYW5zcGFyZW50VmlkZW9fY2hlY2tTdXBwb3J0Rm9yVHJhbnNwYXJlbmN5IiwiY2xvdWRpbmFyeV9jbGFzc0NhbGxDaGVjayIsImNsb3VkaW5hcnlfZGVmaW5lUHJvcGVydGllcyIsImNsb3VkaW5hcnlfY3JlYXRlQ2xhc3MiLCJhcHBseUJyZWFrcG9pbnRzIiwiY2xvc2VzdEFib3ZlIiwiZGVmYXVsdEJyZWFrcG9pbnRzIiwiY2xvdWRpbmFyeV9maW5kQ29udGFpbmVyV2lkdGgiLCJjbG91ZGluYXJ5X21heFdpZHRoIiwidXBkYXRlRHByIiwic3RlcHMiLCJyZXNpemluZyIsImNhbGNfYnJlYWtwb2ludCIsImZpbmRDb250YWluZXJXaWR0aCIsImNvbnRhaW5lcldpZHRoIiwiRWxlbWVudCIsImRpc3BsYXkiLCJyb3VuZERwciIsImRldmljZV9waXhlbF9yYXRpbyIsInJlcXVpcmVkV2lkdGgiLCJpbWFnZVdpZHRoIiwiY2xvdWRpbmFyeV9DbG91ZGluYXJ5IiwiQ2xvdWRpbmFyeSIsImRldmljZVBpeGVsUmF0aW9DYWNoZSIsInJlc3BvbnNpdmVDb25maWciLCJyZXNwb25zaXZlUmVzaXplSW5pdGlhbGl6ZWQiLCJuZXdDb25maWciLCJuZXdWYWx1ZSIsInZpZGVvX3VybCIsInZpZGVvX3RodW1ibmFpbF91cmwiLCJ0cmFuc2Zvcm1hdGlvbl9zdHJpbmciLCJpbWFnZSIsImltZyIsImltYWdlVGFnIiwiY2xvdWRpbmFyeV91cGRhdGUiLCJwaWN0dXJlVGFnIiwic291cmNlVGFnIiwidmlkZW9fdGh1bWJuYWlsIiwiZmFjZWJvb2tfcHJvZmlsZV9pbWFnZSIsInR3aXR0ZXJfcHJvZmlsZV9pbWFnZSIsInR3aXR0ZXJfbmFtZV9wcm9maWxlX2ltYWdlIiwiZ3JhdmF0YXJfaW1hZ2UiLCJmZXRjaF9pbWFnZSIsInNwcml0ZV9jc3MiLCJib290c3RyYXAiLCJyZXNwb25zaXZlUmVzaXplIiwidGltZW91dCIsInJlc3BvbnNpdmVfcmVzaXplIiwibWFrZVJlc3BvbnNpdmUiLCJkZWJvdW5jZSIsInJlc2V0IiwicnVuIiwid2FpdCIsIndhaXRGdW5jIiwicmVzcG9uc2l2ZV9kZWJvdW5jZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicG9pbnQiLCJjYWxjX3N0b3Bwb2ludCIsImRldmljZVBpeGVsUmF0aW8iLCJkcHJTdHJpbmciLCJwcm9jZXNzSW1hZ2VUYWdzIiwibm9kZXMiLCJpbWFnZXMiLCJub2RlIiwidGFnTmFtZSIsImltZ09wdGlvbnMiLCJzZXRVcmwiLCJyZXNwb25zaXZlX3ByZXNlcnZlX2hlaWdodCIsImlzTGF6eUxvYWRpbmciLCJpc0xhenlMb2FkU3VwcG9ydGVkIiwic2V0QXR0cmlidXRlSWZFeGlzdHMiLCJ0b0F0dHJpYnV0ZSIsImZyb21BdHRyaWJ1dGUiLCJhdHRyaWJ1dGVWYWx1ZSIsImluamVjdFRyYW5zcGFyZW50VmlkZW9FbGVtZW50IiwiaXNOYXRpdmVseVRyYW5zcGFyZW50IiwibW91bnRQcm9taXNlIiwiY2xvdWRpbmFyeV9jb3JlIiwiVXRpbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/cloudinary-core/cloudinary-core.js\n");

/***/ })

};
;